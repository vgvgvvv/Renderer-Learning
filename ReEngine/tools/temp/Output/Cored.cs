// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Cored
{
    public enum ImGuiWindowFlags
    {
        ImGuiWindowFlagsNone = 0,
        ImGuiWindowFlagsNoTitleBar = 1,
        ImGuiWindowFlagsNoResize = 2,
        ImGuiWindowFlagsNoMove = 4,
        ImGuiWindowFlagsNoScrollbar = 8,
        ImGuiWindowFlagsNoScrollWithMouse = 16,
        ImGuiWindowFlagsNoCollapse = 32,
        ImGuiWindowFlagsAlwaysAutoResize = 64,
        ImGuiWindowFlagsNoBackground = 128,
        ImGuiWindowFlagsNoSavedSettings = 256,
        ImGuiWindowFlagsNoMouseInputs = 512,
        ImGuiWindowFlagsMenuBar = 1024,
        ImGuiWindowFlagsHorizontalScrollbar = 2048,
        ImGuiWindowFlagsNoFocusOnAppearing = 4096,
        ImGuiWindowFlagsNoBringToFrontOnFocus = 8192,
        ImGuiWindowFlagsAlwaysVerticalScrollbar = 16384,
        ImGuiWindowFlagsAlwaysHorizontalScrollbar = 32768,
        ImGuiWindowFlagsAlwaysUseWindowPadding = 65536,
        ImGuiWindowFlagsNoNavInputs = 262144,
        ImGuiWindowFlagsNoNavFocus = 524288,
        ImGuiWindowFlagsUnsavedDocument = 1048576,
        ImGuiWindowFlagsNoDocking = 2097152,
        ImGuiWindowFlagsNoNav = 786432,
        ImGuiWindowFlagsNoDecoration = 43,
        ImGuiWindowFlagsNoInputs = 786944,
        ImGuiWindowFlagsNavFlattened = 8388608,
        ImGuiWindowFlagsChildWindow = 16777216,
        ImGuiWindowFlagsTooltip = 33554432,
        ImGuiWindowFlagsPopup = 67108864,
        ImGuiWindowFlagsModal = 134217728,
        ImGuiWindowFlagsChildMenu = 268435456,
        ImGuiWindowFlagsDockNodeHost = 536870912
    }

    [Flags]
    public enum ImGuiInputTextFlags
    {
        ImGuiInputTextFlagsNone = 0,
        ImGuiInputTextFlagsCharsDecimal = 1,
        ImGuiInputTextFlagsCharsHexadecimal = 2,
        ImGuiInputTextFlagsCharsUppercase = 4,
        ImGuiInputTextFlagsCharsNoBlank = 8,
        ImGuiInputTextFlagsAutoSelectAll = 16,
        ImGuiInputTextFlagsEnterReturnsTrue = 32,
        ImGuiInputTextFlagsCallbackCompletion = 64,
        ImGuiInputTextFlagsCallbackHistory = 128,
        ImGuiInputTextFlagsCallbackAlways = 256,
        ImGuiInputTextFlagsCallbackCharFilter = 512,
        ImGuiInputTextFlagsAllowTabInput = 1024,
        ImGuiInputTextFlagsCtrlEnterForNewLine = 2048,
        ImGuiInputTextFlagsNoHorizontalScroll = 4096,
        ImGuiInputTextFlagsAlwaysOverwrite = 8192,
        ImGuiInputTextFlagsReadOnly = 16384,
        ImGuiInputTextFlagsPassword = 32768,
        ImGuiInputTextFlagsNoUndoRedo = 65536,
        ImGuiInputTextFlagsCharsScientific = 131072,
        ImGuiInputTextFlagsCallbackResize = 262144,
        ImGuiInputTextFlagsCallbackEdit = 524288,
        ImGuiInputTextFlagsAlwaysInsertMode = 8192
    }

    public enum ImGuiTreeNodeFlags
    {
        ImGuiTreeNodeFlagsNone = 0,
        ImGuiTreeNodeFlagsSelected = 1,
        ImGuiTreeNodeFlagsFramed = 2,
        ImGuiTreeNodeFlagsAllowItemOverlap = 4,
        ImGuiTreeNodeFlagsNoTreePushOnOpen = 8,
        ImGuiTreeNodeFlagsNoAutoOpenOnLog = 16,
        ImGuiTreeNodeFlagsDefaultOpen = 32,
        ImGuiTreeNodeFlagsOpenOnDoubleClick = 64,
        ImGuiTreeNodeFlagsOpenOnArrow = 128,
        ImGuiTreeNodeFlagsLeaf = 256,
        ImGuiTreeNodeFlagsBullet = 512,
        ImGuiTreeNodeFlagsFramePadding = 1024,
        ImGuiTreeNodeFlagsSpanAvailWidth = 2048,
        ImGuiTreeNodeFlagsSpanFullWidth = 4096,
        ImGuiTreeNodeFlagsNavLeftJumpsBackHere = 8192,
        ImGuiTreeNodeFlagsCollapsingHeader = 26
    }

    public enum ImGuiPopupFlags
    {
        ImGuiPopupFlagsNone = 0,
        ImGuiPopupFlagsMouseButtonLeft = 0,
        ImGuiPopupFlagsMouseButtonRight = 1,
        ImGuiPopupFlagsMouseButtonMiddle = 2,
        ImGuiPopupFlagsMouseButtonMask = 31,
        ImGuiPopupFlagsMouseButtonDefault = 1,
        ImGuiPopupFlagsNoOpenOverExistingPopup = 32,
        ImGuiPopupFlagsNoOpenOverItems = 64,
        ImGuiPopupFlagsAnyPopupId = 128,
        ImGuiPopupFlagsAnyPopupLevel = 256,
        ImGuiPopupFlagsAnyPopup = 384
    }

    [Flags]
    public enum ImGuiSelectableFlags
    {
        ImGuiSelectableFlagsNone = 0,
        ImGuiSelectableFlagsDontClosePopups = 1,
        ImGuiSelectableFlagsSpanAllColumns = 2,
        ImGuiSelectableFlagsAllowDoubleClick = 4,
        ImGuiSelectableFlagsDisabled = 8,
        ImGuiSelectableFlagsAllowItemOverlap = 16
    }

    public enum ImGuiComboFlags
    {
        ImGuiComboFlagsNone = 0,
        ImGuiComboFlagsPopupAlignLeft = 1,
        ImGuiComboFlagsHeightSmall = 2,
        ImGuiComboFlagsHeightRegular = 4,
        ImGuiComboFlagsHeightLarge = 8,
        ImGuiComboFlagsHeightLargest = 16,
        ImGuiComboFlagsNoArrowButton = 32,
        ImGuiComboFlagsNoPreview = 64,
        ImGuiComboFlagsHeightMask = 30
    }

    public enum ImGuiTabBarFlags
    {
        ImGuiTabBarFlagsNone = 0,
        ImGuiTabBarFlagsReorderable = 1,
        ImGuiTabBarFlagsAutoSelectNewTabs = 2,
        ImGuiTabBarFlagsTabListPopupButton = 4,
        ImGuiTabBarFlagsNoCloseWithMiddleMouseButton = 8,
        ImGuiTabBarFlagsNoTabListScrollingButtons = 16,
        ImGuiTabBarFlagsNoTooltip = 32,
        ImGuiTabBarFlagsFittingPolicyResizeDown = 64,
        ImGuiTabBarFlagsFittingPolicyScroll = 128,
        ImGuiTabBarFlagsFittingPolicyMask = 192,
        ImGuiTabBarFlagsFittingPolicyDefault = 64
    }

    [Flags]
    public enum ImGuiTabItemFlags
    {
        ImGuiTabItemFlagsNone = 0,
        ImGuiTabItemFlagsUnsavedDocument = 1,
        ImGuiTabItemFlagsSetSelected = 2,
        ImGuiTabItemFlagsNoCloseWithMiddleMouseButton = 4,
        ImGuiTabItemFlagsNoPushId = 8,
        ImGuiTabItemFlagsNoTooltip = 16,
        ImGuiTabItemFlagsNoReorder = 32,
        ImGuiTabItemFlagsLeading = 64,
        ImGuiTabItemFlagsTrailing = 128
    }

    public enum ImGuiTableFlags
    {
        ImGuiTableFlagsNone = 0,
        ImGuiTableFlagsResizable = 1,
        ImGuiTableFlagsReorderable = 2,
        ImGuiTableFlagsHideable = 4,
        ImGuiTableFlagsSortable = 8,
        ImGuiTableFlagsNoSavedSettings = 16,
        ImGuiTableFlagsContextMenuInBody = 32,
        ImGuiTableFlagsRowBg = 64,
        ImGuiTableFlagsBordersInnerH = 128,
        ImGuiTableFlagsBordersOuterH = 256,
        ImGuiTableFlagsBordersInnerV = 512,
        ImGuiTableFlagsBordersOuterV = 1024,
        ImGuiTableFlagsBordersH = 384,
        ImGuiTableFlagsBordersV = 1536,
        ImGuiTableFlagsBordersInner = 640,
        ImGuiTableFlagsBordersOuter = 1280,
        ImGuiTableFlagsBorders = 1920,
        ImGuiTableFlagsNoBordersInBody = 2048,
        ImGuiTableFlagsNoBordersInBodyUntilResize = 4096,
        ImGuiTableFlagsSizingFixedFit = 8192,
        ImGuiTableFlagsSizingFixedSame = 16384,
        ImGuiTableFlagsSizingStretchProp = 24576,
        ImGuiTableFlagsSizingStretchSame = 32768,
        ImGuiTableFlagsNoHostExtendX = 65536,
        ImGuiTableFlagsNoHostExtendY = 131072,
        ImGuiTableFlagsNoKeepColumnsVisible = 262144,
        ImGuiTableFlagsPreciseWidths = 524288,
        ImGuiTableFlagsNoClip = 1048576,
        ImGuiTableFlagsPadOuterX = 2097152,
        ImGuiTableFlagsNoPadOuterX = 4194304,
        ImGuiTableFlagsNoPadInnerX = 8388608,
        ImGuiTableFlagsScrollX = 16777216,
        ImGuiTableFlagsScrollY = 33554432,
        ImGuiTableFlagsSortMulti = 67108864,
        ImGuiTableFlagsSortTristate = 134217728,
        ImGuiTableFlagsSizingMask = 57344
    }

    public enum ImGuiTableColumnFlags
    {
        ImGuiTableColumnFlagsNone = 0,
        ImGuiTableColumnFlagsDisabled = 1,
        ImGuiTableColumnFlagsDefaultHide = 2,
        ImGuiTableColumnFlagsDefaultSort = 4,
        ImGuiTableColumnFlagsWidthStretch = 8,
        ImGuiTableColumnFlagsWidthFixed = 16,
        ImGuiTableColumnFlagsNoResize = 32,
        ImGuiTableColumnFlagsNoReorder = 64,
        ImGuiTableColumnFlagsNoHide = 128,
        ImGuiTableColumnFlagsNoClip = 256,
        ImGuiTableColumnFlagsNoSort = 512,
        ImGuiTableColumnFlagsNoSortAscending = 1024,
        ImGuiTableColumnFlagsNoSortDescending = 2048,
        ImGuiTableColumnFlagsNoHeaderLabel = 4096,
        ImGuiTableColumnFlagsNoHeaderWidth = 8192,
        ImGuiTableColumnFlagsPreferSortAscending = 16384,
        ImGuiTableColumnFlagsPreferSortDescending = 32768,
        ImGuiTableColumnFlagsIndentEnable = 65536,
        ImGuiTableColumnFlagsIndentDisable = 131072,
        ImGuiTableColumnFlagsIsEnabled = 16777216,
        ImGuiTableColumnFlagsIsVisible = 33554432,
        ImGuiTableColumnFlagsIsSorted = 67108864,
        ImGuiTableColumnFlagsIsHovered = 134217728,
        ImGuiTableColumnFlagsWidthMask = 24,
        ImGuiTableColumnFlagsIndentMask = 196608,
        ImGuiTableColumnFlagsStatusMask = 251658240,
        ImGuiTableColumnFlagsNoDirectResize = 1073741824
    }

    public enum ImGuiTableRowFlags
    {
        ImGuiTableRowFlagsNone = 0,
        ImGuiTableRowFlagsHeaders = 1
    }

    public enum ImGuiTableBgTarget
    {
        ImGuiTableBgTargetNone = 0,
        ImGuiTableBgTargetRowBg0 = 1,
        ImGuiTableBgTargetRowBg1 = 2,
        ImGuiTableBgTargetCellBg = 3
    }

    public enum ImGuiFocusedFlags
    {
        ImGuiFocusedFlagsNone = 0,
        ImGuiFocusedFlagsChildWindows = 1,
        ImGuiFocusedFlagsRootWindow = 2,
        ImGuiFocusedFlagsAnyWindow = 4,
        ImGuiFocusedFlagsRootAndChildWindows = 3
    }

    public enum ImGuiHoveredFlags
    {
        ImGuiHoveredFlagsNone = 0,
        ImGuiHoveredFlagsChildWindows = 1,
        ImGuiHoveredFlagsRootWindow = 2,
        ImGuiHoveredFlagsAnyWindow = 4,
        ImGuiHoveredFlagsAllowWhenBlockedByPopup = 8,
        ImGuiHoveredFlagsAllowWhenBlockedByActiveItem = 32,
        ImGuiHoveredFlagsAllowWhenOverlapped = 64,
        ImGuiHoveredFlagsAllowWhenDisabled = 128,
        ImGuiHoveredFlagsRectOnly = 104,
        ImGuiHoveredFlagsRootAndChildWindows = 3
    }

    [Flags]
    public enum ImGuiDockNodeFlags
    {
        ImGuiDockNodeFlagsNone = 0,
        ImGuiDockNodeFlagsKeepAliveOnly = 1,
        ImGuiDockNodeFlagsNoDockingInCentralNode = 4,
        ImGuiDockNodeFlagsPassthruCentralNode = 8,
        ImGuiDockNodeFlagsNoSplit = 16,
        ImGuiDockNodeFlagsNoResize = 32,
        ImGuiDockNodeFlagsAutoHideTabBar = 64
    }

    public enum ImGuiDragDropFlags
    {
        ImGuiDragDropFlagsNone = 0,
        ImGuiDragDropFlagsSourceNoPreviewTooltip = 1,
        ImGuiDragDropFlagsSourceNoDisableHover = 2,
        ImGuiDragDropFlagsSourceNoHoldToOpenOthers = 4,
        ImGuiDragDropFlagsSourceAllowNullID = 8,
        ImGuiDragDropFlagsSourceExtern = 16,
        ImGuiDragDropFlagsSourceAutoExpirePayload = 32,
        ImGuiDragDropFlagsAcceptBeforeDelivery = 1024,
        ImGuiDragDropFlagsAcceptNoDrawDefaultRect = 2048,
        ImGuiDragDropFlagsAcceptNoPreviewTooltip = 4096,
        ImGuiDragDropFlagsAcceptPeekOnly = 3072
    }

    public enum ImGuiDataType
    {
        ImGuiDataTypeS8 = 0,
        ImGuiDataTypeU8 = 1,
        ImGuiDataTypeS16 = 2,
        ImGuiDataTypeU16 = 3,
        ImGuiDataTypeS32 = 4,
        ImGuiDataTypeU32 = 5,
        ImGuiDataTypeS64 = 6,
        ImGuiDataTypeU64 = 7,
        ImGuiDataTypeFloat = 8,
        ImGuiDataTypeDouble = 9,
        ImGuiDataTypeCOUNT = 10
    }

    public enum ImGuiDir
    {
        ImGuiDirNone = -1,
        ImGuiDirLeft = 0,
        ImGuiDirRight = 1,
        ImGuiDirUp = 2,
        ImGuiDirDown = 3,
        ImGuiDirCOUNT = 4
    }

    public enum ImGuiSortDirection
    {
        ImGuiSortDirectionNone = 0,
        ImGuiSortDirectionAscending = 1,
        ImGuiSortDirectionDescending = 2
    }

    public enum ImGuiKey
    {
        ImGuiKeyTab = 0,
        ImGuiKeyLeftArrow = 1,
        ImGuiKeyRightArrow = 2,
        ImGuiKeyUpArrow = 3,
        ImGuiKeyDownArrow = 4,
        ImGuiKeyPageUp = 5,
        ImGuiKeyPageDown = 6,
        ImGuiKeyHome = 7,
        ImGuiKeyEnd = 8,
        ImGuiKeyInsert = 9,
        ImGuiKeyDelete = 10,
        ImGuiKeyBackspace = 11,
        ImGuiKeySpace = 12,
        ImGuiKeyEnter = 13,
        ImGuiKeyEscape = 14,
        ImGuiKeyKeyPadEnter = 15,
        ImGuiKeyA = 16,
        ImGuiKeyC = 17,
        ImGuiKeyV = 18,
        ImGuiKeyX = 19,
        ImGuiKeyY = 20,
        ImGuiKeyZ = 21,
        ImGuiKeyCOUNT = 22
    }

    [Flags]
    public enum ImGuiKeyModFlags
    {
        ImGuiKeyModFlagsNone = 0,
        ImGuiKeyModFlagsCtrl = 1,
        ImGuiKeyModFlagsShift = 2,
        ImGuiKeyModFlagsAlt = 4,
        ImGuiKeyModFlagsSuper = 8
    }

    public enum ImGuiNavInput
    {
        ImGuiNavInputActivate = 0,
        ImGuiNavInputCancel = 1,
        ImGuiNavInputInput = 2,
        ImGuiNavInputMenu = 3,
        ImGuiNavInputDpadLeft = 4,
        ImGuiNavInputDpadRight = 5,
        ImGuiNavInputDpadUp = 6,
        ImGuiNavInputDpadDown = 7,
        ImGuiNavInputLStickLeft = 8,
        ImGuiNavInputLStickRight = 9,
        ImGuiNavInputLStickUp = 10,
        ImGuiNavInputLStickDown = 11,
        ImGuiNavInputFocusPrev = 12,
        ImGuiNavInputFocusNext = 13,
        ImGuiNavInputTweakSlow = 14,
        ImGuiNavInputTweakFast = 15,
        ImGuiNavInputKeyMenu = 16,
        ImGuiNavInputKeyLeft = 17,
        ImGuiNavInputKeyRight = 18,
        ImGuiNavInputKeyUp = 19,
        ImGuiNavInputKeyDown = 20,
        ImGuiNavInputCOUNT = 21,
        ImGuiNavInputInternalStart = 16
    }

    [Flags]
    public enum ImGuiConfigFlags
    {
        ImGuiConfigFlagsNone = 0,
        ImGuiConfigFlagsNavEnableKeyboard = 1,
        ImGuiConfigFlagsNavEnableGamepad = 2,
        ImGuiConfigFlagsNavEnableSetMousePos = 4,
        ImGuiConfigFlagsNavNoCaptureKeyboard = 8,
        ImGuiConfigFlagsNoMouse = 16,
        ImGuiConfigFlagsNoMouseCursorChange = 32,
        ImGuiConfigFlagsDockingEnable = 64,
        ImGuiConfigFlagsViewportsEnable = 1024,
        ImGuiConfigFlagsDpiEnableScaleViewports = 16384,
        ImGuiConfigFlagsDpiEnableScaleFonts = 32768,
        ImGuiConfigFlagsIsSRGB = 1048576,
        ImGuiConfigFlagsIsTouchScreen = 2097152
    }

    [Flags]
    public enum ImGuiBackendFlags
    {
        ImGuiBackendFlagsNone = 0,
        ImGuiBackendFlagsHasGamepad = 1,
        ImGuiBackendFlagsHasMouseCursors = 2,
        ImGuiBackendFlagsHasSetMousePos = 4,
        ImGuiBackendFlagsRendererHasVtxOffset = 8,
        ImGuiBackendFlagsPlatformHasViewports = 1024,
        ImGuiBackendFlagsHasMouseHoveredViewport = 2048,
        ImGuiBackendFlagsRendererHasViewports = 4096
    }

    public enum ImGuiCol
    {
        ImGuiColText = 0,
        ImGuiColTextDisabled = 1,
        ImGuiColWindowBg = 2,
        ImGuiColChildBg = 3,
        ImGuiColPopupBg = 4,
        ImGuiColBorder = 5,
        ImGuiColBorderShadow = 6,
        ImGuiColFrameBg = 7,
        ImGuiColFrameBgHovered = 8,
        ImGuiColFrameBgActive = 9,
        ImGuiColTitleBg = 10,
        ImGuiColTitleBgActive = 11,
        ImGuiColTitleBgCollapsed = 12,
        ImGuiColMenuBarBg = 13,
        ImGuiColScrollbarBg = 14,
        ImGuiColScrollbarGrab = 15,
        ImGuiColScrollbarGrabHovered = 16,
        ImGuiColScrollbarGrabActive = 17,
        ImGuiColCheckMark = 18,
        ImGuiColSliderGrab = 19,
        ImGuiColSliderGrabActive = 20,
        ImGuiColButton = 21,
        ImGuiColButtonHovered = 22,
        ImGuiColButtonActive = 23,
        ImGuiColHeader = 24,
        ImGuiColHeaderHovered = 25,
        ImGuiColHeaderActive = 26,
        ImGuiColSeparator = 27,
        ImGuiColSeparatorHovered = 28,
        ImGuiColSeparatorActive = 29,
        ImGuiColResizeGrip = 30,
        ImGuiColResizeGripHovered = 31,
        ImGuiColResizeGripActive = 32,
        ImGuiColTab = 33,
        ImGuiColTabHovered = 34,
        ImGuiColTabActive = 35,
        ImGuiColTabUnfocused = 36,
        ImGuiColTabUnfocusedActive = 37,
        ImGuiColDockingPreview = 38,
        ImGuiColDockingEmptyBg = 39,
        ImGuiColPlotLines = 40,
        ImGuiColPlotLinesHovered = 41,
        ImGuiColPlotHistogram = 42,
        ImGuiColPlotHistogramHovered = 43,
        ImGuiColTableHeaderBg = 44,
        ImGuiColTableBorderStrong = 45,
        ImGuiColTableBorderLight = 46,
        ImGuiColTableRowBg = 47,
        ImGuiColTableRowBgAlt = 48,
        ImGuiColTextSelectedBg = 49,
        ImGuiColDragDropTarget = 50,
        ImGuiColNavHighlight = 51,
        ImGuiColNavWindowingHighlight = 52,
        ImGuiColNavWindowingDimBg = 53,
        ImGuiColModalWindowDimBg = 54,
        ImGuiColCOUNT = 55
    }

    public enum ImGuiStyleVar
    {
        ImGuiStyleVarAlpha = 0,
        ImGuiStyleVarWindowPadding = 1,
        ImGuiStyleVarWindowRounding = 2,
        ImGuiStyleVarWindowBorderSize = 3,
        ImGuiStyleVarWindowMinSize = 4,
        ImGuiStyleVarWindowTitleAlign = 5,
        ImGuiStyleVarChildRounding = 6,
        ImGuiStyleVarChildBorderSize = 7,
        ImGuiStyleVarPopupRounding = 8,
        ImGuiStyleVarPopupBorderSize = 9,
        ImGuiStyleVarFramePadding = 10,
        ImGuiStyleVarFrameRounding = 11,
        ImGuiStyleVarFrameBorderSize = 12,
        ImGuiStyleVarItemSpacing = 13,
        ImGuiStyleVarItemInnerSpacing = 14,
        ImGuiStyleVarIndentSpacing = 15,
        ImGuiStyleVarCellPadding = 16,
        ImGuiStyleVarScrollbarSize = 17,
        ImGuiStyleVarScrollbarRounding = 18,
        ImGuiStyleVarGrabMinSize = 19,
        ImGuiStyleVarGrabRounding = 20,
        ImGuiStyleVarTabRounding = 21,
        ImGuiStyleVarButtonTextAlign = 22,
        ImGuiStyleVarSelectableTextAlign = 23,
        ImGuiStyleVarCOUNT = 24
    }

    public enum ImGuiButtonFlags
    {
        ImGuiButtonFlagsNone = 0,
        ImGuiButtonFlagsMouseButtonLeft = 1,
        ImGuiButtonFlagsMouseButtonRight = 2,
        ImGuiButtonFlagsMouseButtonMiddle = 4,
        ImGuiButtonFlagsMouseButtonMask = 7,
        ImGuiButtonFlagsMouseButtonDefault = 1
    }

    public enum ImGuiColorEditFlags
    {
        ImGuiColorEditFlagsNone = 0,
        ImGuiColorEditFlagsNoAlpha = 2,
        ImGuiColorEditFlagsNoPicker = 4,
        ImGuiColorEditFlagsNoOptions = 8,
        ImGuiColorEditFlagsNoSmallPreview = 16,
        ImGuiColorEditFlagsNoInputs = 32,
        ImGuiColorEditFlagsNoTooltip = 64,
        ImGuiColorEditFlagsNoLabel = 128,
        ImGuiColorEditFlagsNoSidePreview = 256,
        ImGuiColorEditFlagsNoDragDrop = 512,
        ImGuiColorEditFlagsNoBorder = 1024,
        ImGuiColorEditFlagsAlphaBar = 65536,
        ImGuiColorEditFlagsAlphaPreview = 131072,
        ImGuiColorEditFlagsAlphaPreviewHalf = 262144,
        ImGuiColorEditFlagsHDR = 524288,
        ImGuiColorEditFlagsDisplayRGB = 1048576,
        ImGuiColorEditFlagsDisplayHSV = 2097152,
        ImGuiColorEditFlagsDisplayHex = 4194304,
        ImGuiColorEditFlagsUint8 = 8388608,
        ImGuiColorEditFlagsFloat = 16777216,
        ImGuiColorEditFlagsPickerHueBar = 33554432,
        ImGuiColorEditFlagsPickerHueWheel = 67108864,
        ImGuiColorEditFlagsInputRGB = 134217728,
        ImGuiColorEditFlagsInputHSV = 268435456,
        ImGuiColorEditFlagsOptionsDefault = 177209344,
        ImGuiColorEditFlagsDisplayMask = 7340032,
        ImGuiColorEditFlagsDataTypeMask = 25165824,
        ImGuiColorEditFlagsPickerMask = 100663296,
        ImGuiColorEditFlagsInputMask = 402653184,
        ImGuiColorEditFlagsRGB = 1048576,
        ImGuiColorEditFlagsHSV = 2097152,
        ImGuiColorEditFlagsHEX = 4194304
    }

    public enum ImGuiSliderFlags
    {
        ImGuiSliderFlagsNone = 0,
        ImGuiSliderFlagsAlwaysClamp = 16,
        ImGuiSliderFlagsLogarithmic = 32,
        ImGuiSliderFlagsNoRoundToFormat = 64,
        ImGuiSliderFlagsNoInput = 128,
        ImGuiSliderFlagsInvalidMask = 1879048207,
        ImGuiSliderFlagsClampOnInput = 16
    }

    public enum ImGuiMouseButton
    {
        ImGuiMouseButtonLeft = 0,
        ImGuiMouseButtonRight = 1,
        ImGuiMouseButtonMiddle = 2,
        ImGuiMouseButtonCOUNT = 5
    }

    public enum ImGuiMouseCursor
    {
        ImGuiMouseCursorNone = -1,
        ImGuiMouseCursorArrow = 0,
        ImGuiMouseCursorTextInput = 1,
        ImGuiMouseCursorResizeAll = 2,
        ImGuiMouseCursorResizeNS = 3,
        ImGuiMouseCursorResizeEW = 4,
        ImGuiMouseCursorResizeNESW = 5,
        ImGuiMouseCursorResizeNWSE = 6,
        ImGuiMouseCursorHand = 7,
        ImGuiMouseCursorNotAllowed = 8,
        ImGuiMouseCursorCOUNT = 9
    }

    [Flags]
    public enum ImGuiCond
    {
        ImGuiCondNone = 0,
        ImGuiCondAlways = 1,
        ImGuiCondOnce = 2,
        ImGuiCondFirstUseEver = 4,
        ImGuiCondAppearing = 8
    }

    public enum ImDrawFlags
    {
        ImDrawFlagsNone = 0,
        ImDrawFlagsClosed = 1,
        ImDrawFlagsRoundCornersTopLeft = 16,
        ImDrawFlagsRoundCornersTopRight = 32,
        ImDrawFlagsRoundCornersBottomLeft = 64,
        ImDrawFlagsRoundCornersBottomRight = 128,
        ImDrawFlagsRoundCornersNone = 256,
        ImDrawFlagsRoundCornersTop = 48,
        ImDrawFlagsRoundCornersBottom = 192,
        ImDrawFlagsRoundCornersLeft = 80,
        ImDrawFlagsRoundCornersRight = 160,
        ImDrawFlagsRoundCornersAll = 240,
        ImDrawFlagsRoundCornersDefault = 240,
        ImDrawFlagsRoundCornersMask = 496
    }

    [Flags]
    public enum ImDrawListFlags
    {
        ImDrawListFlagsNone = 0,
        ImDrawListFlagsAntiAliasedLines = 1,
        ImDrawListFlagsAntiAliasedLinesUseTex = 2,
        ImDrawListFlagsAntiAliasedFill = 4,
        ImDrawListFlagsAllowVtxOffset = 8
    }

    [Flags]
    public enum ImFontAtlasFlags
    {
        ImFontAtlasFlagsNone = 0,
        ImFontAtlasFlagsNoPowerOfTwoHeight = 1,
        ImFontAtlasFlagsNoMouseCursors = 2,
        ImFontAtlasFlagsNoBakedLines = 4
    }

    [Flags]
    public enum ImGuiViewportFlags
    {
        ImGuiViewportFlagsNone = 0,
        ImGuiViewportFlagsIsPlatformWindow = 1,
        ImGuiViewportFlagsIsPlatformMonitor = 2,
        ImGuiViewportFlagsOwnedByApp = 4,
        ImGuiViewportFlagsNoDecoration = 8,
        ImGuiViewportFlagsNoTaskBarIcon = 16,
        ImGuiViewportFlagsNoFocusOnAppearing = 32,
        ImGuiViewportFlagsNoFocusOnClick = 64,
        ImGuiViewportFlagsNoInputs = 128,
        ImGuiViewportFlagsNoRendererClear = 256,
        ImGuiViewportFlagsTopMost = 512,
        ImGuiViewportFlagsMinimized = 1024,
        ImGuiViewportFlagsNoAutoMerge = 2048,
        ImGuiViewportFlagsCanHostOtherWindows = 4096
    }

    public enum ImDrawCornerFlags
    {
        ImDrawCornerFlagsNone = 256,
        ImDrawCornerFlagsTopLeft = 16,
        ImDrawCornerFlagsTopRight = 32,
        ImDrawCornerFlagsBotLeft = 64,
        ImDrawCornerFlagsBotRight = 128,
        ImDrawCornerFlagsAll = 240,
        ImDrawCornerFlagsTop = 48,
        ImDrawCornerFlagsBot = 192,
        ImDrawCornerFlagsLeft = 80,
        ImDrawCornerFlagsRight = 160
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImDrawCallback(__IntPtr parent_list, __IntPtr cmd);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int ImGuiInputTextCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiSizeCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr ImGuiMemAllocFunc(ulong sz, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiMemFreeFunc(__IntPtr ptr, __IntPtr user_data);

    namespace ImVector
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public unsafe partial struct __Internal
        {
            internal int Size;
            internal int Capacity;
            internal __IntPtr Data;
        }
    }

    public unsafe partial class ImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec2@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec2@@QEAA@MM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float _x, float _y);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??AImVec2@@QEAAAEAM_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float* OperatorSubscript(__IntPtr __instance, ulong idx);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImVec2> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImVec2>();

        protected bool __ownsNativeInstance;

        internal static ImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImVec2(float _x, float _y)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, _x, _y);
        }

        public ImVec2(global::Cored.ImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec2.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImVec2.__Internal*) __Instance) = *((global::Cored.ImVec2.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float this[ulong idx]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript(__Instance, idx);
                return *__ret;
            }

            set
            {
                *global::Cored.ImVec2.__Internal.OperatorSubscript(__Instance, idx) = value;
            }
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class ImDrawListSharedData
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawListSharedData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawListSharedData>();

        protected bool __ownsNativeInstance;

        internal static ImDrawListSharedData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSharedData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawListSharedData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawListSharedData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSharedData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawListSharedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImFontBuilderIO
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontBuilderIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontBuilderIO>();

        protected bool __ownsNativeInstance;

        internal static ImFontBuilderIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native.ToPointer(), skipVTables);
        }

        internal static ImFontBuilderIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontBuilderIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontBuilderIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontBuilderIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontBuilderIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGuiContext
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiContext>();

        protected bool __ownsNativeInstance;

        internal static ImGuiContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContext(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal float x;
            internal float y;
            internal float z;
            internal float w;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec4@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec4@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, float _x, float _y, float _z, float _w);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImVec4> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImVec4>();

        protected bool __ownsNativeInstance;

        internal static ImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImVec4(float _x, float _y, float _z, float _w)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, _x, _y, _z, _w);
        }

        public ImVec4(global::Cored.ImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImVec4.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImVec4.__Internal*) __Instance) = *((global::Cored.ImVec4.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class ImNewWrapper : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImNewWrapper@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImNewWrapper> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImNewWrapper>();

        protected bool __ownsNativeInstance;

        internal static ImNewWrapper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImNewWrapper(native.ToPointer(), skipVTables);
        }

        internal static ImNewWrapper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImNewWrapper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImNewWrapper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImNewWrapper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImNewWrapper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImNewWrapper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImNewWrapper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImNewWrapper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImNewWrapper(global::Cored.ImNewWrapper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImNewWrapper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImNewWrapper.__Internal*) __Instance) = *((global::Cored.ImNewWrapper.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class ImGuiStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1076)]
        public partial struct __Internal
        {
            internal float Alpha;
            internal global::Cored.ImVec2.__Internal WindowPadding;
            internal float WindowRounding;
            internal float WindowBorderSize;
            internal global::Cored.ImVec2.__Internal WindowMinSize;
            internal global::Cored.ImVec2.__Internal WindowTitleAlign;
            internal int WindowMenuButtonPosition;
            internal float ChildRounding;
            internal float ChildBorderSize;
            internal float PopupRounding;
            internal float PopupBorderSize;
            internal global::Cored.ImVec2.__Internal FramePadding;
            internal float FrameRounding;
            internal float FrameBorderSize;
            internal global::Cored.ImVec2.__Internal ItemSpacing;
            internal global::Cored.ImVec2.__Internal ItemInnerSpacing;
            internal global::Cored.ImVec2.__Internal CellPadding;
            internal global::Cored.ImVec2.__Internal TouchExtraPadding;
            internal float IndentSpacing;
            internal float ColumnsMinSpacing;
            internal float ScrollbarSize;
            internal float ScrollbarRounding;
            internal float GrabMinSize;
            internal float GrabRounding;
            internal float LogSliderDeadzone;
            internal float TabRounding;
            internal float TabBorderSize;
            internal float TabMinWidthForCloseButton;
            internal int ColorButtonPosition;
            internal global::Cored.ImVec2.__Internal ButtonTextAlign;
            internal global::Cored.ImVec2.__Internal SelectableTextAlign;
            internal global::Cored.ImVec2.__Internal DisplayWindowPadding;
            internal global::Cored.ImVec2.__Internal DisplaySafeAreaPadding;
            internal float MouseCursorScale;
            internal byte AntiAliasedLines;
            internal byte AntiAliasedLinesUseTex;
            internal byte AntiAliasedFill;
            internal float CurveTessellationTol;
            internal float CircleTessellationMaxError;
            internal fixed byte Colors[880];

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStyle@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStyle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ScaleAllSizes(__IntPtr __instance, float scale_factor);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStyle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStyle>();

        protected bool __ownsNativeInstance;

        internal static ImGuiStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyle(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiStyle(global::Cored.ImGuiStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiStyle.__Internal*) __Instance) = *((global::Cored.ImGuiStyle.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void ScaleAllSizes(float scale_factor)
        {
            __Internal.ScaleAllSizes(__Instance, scale_factor);
        }

        public float Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->Alpha;
            }

            set
            {
                ((__Internal*)__Instance)->Alpha = value;
            }
        }

        public global::Cored.ImVec2 WindowPadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public global::Cored.ImVec2 WindowMinSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowMinSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowMinSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 WindowTitleAlign
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowTitleAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowTitleAlign = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int WindowMenuButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->WindowMenuButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->WindowMenuButtonPosition = value;
            }
        }

        public float ChildRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ChildRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ChildRounding = value;
            }
        }

        public float ChildBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->ChildBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->ChildBorderSize = value;
            }
        }

        public float PopupRounding
        {
            get
            {
                return ((__Internal*)__Instance)->PopupRounding;
            }

            set
            {
                ((__Internal*)__Instance)->PopupRounding = value;
            }
        }

        public float PopupBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->PopupBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->PopupBorderSize = value;
            }
        }

        public global::Cored.ImVec2 FramePadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float FrameRounding
        {
            get
            {
                return ((__Internal*)__Instance)->FrameRounding;
            }

            set
            {
                ((__Internal*)__Instance)->FrameRounding = value;
            }
        }

        public float FrameBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->FrameBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->FrameBorderSize = value;
            }
        }

        public global::Cored.ImVec2 ItemSpacing
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemSpacing = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 ItemInnerSpacing
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemInnerSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemInnerSpacing = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 CellPadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CellPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CellPadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 TouchExtraPadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TouchExtraPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TouchExtraPadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float IndentSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->IndentSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->IndentSpacing = value;
            }
        }

        public float ColumnsMinSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsMinSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsMinSpacing = value;
            }
        }

        public float ScrollbarSize
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarSize;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarSize = value;
            }
        }

        public float ScrollbarRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarRounding = value;
            }
        }

        public float GrabMinSize
        {
            get
            {
                return ((__Internal*)__Instance)->GrabMinSize;
            }

            set
            {
                ((__Internal*)__Instance)->GrabMinSize = value;
            }
        }

        public float GrabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->GrabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->GrabRounding = value;
            }
        }

        public float LogSliderDeadzone
        {
            get
            {
                return ((__Internal*)__Instance)->LogSliderDeadzone;
            }

            set
            {
                ((__Internal*)__Instance)->LogSliderDeadzone = value;
            }
        }

        public float TabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->TabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->TabRounding = value;
            }
        }

        public float TabBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->TabBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->TabBorderSize = value;
            }
        }

        public float TabMinWidthForCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->TabMinWidthForCloseButton;
            }

            set
            {
                ((__Internal*)__Instance)->TabMinWidthForCloseButton = value;
            }
        }

        public int ColorButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->ColorButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->ColorButtonPosition = value;
            }
        }

        public global::Cored.ImVec2 ButtonTextAlign
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ButtonTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ButtonTextAlign = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 SelectableTextAlign
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SelectableTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SelectableTextAlign = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 DisplayWindowPadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayWindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayWindowPadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 DisplaySafeAreaPadding
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySafeAreaPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySafeAreaPadding = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float MouseCursorScale
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursorScale;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursorScale = value;
            }
        }

        public bool AntiAliasedLines
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLines != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLines = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedLinesUseTex
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLinesUseTex != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLinesUseTex = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedFill
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedFill != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedFill = (byte) (value ? 1 : 0);
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleTessellationMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleTessellationMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleTessellationMaxError = value;
            }
        }

        public global::Cored.ImVec4[] Colors
        {
            get
            {
                global::Cored.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->Colors != null)
                {
                    __value = new global::Cored.ImVec4[55];
                    for (int i = 0; i < 55; i++)
                        __value[i] = global::Cored.ImVec4.__CreateInstance(*((global::Cored.ImVec4.__Internal*)&(((__Internal*)__Instance)->Colors[i * sizeof(global::Cored.ImVec4.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 55)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 55; i++)
                        *(global::Cored.ImVec4.__Internal*) &((__Internal*)__Instance)->Colors[i * sizeof(global::Cored.ImVec4.__Internal)] = *(global::Cored.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5456)]
        public partial struct __Internal
        {
            internal int ConfigFlags;
            internal int BackendFlags;
            internal global::Cored.ImVec2.__Internal DisplaySize;
            internal float DeltaTime;
            internal float IniSavingRate;
            internal __IntPtr IniFilename;
            internal __IntPtr LogFilename;
            internal float MouseDoubleClickTime;
            internal float MouseDoubleClickMaxDist;
            internal float MouseDragThreshold;
            internal fixed int KeyMap[22];
            internal float KeyRepeatDelay;
            internal float KeyRepeatRate;
            internal __IntPtr UserData;
            internal __IntPtr Fonts;
            internal float FontGlobalScale;
            internal byte FontAllowUserScaling;
            internal __IntPtr FontDefault;
            internal global::Cored.ImVec2.__Internal DisplayFramebufferScale;
            internal byte ConfigDockingNoSplit;
            internal byte ConfigDockingAlwaysTabBar;
            internal byte ConfigDockingTransparentPayload;
            internal byte ConfigViewportsNoAutoMerge;
            internal byte ConfigViewportsNoTaskBarIcon;
            internal byte ConfigViewportsNoDecoration;
            internal byte ConfigViewportsNoDefaultParent;
            internal byte MouseDrawCursor;
            internal byte ConfigMacOSXBehaviors;
            internal byte ConfigInputTextCursorBlink;
            internal byte ConfigDragClickToInputText;
            internal byte ConfigWindowsResizeFromEdges;
            internal byte ConfigWindowsMoveFromTitleBarOnly;
            internal float ConfigMemoryCompactTimer;
            internal __IntPtr BackendPlatformName;
            internal __IntPtr BackendRendererName;
            internal __IntPtr BackendPlatformUserData;
            internal __IntPtr BackendRendererUserData;
            internal __IntPtr BackendLanguageUserData;
            internal __IntPtr GetClipboardTextFn;
            internal __IntPtr SetClipboardTextFn;
            internal __IntPtr ClipboardUserData;
            internal global::Cored.ImVec2.__Internal MousePos;
            internal fixed byte MouseDown[5];
            internal float MouseWheel;
            internal float MouseWheelH;
            internal uint MouseHoveredViewport;
            internal byte KeyCtrl;
            internal byte KeyShift;
            internal byte KeyAlt;
            internal byte KeySuper;
            internal fixed byte KeysDown[512];
            internal fixed float NavInputs[21];
            internal byte WantCaptureMouse;
            internal byte WantCaptureKeyboard;
            internal byte WantTextInput;
            internal byte WantSetMousePos;
            internal byte WantSaveIniSettings;
            internal byte NavActive;
            internal byte NavVisible;
            internal float Framerate;
            internal int MetricsRenderVertices;
            internal int MetricsRenderIndices;
            internal int MetricsRenderWindows;
            internal int MetricsActiveWindows;
            internal int MetricsActiveAllocations;
            internal global::Cored.ImVec2.__Internal MouseDelta;
            internal int KeyMods;
            internal global::Cored.ImVec2.__Internal MousePosPrev;
            internal fixed byte MouseClickedPos[40];
            internal fixed double MouseClickedTime[5];
            internal fixed byte MouseClicked[5];
            internal fixed byte MouseDoubleClicked[5];
            internal fixed byte MouseReleased[5];
            internal fixed byte MouseDownOwned[5];
            internal fixed byte MouseDownWasDoubleClick[5];
            internal fixed float MouseDownDuration[5];
            internal fixed float MouseDownDurationPrev[5];
            internal fixed byte MouseDragMaxDistanceAbs[40];
            internal fixed float MouseDragMaxDistanceSqr[5];
            internal fixed float KeysDownDuration[512];
            internal fixed float KeysDownDurationPrev[512];
            internal fixed float NavInputsDownDuration[21];
            internal fixed float NavInputsDownDurationPrev[21];
            internal float PenPressure;
            internal ushort InputQueueSurrogate;
            internal global::Cored.ImVector.__Internal InputQueueCharacters;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiIO@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiIO@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddInputCharacter@ImGuiIO@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddInputCharacter(__IntPtr __instance, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddInputCharacterUTF16@ImGuiIO@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddInputCharacterUTF16(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddInputCharactersUTF8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearInputCharacters@ImGuiIO@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearInputCharacters(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiIO>();

        protected bool __ownsNativeInstance;

        internal static ImGuiIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImGuiIO.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImGuiIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiIO(global::Cored.ImGuiIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void AddInputCharacter(uint c)
        {
            __Internal.AddInputCharacter(__Instance, c);
        }

        public void AddInputCharacterUTF16(ushort c)
        {
            __Internal.AddInputCharacterUTF16(__Instance, c);
        }

        public void AddInputCharactersUTF8(string str)
        {
            __Internal.AddInputCharactersUTF8(__Instance, str);
        }

        public void ClearInputCharacters()
        {
            __Internal.ClearInputCharacters(__Instance);
        }

        public int ConfigFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlags;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlags = value;
            }
        }

        public int BackendFlags
        {
            get
            {
                return ((__Internal*)__Instance)->BackendFlags;
            }

            set
            {
                ((__Internal*)__Instance)->BackendFlags = value;
            }
        }

        public global::Cored.ImVec2 DisplaySize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DeltaTime
        {
            get
            {
                return ((__Internal*)__Instance)->DeltaTime;
            }

            set
            {
                ((__Internal*)__Instance)->DeltaTime = value;
            }
        }

        public float IniSavingRate
        {
            get
            {
                return ((__Internal*)__Instance)->IniSavingRate;
            }

            set
            {
                ((__Internal*)__Instance)->IniSavingRate = value;
            }
        }

        public string IniFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->IniFilename);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->IniFilename = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string LogFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogFilename);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->LogFilename = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public float MouseDoubleClickTime
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickTime;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickTime = value;
            }
        }

        public float MouseDoubleClickMaxDist
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickMaxDist;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickMaxDist = value;
            }
        }

        public float MouseDragThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDragThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDragThreshold = value;
            }
        }

        public int[] KeyMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->KeyMap, 22);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 22; i++)
                        ((__Internal*)__Instance)->KeyMap[i] = value[i];
                }
            }
        }

        public float KeyRepeatDelay
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatDelay;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatDelay = value;
            }
        }

        public float KeyRepeatRate
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatRate;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatRate = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::Cored.ImFontAtlas Fonts
        {
            get
            {
                var __result0 = global::Cored.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->Fonts, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Fonts = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontGlobalScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontGlobalScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontGlobalScale = value;
            }
        }

        public bool FontAllowUserScaling
        {
            get
            {
                return ((__Internal*)__Instance)->FontAllowUserScaling != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAllowUserScaling = (byte) (value ? 1 : 0);
            }
        }

        public global::Cored.ImFont FontDefault
        {
            get
            {
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->FontDefault, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDefault = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Cored.ImVec2 DisplayFramebufferScale
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayFramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayFramebufferScale = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool ConfigDockingNoSplit
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingNoSplit != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingNoSplit = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDockingAlwaysTabBar
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingAlwaysTabBar != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingAlwaysTabBar = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDockingTransparentPayload
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingTransparentPayload != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingTransparentPayload = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoAutoMerge
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoAutoMerge != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoAutoMerge = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoTaskBarIcon
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoTaskBarIcon != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoTaskBarIcon = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoDecoration
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoDecoration != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoDecoration = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoDefaultParent
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoDefaultParent != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoDefaultParent = (byte) (value ? 1 : 0);
            }
        }

        public bool MouseDrawCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDrawCursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDrawCursor = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigMacOSXBehaviors
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMacOSXBehaviors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMacOSXBehaviors = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTextCursorBlink
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTextCursorBlink != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTextCursorBlink = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDragClickToInputText
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDragClickToInputText != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDragClickToInputText = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsResizeFromEdges
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsMoveFromTitleBarOnly
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly = (byte) (value ? 1 : 0);
            }
        }

        public float ConfigMemoryCompactTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMemoryCompactTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMemoryCompactTimer = value;
            }
        }

        public string BackendPlatformName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendPlatformName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->BackendPlatformName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public string BackendRendererName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendRendererName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->BackendRendererName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public __IntPtr BackendPlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendPlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendPlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendRendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendRendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendRendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendLanguageUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendLanguageUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendLanguageUserData = (__IntPtr) value;
            }
        }

        public global::Cored.Delegates.Func___IntPtr___IntPtr GetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string SetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string));
            }

            set
            {
                ((__Internal*)__Instance)->SetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ClipboardUserData
        {
            get
            {
                return ((__Internal*)__Instance)->ClipboardUserData;
            }

            set
            {
                ((__Internal*)__Instance)->ClipboardUserData = (__IntPtr) value;
            }
        }

        public global::Cored.ImVec2 MousePos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool[] MouseDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDown, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float MouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheel;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheel = value;
            }
        }

        public float MouseWheelH
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheelH;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheelH = value;
            }
        }

        public uint MouseHoveredViewport
        {
            get
            {
                return ((__Internal*)__Instance)->MouseHoveredViewport;
            }

            set
            {
                ((__Internal*)__Instance)->MouseHoveredViewport = value;
            }
        }

        public bool KeyCtrl
        {
            get
            {
                return ((__Internal*)__Instance)->KeyCtrl != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyCtrl = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyShift
        {
            get
            {
                return ((__Internal*)__Instance)->KeyShift != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyShift = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyAlt
        {
            get
            {
                return ((__Internal*)__Instance)->KeyAlt != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyAlt = (byte) (value ? 1 : 0);
            }
        }

        public bool KeySuper
        {
            get
            {
                return ((__Internal*)__Instance)->KeySuper != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeySuper = (byte) (value ? 1 : 0);
            }
        }

        public bool[] KeysDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->KeysDown, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] NavInputs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputs, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputs[i] = value[i];
                }
            }
        }

        public bool WantCaptureMouse
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouse != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouse = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCaptureKeyboard
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboard = (byte) (value ? 1 : 0);
            }
        }

        public bool WantTextInput
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInput = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSetMousePos
        {
            get
            {
                return ((__Internal*)__Instance)->WantSetMousePos != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSetMousePos = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSaveIniSettings
        {
            get
            {
                return ((__Internal*)__Instance)->WantSaveIniSettings != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSaveIniSettings = (byte) (value ? 1 : 0);
            }
        }

        public bool NavActive
        {
            get
            {
                return ((__Internal*)__Instance)->NavActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavActive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavVisible
        {
            get
            {
                return ((__Internal*)__Instance)->NavVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavVisible = (byte) (value ? 1 : 0);
            }
        }

        public float Framerate
        {
            get
            {
                return ((__Internal*)__Instance)->Framerate;
            }

            set
            {
                ((__Internal*)__Instance)->Framerate = value;
            }
        }

        public int MetricsRenderVertices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderVertices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderVertices = value;
            }
        }

        public int MetricsRenderIndices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderIndices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderIndices = value;
            }
        }

        public int MetricsRenderWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderWindows = value;
            }
        }

        public int MetricsActiveWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveWindows = value;
            }
        }

        public int MetricsActiveAllocations
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveAllocations;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveAllocations = value;
            }
        }

        public global::Cored.ImVec2 MouseDelta
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseDelta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseDelta = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int KeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->KeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->KeyMods = value;
            }
        }

        public global::Cored.ImVec2 MousePosPrev
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePosPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePosPrev = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2[] MouseClickedPos
        {
            get
            {
                global::Cored.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseClickedPos != null)
                {
                    __value = new global::Cored.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::Cored.ImVec2.__CreateInstance(*((global::Cored.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::Cored.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::Cored.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::Cored.ImVec2.__Internal)] = *(global::Cored.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public double[] MouseClickedTime
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<double>(((__Internal*)__Instance)->MouseClickedTime, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedTime[i] = value[i];
                }
            }
        }

        public bool[] MouseClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDoubleClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDoubleClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDoubleClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseReleased
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseReleased, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseReleased[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwned
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwned, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwned[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownWasDoubleClick
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownWasDoubleClick, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownWasDoubleClick[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] MouseDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDuration, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDuration[i] = value[i];
                }
            }
        }

        public float[] MouseDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDurationPrev, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDurationPrev[i] = value[i];
                }
            }
        }

        public global::Cored.ImVec2[] MouseDragMaxDistanceAbs
        {
            get
            {
                global::Cored.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseDragMaxDistanceAbs != null)
                {
                    __value = new global::Cored.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::Cored.ImVec2.__CreateInstance(*((global::Cored.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::Cored.ImVec2.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::Cored.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::Cored.ImVec2.__Internal)] = *(global::Cored.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float[] MouseDragMaxDistanceSqr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDragMaxDistanceSqr, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDragMaxDistanceSqr[i] = value[i];
                }
            }
        }

        public float[] KeysDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->KeysDownDuration, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDownDuration[i] = value[i];
                }
            }
        }

        public float[] KeysDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->KeysDownDurationPrev, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->KeysDownDurationPrev[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDuration, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputsDownDuration[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDurationPrev, 21);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 21; i++)
                        ((__Internal*)__Instance)->NavInputsDownDurationPrev[i] = value[i];
                }
            }
        }

        public float PenPressure
        {
            get
            {
                return ((__Internal*)__Instance)->PenPressure;
            }

            set
            {
                ((__Internal*)__Instance)->PenPressure = value;
            }
        }

        public ushort InputQueueSurrogate
        {
            get
            {
                return ((__Internal*)__Instance)->InputQueueSurrogate;
            }

            set
            {
                ((__Internal*)__Instance)->InputQueueSurrogate = value;
            }
        }
    }

    public unsafe partial class ImGuiInputTextCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal int EventFlag;
            internal int Flags;
            internal __IntPtr UserData;
            internal ushort EventChar;
            internal int EventKey;
            internal __IntPtr Buf;
            internal int BufTextLen;
            internal int BufSize;
            internal byte BufDirty;
            internal int CursorPos;
            internal int SelectionStart;
            internal int SelectionEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiInputTextCallbackData@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiInputTextCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DeleteChars(__IntPtr __instance, int pos, int bytes_count);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void InsertChars(__IntPtr __instance, int pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SelectAll@ImGuiInputTextCallbackData@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SelectAll(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearSelection@ImGuiInputTextCallbackData@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearSelection(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?HasSelection@ImGuiInputTextCallbackData@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HasSelection(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiInputTextCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiInputTextCallbackData>();

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiInputTextCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiInputTextCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiInputTextCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiInputTextCallbackData(global::Cored.ImGuiInputTextCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiInputTextCallbackData.__Internal*) __Instance) = *((global::Cored.ImGuiInputTextCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void DeleteChars(int pos, int bytes_count)
        {
            __Internal.DeleteChars(__Instance, pos, bytes_count);
        }

        public void InsertChars(int pos, string text, string text_end)
        {
            __Internal.InsertChars(__Instance, pos, text, text_end);
        }

        public void SelectAll()
        {
            __Internal.SelectAll(__Instance);
        }

        public void ClearSelection()
        {
            __Internal.ClearSelection(__Instance);
        }

        public int EventFlag
        {
            get
            {
                return ((__Internal*)__Instance)->EventFlag;
            }

            set
            {
                ((__Internal*)__Instance)->EventFlag = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public ushort EventChar
        {
            get
            {
                return ((__Internal*)__Instance)->EventChar;
            }

            set
            {
                ((__Internal*)__Instance)->EventChar = value;
            }
        }

        public int EventKey
        {
            get
            {
                return ((__Internal*)__Instance)->EventKey;
            }

            set
            {
                ((__Internal*)__Instance)->EventKey = value;
            }
        }

        public sbyte* Buf
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Buf;
            }

            set
            {
                ((__Internal*)__Instance)->Buf = (__IntPtr) value;
            }
        }

        public int BufTextLen
        {
            get
            {
                return ((__Internal*)__Instance)->BufTextLen;
            }

            set
            {
                ((__Internal*)__Instance)->BufTextLen = value;
            }
        }

        public int BufSize
        {
            get
            {
                return ((__Internal*)__Instance)->BufSize;
            }

            set
            {
                ((__Internal*)__Instance)->BufSize = value;
            }
        }

        public bool BufDirty
        {
            get
            {
                return ((__Internal*)__Instance)->BufDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BufDirty = (byte) (value ? 1 : 0);
            }
        }

        public int CursorPos
        {
            get
            {
                return ((__Internal*)__Instance)->CursorPos;
            }

            set
            {
                ((__Internal*)__Instance)->CursorPos = value;
            }
        }

        public int SelectionStart
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionStart;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionStart = value;
            }
        }

        public int SelectionEnd
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionEnd;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionEnd = value;
            }
        }

        public bool HasSelection
        {
            get
            {
                var __ret = __Internal.HasSelection(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImGuiSizeCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr UserData;
            internal global::Cored.ImVec2.__Internal Pos;
            internal global::Cored.ImVec2.__Internal CurrentSize;
            internal global::Cored.ImVec2.__Internal DesiredSize;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiSizeCallbackData@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiSizeCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiSizeCallbackData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiSizeCallbackData>();

        protected bool __ownsNativeInstance;

        internal static ImGuiSizeCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSizeCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiSizeCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiSizeCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSizeCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiSizeCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSizeCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiSizeCallbackData(global::Cored.ImGuiSizeCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiSizeCallbackData.__Internal*) __Instance) = *((global::Cored.ImGuiSizeCallbackData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::Cored.ImVec2 Pos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 CurrentSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 DesiredSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DesiredSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DesiredSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindowClass : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal uint ClassId;
            internal uint ParentViewportId;
            internal int ViewportFlagsOverrideSet;
            internal int ViewportFlagsOverrideClear;
            internal int TabItemFlagsOverrideSet;
            internal int DockNodeFlagsOverrideSet;
            internal int DockNodeFlagsOverrideClear;
            internal byte DockingAlwaysTabBar;
            internal byte DockingAllowUnclassed;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiWindowClass@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiWindowClass@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiWindowClass> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiWindowClass>();

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowClass __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowClass(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowClass __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiWindowClass)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiWindowClass __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowClass(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowClass(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiWindowClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowClass()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiWindowClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiWindowClass(global::Cored.ImGuiWindowClass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiWindowClass.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiWindowClass.__Internal*) __Instance) = *((global::Cored.ImGuiWindowClass.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ClassId
        {
            get
            {
                return ((__Internal*)__Instance)->ClassId;
            }

            set
            {
                ((__Internal*)__Instance)->ClassId = value;
            }
        }

        public uint ParentViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ParentViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ParentViewportId = value;
            }
        }

        public int ViewportFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportFlagsOverrideSet = value;
            }
        }

        public int ViewportFlagsOverrideClear
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportFlagsOverrideClear;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportFlagsOverrideClear = value;
            }
        }

        public int TabItemFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->TabItemFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->TabItemFlagsOverrideSet = value;
            }
        }

        public int DockNodeFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->DockNodeFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->DockNodeFlagsOverrideSet = value;
            }
        }

        public int DockNodeFlagsOverrideClear
        {
            get
            {
                return ((__Internal*)__Instance)->DockNodeFlagsOverrideClear;
            }

            set
            {
                ((__Internal*)__Instance)->DockNodeFlagsOverrideClear = value;
            }
        }

        public bool DockingAlwaysTabBar
        {
            get
            {
                return ((__Internal*)__Instance)->DockingAlwaysTabBar != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockingAlwaysTabBar = (byte) (value ? 1 : 0);
            }
        }

        public bool DockingAllowUnclassed
        {
            get
            {
                return ((__Internal*)__Instance)->DockingAllowUnclassed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockingAllowUnclassed = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiPayload : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal __IntPtr Data;
            internal int DataSize;
            internal uint SourceId;
            internal uint SourceParentId;
            internal int DataFrameCount;
            internal fixed sbyte DataType[33];
            internal byte Preview;
            internal byte Delivery;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPayload@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPayload@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImGuiPayload@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsDataType@ImGuiPayload@@QEBA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDataType(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsPreview@ImGuiPayload@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPreview(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsDelivery@ImGuiPayload@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDelivery(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPayload> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPayload>();

        protected bool __ownsNativeInstance;

        internal static ImGuiPayload __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPayload(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPayload __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiPayload)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiPayload __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPayload(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPayload(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPayload(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPayload()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiPayload(global::Cored.ImGuiPayload _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiPayload.__Internal*) __Instance) = *((global::Cored.ImGuiPayload.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public bool IsDataType(string type)
        {
            var __ret = __Internal.IsDataType(__Instance, type);
            return __ret;
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public int DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->DataSize;
            }

            set
            {
                ((__Internal*)__Instance)->DataSize = value;
            }
        }

        public uint SourceId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceId = value;
            }
        }

        public uint SourceParentId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceParentId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceParentId = value;
            }
        }

        public int DataFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DataFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DataFrameCount = value;
            }
        }

        public sbyte[] DataType
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->DataType, 33);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((__Internal*)__Instance)->DataType[i] = value[i];
                }
            }
        }

        public bool Preview
        {
            get
            {
                return ((__Internal*)__Instance)->Preview != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Preview = (byte) (value ? 1 : 0);
            }
        }

        public bool Delivery
        {
            get
            {
                return ((__Internal*)__Instance)->Delivery != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Delivery = (byte) (value ? 1 : 0);
            }
        }

        public bool IsPreview
        {
            get
            {
                var __ret = __Internal.IsPreview(__Instance);
                return __ret;
            }
        }

        public bool IsDelivery
        {
            get
            {
                var __ret = __Internal.IsDelivery(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint ColumnUserID;
            internal short ColumnIndex;
            internal short SortOrder;
            internal int SortDirection;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTableColumnSortSpecs@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTableColumnSortSpecs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTableColumnSortSpecs>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiTableColumnSortSpecs(global::Cored.ImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::Cored.ImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ColumnUserID
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnUserID;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnUserID = value;
            }
        }

        public short ColumnIndex
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnIndex;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnIndex = value;
            }
        }

        public short SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public int SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr Specs;
            internal int SpecsCount;
            internal byte SpecsDirty;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTableSortSpecs@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTableSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTableSortSpecs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTableSortSpecs>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTableSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTableSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTableSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiTableSortSpecs(global::Cored.ImGuiTableSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiTableSortSpecs.__Internal*) __Instance) = *((global::Cored.ImGuiTableSortSpecs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImGuiTableColumnSortSpecs Specs
        {
            get
            {
                var __result0 = global::Cored.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Specs, false);
                return __result0;
            }
        }

        public int SpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsCount = value;
            }
        }

        public bool SpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsDirty = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiOnceUponAFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal int RefFrame;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiOnceUponAFrame@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiOnceUponAFrame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??BImGuiOnceUponAFrame@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool OperatorConversion(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiOnceUponAFrame> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiOnceUponAFrame>();

        protected bool __ownsNativeInstance;

        internal static ImGuiOnceUponAFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOnceUponAFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiOnceUponAFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiOnceUponAFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOnceUponAFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiOnceUponAFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOnceUponAFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiOnceUponAFrame(global::Cored.ImGuiOnceUponAFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiOnceUponAFrame.__Internal*) __Instance) = *((global::Cored.ImGuiOnceUponAFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator bool(global::Cored.ImGuiOnceUponAFrame __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorConversion(__arg0);
            return __ret;
        }

        public int RefFrame
        {
            get
            {
                return ((__Internal*)__Instance)->RefFrame;
            }

            set
            {
                ((__Internal*)__Instance)->RefFrame = value;
            }
        }
    }

    public unsafe partial class ImGuiTextFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            internal fixed sbyte InputBuf[256];
            internal global::Cored.ImVector.__Internal Filters;
            internal int CountGrep;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextFilter@@QEAA@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string default_filter);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiTextFilter@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Draw(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool PassFilter(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Build@ImGuiTextFilter@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Build(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImGuiTextFilter@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsActive@ImGuiTextFilter@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsActive(__IntPtr __instance);
        }

        public unsafe partial class ImGuiTextRange : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr b;
                internal __IntPtr e;

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextRange@ImGuiTextFilter@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextRange@ImGuiTextFilter@@QEAA@PEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _b, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _e);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextRange@ImGuiTextFilter@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?empty@ImGuiTextRange@ImGuiTextFilter@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Empty(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextFilter.ImGuiTextRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextFilter.ImGuiTextRange>();

            protected bool __ownsNativeInstance;

            internal static ImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ImGuiTextRange(native.ToPointer(), skipVTables);
            }

            internal static ImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ImGuiTextRange)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ImGuiTextRange(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ImGuiTextRange(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImGuiTextRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ImGuiTextRange()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextFilter.ImGuiTextRange.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public ImGuiTextRange(string _b, string _e)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextFilter.ImGuiTextRange.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance, _b, _e);
            }

            public ImGuiTextRange(global::Cored.ImGuiTextFilter.ImGuiTextRange _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextFilter.ImGuiTextRange.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Cored.ImGuiTextFilter.ImGuiTextRange.__Internal*) __Instance) = *((global::Cored.ImGuiTextFilter.ImGuiTextRange.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string B
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->b);
                }

                set
                {
                    byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    fixed (byte* __bytePtr0 = __bytes0)
                    {
                        ((__Internal*)__Instance)->b = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                    }
                }
            }

            public string E
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->e);
                }

                set
                {
                    byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    fixed (byte* __bytePtr0 = __bytes0)
                    {
                        ((__Internal*)__Instance)->e = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                    }
                }
            }

            public bool Empty
            {
                get
                {
                    var __ret = __Internal.Empty(__Instance);
                    return __ret;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextFilter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextFilter>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTextFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTextFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTextFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImGuiTextFilter.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImGuiTextFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTextFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextFilter(string default_filter)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, default_filter);
        }

        public ImGuiTextFilter(global::Cored.ImGuiTextFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Draw(string label, float width)
        {
            var __ret = __Internal.Draw(__Instance, label, width);
            return __ret;
        }

        public bool PassFilter(string text, string text_end)
        {
            var __ret = __Internal.PassFilter(__Instance, text, text_end);
            return __ret;
        }

        public void Build()
        {
            __Internal.Build(__Instance);
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public static implicit operator global::Cored.ImGuiTextFilter(string default_filter)
        {
            return new global::Cored.ImGuiTextFilter(default_filter);
        }

        public sbyte[] InputBuf
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->InputBuf, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->InputBuf[i] = value[i];
                }
            }
        }

        public int CountGrep
        {
            get
            {
                return ((__Internal*)__Instance)->CountGrep;
            }

            set
            {
                ((__Internal*)__Instance)->CountGrep = value;
            }
        }

        public bool IsActive
        {
            get
            {
                var __ret = __Internal.IsActive(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImGuiTextBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextBuffer@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiTextBuffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiTextBuffer@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?begin@ImGuiTextBuffer@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Begin(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?end@ImGuiTextBuffer@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr End(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?clear@ImGuiTextBuffer@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?reserve@ImGuiTextBuffer@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Reserve(__IntPtr __instance, int capacity);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?append@ImGuiTextBuffer@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Append(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Appendf(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??AImGuiTextBuffer@@QEBADH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte OperatorSubscript(__IntPtr __instance, int i);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?size@ImGuiTextBuffer@@QEBAHXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int Size(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?empty@ImGuiTextBuffer@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Empty(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?c_str@ImGuiTextBuffer@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CStr(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiTextBuffer>();

        protected bool __ownsNativeInstance;

        internal static ImGuiTextBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiTextBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiTextBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImGuiTextBuffer.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImGuiTextBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiTextBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiTextBuffer(global::Cored.ImGuiTextBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string Begin()
        {
            var __ret = __Internal.Begin(__Instance);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public string End()
        {
            var __ret = __Internal.End(__Instance);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public void Reserve(int capacity)
        {
            __Internal.Reserve(__Instance, capacity);
        }

        public void Append(string str, string str_end)
        {
            __Internal.Append(__Instance, str, str_end);
        }

        public void Appendf(string fmt)
        {
            __Internal.Appendf(__Instance, fmt);
        }

        public static sbyte[] EmptyString
        {
            get
            {
                var __ptr = (sbyte*)global::Cored.__Symbols.Cored._EmptyString_ImGuiTextBuffer__2PADA;
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__ptr, 1);
            }
        }

        public sbyte this[int i]
        {
            get
            {
                var __ret = __Internal.OperatorSubscript(__Instance, i);
                return __ret;
            }
        }

        public int Size
        {
            get
            {
                var __ret = __Internal.Size(__Instance);
                return __ret;
            }
        }

        public bool Empty
        {
            get
            {
                var __ret = __Internal.Empty(__Instance);
                return __ret;
            }
        }

        public string CStr
        {
            get
            {
                var __ret = __Internal.CStr(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }
    }

    public unsafe partial class ImGuiStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal Data;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStorage@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiStorage@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImGuiStorage@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetInt@ImGuiStorage@@QEBAHIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int GetInt(__IntPtr __instance, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetInt@ImGuiStorage@@QEAAXIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInt(__IntPtr __instance, uint key, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetBool@ImGuiStorage@@QEBA_NI_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBool(__IntPtr __instance, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetBool@ImGuiStorage@@QEAAXI_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetBool(__IntPtr __instance, uint key, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFloat@ImGuiStorage@@QEBAMIM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetFloat(__IntPtr __instance, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetFloat@ImGuiStorage@@QEAAXIM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetFloat(__IntPtr __instance, uint key, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetVoidPtr(__IntPtr __instance, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetVoidPtr(__IntPtr __instance, uint key, __IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int* GetIntRef(__IntPtr __instance, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern bool* GetBoolRef(__IntPtr __instance, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float* GetFloatRef(__IntPtr __instance, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void** GetVoidPtrRef(__IntPtr __instance, uint key, __IntPtr default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetAllInt@ImGuiStorage@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetAllInt(__IntPtr __instance, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BuildSortByKey@ImGuiStorage@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void BuildSortByKey(__IntPtr __instance);
        }

        public unsafe partial class ImGuiStoragePair : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint key;

                [FieldOffset(8)]
                internal int val_i;

                [FieldOffset(8)]
                internal float val_f;

                [FieldOffset(8)]
                internal __IntPtr val_p;

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStoragePair@ImGuiStorage@@QEAA@IH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint _key, int _val_i);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStoragePair@ImGuiStorage@@QEAA@IM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor_1(__IntPtr __instance, uint _key, float _val_f);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStoragePair@ImGuiStorage@@QEAA@IPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr ctor(__IntPtr __instance, uint _key, __IntPtr _val_p);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiStoragePair@ImGuiStorage@@QEAA@AEBU01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStorage.ImGuiStoragePair> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStorage.ImGuiStoragePair>();

            protected bool __ownsNativeInstance;

            internal static ImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ImGuiStoragePair(native.ToPointer(), skipVTables);
            }

            internal static ImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ImGuiStoragePair)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ImGuiStoragePair(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ImGuiStoragePair(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImGuiStoragePair(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ImGuiStoragePair(uint _key, int _val_i)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance, _key, _val_i);
            }

            public ImGuiStoragePair(uint _key, float _val_f)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor_1(__Instance, _key, _val_f);
            }

            public ImGuiStoragePair(uint _key, __IntPtr _val_p)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance, _key, _val_p);
            }

            public ImGuiStoragePair(global::Cored.ImGuiStorage.ImGuiStoragePair _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal*) __Instance) = *((global::Cored.ImGuiStorage.ImGuiStoragePair.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public uint Key
            {
                get
                {
                    return ((__Internal*)__Instance)->key;
                }

                set
                {
                    ((__Internal*)__Instance)->key = value;
                }
            }

            public int ValI
            {
                get
                {
                    return ((__Internal*)__Instance)->val_i;
                }

                set
                {
                    ((__Internal*)__Instance)->val_i = value;
                }
            }

            public float ValF
            {
                get
                {
                    return ((__Internal*)__Instance)->val_f;
                }

                set
                {
                    ((__Internal*)__Instance)->val_f = value;
                }
            }

            public __IntPtr ValP
            {
                get
                {
                    return ((__Internal*)__Instance)->val_p;
                }

                set
                {
                    ((__Internal*)__Instance)->val_p = (__IntPtr) value;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStorage> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiStorage>();

        protected bool __ownsNativeInstance;

        internal static ImGuiStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImGuiStorage.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImGuiStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStorage(global::Cored.ImGuiStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public ImGuiStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public int GetInt(uint key, int default_val)
        {
            var __ret = __Internal.GetInt(__Instance, key, default_val);
            return __ret;
        }

        public void SetInt(uint key, int val)
        {
            __Internal.SetInt(__Instance, key, val);
        }

        public bool GetBool(uint key, bool default_val)
        {
            var __ret = __Internal.GetBool(__Instance, key, default_val);
            return __ret;
        }

        public void SetBool(uint key, bool val)
        {
            __Internal.SetBool(__Instance, key, val);
        }

        public float GetFloat(uint key, float default_val)
        {
            var __ret = __Internal.GetFloat(__Instance, key, default_val);
            return __ret;
        }

        public void SetFloat(uint key, float val)
        {
            __Internal.SetFloat(__Instance, key, val);
        }

        public __IntPtr GetVoidPtr(uint key)
        {
            var __ret = __Internal.GetVoidPtr(__Instance, key);
            return __ret;
        }

        public void SetVoidPtr(uint key, __IntPtr val)
        {
            __Internal.SetVoidPtr(__Instance, key, val);
        }

        public int* GetIntRef(uint key, int default_val)
        {
            var __ret = __Internal.GetIntRef(__Instance, key, default_val);
            return __ret;
        }

        public bool* GetBoolRef(uint key, bool default_val)
        {
            var __ret = __Internal.GetBoolRef(__Instance, key, default_val);
            return __ret;
        }

        public float* GetFloatRef(uint key, float default_val)
        {
            var __ret = __Internal.GetFloatRef(__Instance, key, default_val);
            return __ret;
        }

        public void** GetVoidPtrRef(uint key, __IntPtr default_val)
        {
            var __ret = __Internal.GetVoidPtrRef(__Instance, key, default_val);
            return __ret;
        }

        public void SetAllInt(int val)
        {
            __Internal.SetAllInt(__Instance, val);
        }

        public void BuildSortByKey()
        {
            __Internal.BuildSortByKey(__Instance);
        }
    }

    public unsafe partial class ImGuiListClipper : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int DisplayStart;
            internal int DisplayEnd;
            internal int ItemsCount;
            internal int StepNo;
            internal int ItemsFrozen;
            internal float ItemsHeight;
            internal float StartPosY;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiListClipper@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiListClipper@@QEAA@HM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiListClipper@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiListClipper@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Begin@ImGuiListClipper@@QEAAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Begin(__IntPtr __instance, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?End@ImGuiListClipper@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void End(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Step@ImGuiListClipper@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Step(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiListClipper> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiListClipper>();

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiListClipper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiListClipper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiListClipper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiListClipper(int items_count, float items_height)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, items_count, items_height);
        }

        public ImGuiListClipper(global::Cored.ImGuiListClipper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiListClipper.__Internal*) __Instance) = *((global::Cored.ImGuiListClipper.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Begin(int items_count, float items_height)
        {
            __Internal.Begin(__Instance, items_count, items_height);
        }

        public void End()
        {
            __Internal.End(__Instance);
        }

        public int DisplayStart
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayStart;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayStart = value;
            }
        }

        public int DisplayEnd
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayEnd = value;
            }
        }

        public int ItemsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsCount = value;
            }
        }

        public int StepNo
        {
            get
            {
                return ((__Internal*)__Instance)->StepNo;
            }

            set
            {
                ((__Internal*)__Instance)->StepNo = value;
            }
        }

        public int ItemsFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsFrozen = value;
            }
        }

        public float ItemsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsHeight = value;
            }
        }

        public float StartPosY
        {
            get
            {
                return ((__Internal*)__Instance)->StartPosY;
            }

            set
            {
                ((__Internal*)__Instance)->StartPosY = value;
            }
        }

        public bool Step
        {
            get
            {
                var __ret = __Internal.Step(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Cored.ImVec4.__Internal Value;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@HHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, uint rgba);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor_1(__IntPtr __instance, float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@AEBUImVec4@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImColor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??BImColor@@QEBAIXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint OperatorConversion(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??BImColor@@QEBA?AUImVec4@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OperatorConversion(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetHSV@ImColor@@QEAAXMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetHSV(__IntPtr __instance, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?HSV@ImColor@@SA?AU1@MMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HSV(__IntPtr @return, float h, float s, float v, float a);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImColor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImColor>();

        protected bool __ownsNativeInstance;

        internal static ImColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImColor(native.ToPointer(), skipVTables);
        }

        internal static ImColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImColor(int r, int g, int b, int a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, r, g, b, a);
        }

        public ImColor(uint rgba)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance, rgba);
        }

        public ImColor(float r, float g, float b, float a)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor_1(__Instance, r, g, b, a);
        }

        public ImColor(global::Cored.ImVec4 col)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = col.__Instance;
            __Internal.ctor(__Instance, __arg0);
        }

        public ImColor(global::Cored.ImColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImColor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImColor.__Internal*) __Instance) = *((global::Cored.ImColor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static implicit operator uint(global::Cored.ImColor __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = __Internal.OperatorConversion(__arg0);
            return __ret;
        }

        public static implicit operator global::Cored.ImVec4(global::Cored.ImColor __op)
        {
            if (ReferenceEquals(__op, null))
                throw new global::System.ArgumentNullException("__op", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = __op.__Instance;
            var __ret = new global::Cored.ImVec4.__Internal();
            __Internal.OperatorConversion(__arg0, new IntPtr(&__ret));
            return global::Cored.ImVec4.__CreateInstance(__ret);
        }

        public void SetHSV(float h, float s, float v, float a)
        {
            __Internal.SetHSV(__Instance, h, s, v, a);
        }

        public static implicit operator global::Cored.ImColor(uint rgba)
        {
            return new global::Cored.ImColor(rgba);
        }

        public static implicit operator global::Cored.ImColor(global::Cored.ImVec4 col)
        {
            return new global::Cored.ImColor(col);
        }

        public static global::Cored.ImColor HSV(float h, float s, float v, float a)
        {
            var __ret = new global::Cored.ImColor.__Internal();
            __Internal.HSV(new IntPtr(&__ret), h, s, v, a);
            return global::Cored.ImColor.__CreateInstance(__ret);
        }

        public global::Cored.ImVec4 Value
        {
            get
            {
                return global::Cored.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Value = *(global::Cored.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal global::Cored.ImVec4.__Internal ClipRect;
            internal __IntPtr TextureId;
            internal uint VtxOffset;
            internal uint IdxOffset;
            internal uint ElemCount;
            internal __IntPtr UserCallback;
            internal __IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawCmd@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTexID@ImDrawCmd@@QEBAPEAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetTexID(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawCmd> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawCmd>();

        protected bool __ownsNativeInstance;

        internal static ImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImDrawCmd(global::Cored.ImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImDrawCmd.__Internal*) __Instance) = *((global::Cored.ImDrawCmd.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImVec4 ClipRect
        {
            get
            {
                return global::Cored.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::Cored.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }

        public uint IdxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->IdxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->IdxOffset = value;
            }
        }

        public uint ElemCount
        {
            get
            {
                return ((__Internal*)__Instance)->ElemCount;
            }

            set
            {
                ((__Internal*)__Instance)->ElemCount = value;
            }
        }

        public global::Cored.ImDrawCallback UserCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.ImDrawCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.ImDrawCallback));
            }

            set
            {
                ((__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserCallbackData
        {
            get
            {
                return ((__Internal*)__Instance)->UserCallbackData;
            }

            set
            {
                ((__Internal*)__Instance)->UserCallbackData = (__IntPtr) value;
            }
        }

        public __IntPtr TexID
        {
            get
            {
                var __ret = __Internal.GetTexID(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal global::Cored.ImVec2.__Internal pos;
            internal global::Cored.ImVec2.__Internal uv;
            internal uint col;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawVert@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawVert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawVert>();

        protected bool __ownsNativeInstance;

        internal static ImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImDrawVert(global::Cored.ImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImDrawVert.__Internal*) __Instance) = *((global::Cored.ImDrawVert.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImVec2 Pos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 Uv
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uv = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public uint Col
        {
            get
            {
                return ((__Internal*)__Instance)->col;
            }

            set
            {
                ((__Internal*)__Instance)->col = value;
            }
        }
    }

    public unsafe partial class ImDrawCmdHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::Cored.ImVec4.__Internal ClipRect;
            internal __IntPtr TextureId;
            internal uint VtxOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawCmdHeader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawCmdHeader@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawCmdHeader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawCmdHeader>();

        protected bool __ownsNativeInstance;

        internal static ImDrawCmdHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmdHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawCmdHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawCmdHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmdHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawCmdHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmdHeader(global::Cored.ImDrawCmdHeader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImDrawCmdHeader.__Internal*) __Instance) = *((global::Cored.ImDrawCmdHeader.__Internal*) _0.__Instance);
        }

        public ImDrawCmdHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImVec4 ClipRect
        {
            get
            {
                return global::Cored.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::Cored.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }
    }

    public unsafe partial class ImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal _CmdBuffer;
            internal global::Cored.ImVector.__Internal _IdxBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawChannel@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImDrawChannel@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawChannel> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawChannel>();

        protected bool __ownsNativeInstance;

        internal static ImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImDrawChannel.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawChannel(global::Cored.ImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public ImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    public unsafe partial class ImDrawListSplitter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int _Current;
            internal int _Count;
            internal global::Cored.ImVector.__Internal _Channels;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawListSplitter@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawListSplitter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImDrawListSplitter@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImDrawListSplitter@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearFreeMemory(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Split(__IntPtr __instance, __IntPtr draw_list, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Merge(__IntPtr __instance, __IntPtr draw_list);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetCurrentChannel(__IntPtr __instance, __IntPtr draw_list, int channel_idx);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawListSplitter> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawListSplitter>();

        protected bool __ownsNativeInstance;

        internal static ImDrawListSplitter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSplitter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawListSplitter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawListSplitter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImDrawListSplitter.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImDrawListSplitter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawListSplitter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSplitter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImDrawListSplitter(global::Cored.ImDrawListSplitter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public void ClearFreeMemory()
        {
            __Internal.ClearFreeMemory(__Instance);
        }

        public void Split(global::Cored.ImDrawList draw_list, int count)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.Split(__Instance, __arg0, count);
        }

        public void Merge(global::Cored.ImDrawList draw_list)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.Merge(__Instance, __arg0);
        }

        public void SetCurrentChannel(global::Cored.ImDrawList draw_list, int channel_idx)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.SetCurrentChannel(__Instance, __arg0, channel_idx);
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->_Current;
            }

            set
            {
                ((__Internal*)__Instance)->_Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->_Count;
            }

            set
            {
                ((__Internal*)__Instance)->_Count = value;
            }
        }
    }

    public unsafe partial class ImDrawList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal CmdBuffer;
            internal global::Cored.ImVector.__Internal IdxBuffer;
            internal global::Cored.ImVector.__Internal VtxBuffer;
            internal int Flags;
            internal uint _VtxCurrentIdx;
            internal __IntPtr _Data;
            internal __IntPtr _OwnerName;
            internal __IntPtr _VtxWritePtr;
            internal __IntPtr _IdxWritePtr;
            internal global::Cored.ImVector.__Internal _ClipRectStack;
            internal global::Cored.ImVector.__Internal _TextureIdStack;
            internal global::Cored.ImVector.__Internal _Path;
            internal global::Cored.ImDrawCmdHeader.__Internal _CmdHeader;
            internal global::Cored.ImDrawListSplitter.__Internal _Splitter;
            internal float _FringeScale;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawList@@QEAA@PEBUImDrawListSharedData@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr shared_data);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawList@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor_1(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImDrawList@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PushClipRect(__IntPtr __instance, global::Cored.ImVec2.__Internal clip_rect_min, global::Cored.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushClipRectFullScreen@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PushClipRectFullScreen(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopClipRect@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PopClipRect(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushTextureID@ImDrawList@@QEAAXPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PushTextureID(__IntPtr __instance, __IntPtr texture_id);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopTextureID@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PopTextureID(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddLine(__IntPtr __instance, __IntPtr p1, __IntPtr p2, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddRect(__IntPtr __instance, __IntPtr p_min, __IntPtr p_max, uint col, float rounding, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddRectFilled(__IntPtr __instance, __IntPtr p_min, __IntPtr p_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddRectFilledMultiColor(__IntPtr __instance, __IntPtr p_min, __IntPtr p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddQuad(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, __IntPtr p4, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddQuadFilled(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, __IntPtr p4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddTriangle(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddTriangleFilled(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddCircle(__IntPtr __instance, __IntPtr center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddCircleFilled(__IntPtr __instance, __IntPtr center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddNgon@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddNgon(__IntPtr __instance, __IntPtr center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddNgonFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddNgonFilled(__IntPtr __instance, __IntPtr center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddText(__IntPtr __instance, __IntPtr pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddText(__IntPtr __instance, __IntPtr font, float font_size, __IntPtr pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, __IntPtr cpu_fine_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddPolyline(__IntPtr __instance, __IntPtr points, int num_points, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddConvexPolyFilled(__IntPtr __instance, __IntPtr points, int num_points, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBezierCubic(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, __IntPtr p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddBezierQuadratic@ImDrawList@@QEAAXAEBUImVec2@@00IMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBezierQuadratic(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddImage(__IntPtr __instance, __IntPtr user_texture_id, __IntPtr p_min, __IntPtr p_max, __IntPtr uv_min, __IntPtr uv_max, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddImageQuad(__IntPtr __instance, __IntPtr user_texture_id, __IntPtr p1, __IntPtr p2, __IntPtr p3, __IntPtr p4, __IntPtr uv1, __IntPtr uv2, __IntPtr uv3, __IntPtr uv4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddImageRounded(__IntPtr __instance, __IntPtr user_texture_id, __IntPtr p_min, __IntPtr p_max, __IntPtr uv_min, __IntPtr uv_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathClear@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathClear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathLineTo@ImDrawList@@QEAAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathLineTo(__IntPtr __instance, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathLineToMergeDuplicate@ImDrawList@@QEAAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathLineToMergeDuplicate(__IntPtr __instance, __IntPtr pos);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathFillConvex@ImDrawList@@QEAAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathFillConvex(__IntPtr __instance, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathStroke@ImDrawList@@QEAAXIHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathStroke(__IntPtr __instance, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathArcTo(__IntPtr __instance, __IntPtr center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathArcToFast(__IntPtr __instance, __IntPtr center, float radius, int a_min_of_12, int a_max_of_12);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathBezierCubicCurveTo(__IntPtr __instance, __IntPtr p2, __IntPtr p3, __IntPtr p4, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathBezierQuadraticCurveTo@ImDrawList@@QEAAXAEBUImVec2@@0H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathBezierQuadraticCurveTo(__IntPtr __instance, __IntPtr p2, __IntPtr p3, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathRect(__IntPtr __instance, __IntPtr rect_min, __IntPtr rect_max, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddCallback(__IntPtr __instance, __IntPtr callback, __IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddDrawCmd@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddDrawCmd(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CloneOutput@ImDrawList@@QEBAPEAU1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CloneOutput(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ChannelsSplit@ImDrawList@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ChannelsSplit(__IntPtr __instance, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ChannelsMerge@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ChannelsMerge(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ChannelsSetCurrent@ImDrawList@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ChannelsSetCurrent(__IntPtr __instance, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimReserve@ImDrawList@@QEAAXHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimReserve(__IntPtr __instance, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimUnreserve@ImDrawList@@QEAAXHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimUnreserve(__IntPtr __instance, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimRect(__IntPtr __instance, __IntPtr a, __IntPtr b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimRectUV(__IntPtr __instance, __IntPtr a, __IntPtr b, __IntPtr uv_a, __IntPtr uv_b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimQuadUV(__IntPtr __instance, __IntPtr a, __IntPtr b, __IntPtr c, __IntPtr d, __IntPtr uv_a, __IntPtr uv_b, __IntPtr uv_c, __IntPtr uv_d, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimWriteVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimWriteVtx(__IntPtr __instance, __IntPtr pos, __IntPtr uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimWriteIdx@ImDrawList@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimWriteIdx(__IntPtr __instance, ushort idx);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PrimVtx@ImDrawList@@QEAAXAEBUImVec2@@0I@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PrimVtx(__IntPtr __instance, __IntPtr pos, __IntPtr uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddBezierCurve@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddBezierCurve(__IntPtr __instance, __IntPtr p1, __IntPtr p2, __IntPtr p3, __IntPtr p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PathBezierCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathBezierCurveTo(__IntPtr __instance, __IntPtr p2, __IntPtr p3, __IntPtr p4, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_ResetForNewFrame@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ResetForNewFrame(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_ClearFreeMemory@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearFreeMemory(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PopUnusedDrawCmd(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_TryMergeDrawCmds@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void TryMergeDrawCmds(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_OnChangedClipRect@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnChangedClipRect(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_OnChangedTextureID@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnChangedTextureID(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnChangedVtxOffset(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int CalcCircleAutoSegmentCount(__IntPtr __instance, float radius);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathArcToFastEx(__IntPtr __instance, __IntPtr center, float radius, int a_min_sample, int a_max_sample, int a_step);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PathArcToN(__IntPtr __instance, __IntPtr center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetClipRectMin@ImDrawList@@QEBA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetClipRectMin(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetClipRectMax@ImDrawList@@QEBA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetClipRectMax(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawList>();

        protected bool __ownsNativeInstance;

        internal static ImDrawList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawList(native.ToPointer(), skipVTables);
        }

        internal static ImDrawList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImDrawList.__Internal.cctor_1(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImDrawList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawList(global::Cored.ImDrawListSharedData shared_data)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __arg0 = shared_data is null ? __IntPtr.Zero : shared_data.__Instance;
            __Internal.ctor(__Instance, __arg0);
        }

        public ImDrawList(global::Cored.ImDrawList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor_1(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void PushClipRect(global::Cored.ImVec2 clip_rect_min, global::Cored.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_max.__Instance;
            __Internal.PushClipRect(__Instance, *(global::Cored.ImVec2.__Internal*) __arg0, *(global::Cored.ImVec2.__Internal*) __arg1, intersect_with_current_clip_rect);
        }

        public void PushClipRectFullScreen()
        {
            __Internal.PushClipRectFullScreen(__Instance);
        }

        public void PopClipRect()
        {
            __Internal.PopClipRect(__Instance);
        }

        public void PushTextureID(__IntPtr texture_id)
        {
            __Internal.PushTextureID(__Instance, texture_id);
        }

        public void PopTextureID()
        {
            __Internal.PopTextureID(__Instance);
        }

        public void AddLine(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, uint col, float thickness)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            __Internal.AddLine(__Instance, __arg0, __arg1, col, thickness);
        }

        public void AddRect(global::Cored.ImVec2 p_min, global::Cored.ImVec2 p_max, uint col, float rounding, int flags, float thickness)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p_max.__Instance;
            __Internal.AddRect(__Instance, __arg0, __arg1, col, rounding, flags, thickness);
        }

        public void AddRectFilled(global::Cored.ImVec2 p_min, global::Cored.ImVec2 p_max, uint col, float rounding, int flags)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p_max.__Instance;
            __Internal.AddRectFilled(__Instance, __arg0, __arg1, col, rounding, flags);
        }

        public void AddRectFilledMultiColor(global::Cored.ImVec2 p_min, global::Cored.ImVec2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p_max.__Instance;
            __Internal.AddRectFilledMultiColor(__Instance, __arg0, __arg1, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
        }

        public void AddQuad(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, uint col, float thickness)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = p4.__Instance;
            __Internal.AddQuad(__Instance, __arg0, __arg1, __arg2, __arg3, col, thickness);
        }

        public void AddQuadFilled(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, uint col)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = p4.__Instance;
            __Internal.AddQuadFilled(__Instance, __arg0, __arg1, __arg2, __arg3, col);
        }

        public void AddTriangle(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, uint col, float thickness)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            __Internal.AddTriangle(__Instance, __arg0, __arg1, __arg2, col, thickness);
        }

        public void AddTriangleFilled(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, uint col)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            __Internal.AddTriangleFilled(__Instance, __arg0, __arg1, __arg2, col);
        }

        public void AddCircle(global::Cored.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.AddCircle(__Instance, __arg0, radius, col, num_segments, thickness);
        }

        public void AddCircleFilled(global::Cored.ImVec2 center, float radius, uint col, int num_segments)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.AddCircleFilled(__Instance, __arg0, radius, col, num_segments);
        }

        public void AddNgon(global::Cored.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.AddNgon(__Instance, __arg0, radius, col, num_segments, thickness);
        }

        public void AddNgonFilled(global::Cored.ImVec2 center, float radius, uint col, int num_segments)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.AddNgonFilled(__Instance, __arg0, radius, col, num_segments);
        }

        public void AddText(global::Cored.ImVec2 pos, uint col, string text_begin, string text_end)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pos.__Instance;
            __Internal.AddText(__Instance, __arg0, col, text_begin, text_end);
        }

        public void AddText(global::Cored.ImFont font, float font_size, global::Cored.ImVec2 pos, uint col, string text_begin, string text_end, float wrap_width, global::Cored.ImVec4 cpu_fine_clip_rect)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = pos.__Instance;
            var __arg7 = cpu_fine_clip_rect is null ? __IntPtr.Zero : cpu_fine_clip_rect.__Instance;
            __Internal.AddText(__Instance, __arg0, font_size, __arg2, col, text_begin, text_end, wrap_width, __arg7);
        }

        public void AddPolyline(global::Cored.ImVec2 points, int num_points, uint col, int flags, float thickness)
        {
            var __arg0 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.AddPolyline(__Instance, __arg0, num_points, col, flags, thickness);
        }

        public void AddConvexPolyFilled(global::Cored.ImVec2 points, int num_points, uint col)
        {
            var __arg0 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.AddConvexPolyFilled(__Instance, __arg0, num_points, col);
        }

        public void AddBezierCubic(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = p4.__Instance;
            __Internal.AddBezierCubic(__Instance, __arg0, __arg1, __arg2, __arg3, col, thickness, num_segments);
        }

        public void AddBezierQuadratic(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, uint col, float thickness, int num_segments)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            __Internal.AddBezierQuadratic(__Instance, __arg0, __arg1, __arg2, col, thickness, num_segments);
        }

        public void AddImage(__IntPtr user_texture_id, global::Cored.ImVec2 p_min, global::Cored.ImVec2 p_max, global::Cored.ImVec2 uv_min, global::Cored.ImVec2 uv_max, uint col)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = uv_max.__Instance;
            __Internal.AddImage(__Instance, user_texture_id, __arg1, __arg2, __arg3, __arg4, col);
        }

        public void AddImageQuad(__IntPtr user_texture_id, global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, global::Cored.ImVec2 uv1, global::Cored.ImVec2 uv2, global::Cored.ImVec2 uv3, global::Cored.ImVec2 uv4, uint col)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = uv1.__Instance;
            if (ReferenceEquals(uv2, null))
                throw new global::System.ArgumentNullException("uv2", "Cannot be null because it is a C++ reference (&).");
            var __arg6 = uv2.__Instance;
            if (ReferenceEquals(uv3, null))
                throw new global::System.ArgumentNullException("uv3", "Cannot be null because it is a C++ reference (&).");
            var __arg7 = uv3.__Instance;
            if (ReferenceEquals(uv4, null))
                throw new global::System.ArgumentNullException("uv4", "Cannot be null because it is a C++ reference (&).");
            var __arg8 = uv4.__Instance;
            __Internal.AddImageQuad(__Instance, user_texture_id, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, __arg8, col);
        }

        public void AddImageRounded(__IntPtr user_texture_id, global::Cored.ImVec2 p_min, global::Cored.ImVec2 p_max, global::Cored.ImVec2 uv_min, global::Cored.ImVec2 uv_max, uint col, float rounding, int flags)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = uv_max.__Instance;
            __Internal.AddImageRounded(__Instance, user_texture_id, __arg1, __arg2, __arg3, __arg4, col, rounding, flags);
        }

        public void PathClear()
        {
            __Internal.PathClear(__Instance);
        }

        public void PathLineTo(global::Cored.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pos.__Instance;
            __Internal.PathLineTo(__Instance, __arg0);
        }

        public void PathLineToMergeDuplicate(global::Cored.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pos.__Instance;
            __Internal.PathLineToMergeDuplicate(__Instance, __arg0);
        }

        public void PathFillConvex(uint col)
        {
            __Internal.PathFillConvex(__Instance, col);
        }

        public void PathStroke(uint col, int flags, float thickness)
        {
            __Internal.PathStroke(__Instance, col, flags, thickness);
        }

        public void PathArcTo(global::Cored.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.PathArcTo(__Instance, __arg0, radius, a_min, a_max, num_segments);
        }

        public void PathArcToFast(global::Cored.ImVec2 center, float radius, int a_min_of_12, int a_max_of_12)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.PathArcToFast(__Instance, __arg0, radius, a_min_of_12, a_max_of_12);
        }

        public void PathBezierCubicCurveTo(global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, int num_segments)
        {
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p4.__Instance;
            __Internal.PathBezierCubicCurveTo(__Instance, __arg0, __arg1, __arg2, num_segments);
        }

        public void PathBezierQuadraticCurveTo(global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, int num_segments)
        {
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p3.__Instance;
            __Internal.PathBezierQuadraticCurveTo(__Instance, __arg0, __arg1, num_segments);
        }

        public void PathRect(global::Cored.ImVec2 rect_min, global::Cored.ImVec2 rect_max, float rounding, int flags)
        {
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = rect_max.__Instance;
            __Internal.PathRect(__Instance, __arg0, __arg1, rounding, flags);
        }

        public void AddCallback(global::Cored.ImDrawCallback callback, __IntPtr callback_data)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.AddCallback(__Instance, __arg0, callback_data);
        }

        public void AddDrawCmd()
        {
            __Internal.AddDrawCmd(__Instance);
        }

        public global::Cored.ImDrawList CloneOutput()
        {
            var __ret = __Internal.CloneOutput(__Instance);
            var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public void ChannelsSplit(int count)
        {
            __Internal.ChannelsSplit(__Instance, count);
        }

        public void ChannelsMerge()
        {
            __Internal.ChannelsMerge(__Instance);
        }

        public void ChannelsSetCurrent(int n)
        {
            __Internal.ChannelsSetCurrent(__Instance, n);
        }

        public void PrimReserve(int idx_count, int vtx_count)
        {
            __Internal.PrimReserve(__Instance, idx_count, vtx_count);
        }

        public void PrimUnreserve(int idx_count, int vtx_count)
        {
            __Internal.PrimUnreserve(__Instance, idx_count, vtx_count);
        }

        public void PrimRect(global::Cored.ImVec2 a, global::Cored.ImVec2 b, uint col)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            __Internal.PrimRect(__Instance, __arg0, __arg1, col);
        }

        public void PrimRectUV(global::Cored.ImVec2 a, global::Cored.ImVec2 b, global::Cored.ImVec2 uv_a, global::Cored.ImVec2 uv_b, uint col)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = uv_b.__Instance;
            __Internal.PrimRectUV(__Instance, __arg0, __arg1, __arg2, __arg3, col);
        }

        public void PrimQuadUV(global::Cored.ImVec2 a, global::Cored.ImVec2 b, global::Cored.ImVec2 c, global::Cored.ImVec2 d, global::Cored.ImVec2 uv_a, global::Cored.ImVec2 uv_b, global::Cored.ImVec2 uv_c, global::Cored.ImVec2 uv_d, uint col)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = d.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = uv_b.__Instance;
            if (ReferenceEquals(uv_c, null))
                throw new global::System.ArgumentNullException("uv_c", "Cannot be null because it is a C++ reference (&).");
            var __arg6 = uv_c.__Instance;
            if (ReferenceEquals(uv_d, null))
                throw new global::System.ArgumentNullException("uv_d", "Cannot be null because it is a C++ reference (&).");
            var __arg7 = uv_d.__Instance;
            __Internal.PrimQuadUV(__Instance, __arg0, __arg1, __arg2, __arg3, __arg4, __arg5, __arg6, __arg7, col);
        }

        public void PrimWriteVtx(global::Cored.ImVec2 pos, global::Cored.ImVec2 uv, uint col)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            __Internal.PrimWriteVtx(__Instance, __arg0, __arg1, col);
        }

        public void PrimWriteIdx(ushort idx)
        {
            __Internal.PrimWriteIdx(__Instance, idx);
        }

        public void PrimVtx(global::Cored.ImVec2 pos, global::Cored.ImVec2 uv, uint col)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = uv.__Instance;
            __Internal.PrimVtx(__Instance, __arg0, __arg1, col);
        }

        public void AddBezierCurve(global::Cored.ImVec2 p1, global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg3 = p4.__Instance;
            __Internal.AddBezierCurve(__Instance, __arg0, __arg1, __arg2, __arg3, col, thickness, num_segments);
        }

        public void PathBezierCurveTo(global::Cored.ImVec2 p2, global::Cored.ImVec2 p3, global::Cored.ImVec2 p4, int num_segments)
        {
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is a C++ reference (&).");
            var __arg1 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is a C++ reference (&).");
            var __arg2 = p4.__Instance;
            __Internal.PathBezierCurveTo(__Instance, __arg0, __arg1, __arg2, num_segments);
        }

        public void ResetForNewFrame()
        {
            __Internal.ResetForNewFrame(__Instance);
        }

        public void ClearFreeMemory()
        {
            __Internal.ClearFreeMemory(__Instance);
        }

        public void PopUnusedDrawCmd()
        {
            __Internal.PopUnusedDrawCmd(__Instance);
        }

        public void TryMergeDrawCmds()
        {
            __Internal.TryMergeDrawCmds(__Instance);
        }

        public void OnChangedClipRect()
        {
            __Internal.OnChangedClipRect(__Instance);
        }

        public void OnChangedTextureID()
        {
            __Internal.OnChangedTextureID(__Instance);
        }

        public void OnChangedVtxOffset()
        {
            __Internal.OnChangedVtxOffset(__Instance);
        }

        public int CalcCircleAutoSegmentCount(float radius)
        {
            var __ret = __Internal.CalcCircleAutoSegmentCount(__Instance, radius);
            return __ret;
        }

        public void PathArcToFastEx(global::Cored.ImVec2 center, float radius, int a_min_sample, int a_max_sample, int a_step)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.PathArcToFastEx(__Instance, __arg0, radius, a_min_sample, a_max_sample, a_step);
        }

        public void PathArcToN(global::Cored.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = center.__Instance;
            __Internal.PathArcToN(__Instance, __arg0, radius, a_min, a_max, num_segments);
        }

        public static implicit operator global::Cored.ImDrawList(global::Cored.ImDrawListSharedData shared_data)
        {
            return new global::Cored.ImDrawList(shared_data);
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint VtxCurrentIdx
        {
            get
            {
                return ((__Internal*)__Instance)->_VtxCurrentIdx;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxCurrentIdx = value;
            }
        }

        public global::Cored.ImDrawListSharedData Data
        {
            get
            {
                var __result0 = global::Cored.ImDrawListSharedData.__GetOrCreateInstance(((__Internal*)__Instance)->_Data, false);
                return __result0;
            }
        }

        public string OwnerName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_OwnerName);
            }

            set
            {
                byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                fixed (byte* __bytePtr0 = __bytes0)
                {
                    ((__Internal*)__Instance)->_OwnerName = (__IntPtr) new global::System.IntPtr(__bytePtr0);
                }
            }
        }

        public global::Cored.ImDrawVert VtxWritePtr
        {
            get
            {
                var __result0 = global::Cored.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->_VtxWritePtr, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxWritePtr = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ushort* IdxWritePtr
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->_IdxWritePtr;
            }

            set
            {
                ((__Internal*)__Instance)->_IdxWritePtr = (__IntPtr) value;
            }
        }

        public global::Cored.ImDrawCmdHeader CmdHeader
        {
            get
            {
                return global::Cored.ImDrawCmdHeader.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdHeader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdHeader = *(global::Cored.ImDrawCmdHeader.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImDrawListSplitter Splitter
        {
            get
            {
                return global::Cored.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Splitter = *(global::Cored.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public float FringeScale
        {
            get
            {
                return ((__Internal*)__Instance)->_FringeScale;
            }

            set
            {
                ((__Internal*)__Instance)->_FringeScale = value;
            }
        }

        public global::Cored.ImVec2 ClipRectMin
        {
            get
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetClipRectMin(__Instance, new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }
        }

        public global::Cored.ImVec2 ClipRectMax
        {
            get
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetClipRectMax(__Instance, new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class ImDrawData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal byte Valid;
            internal int CmdListsCount;
            internal int TotalIdxCount;
            internal int TotalVtxCount;
            internal __IntPtr CmdLists;
            internal global::Cored.ImVec2.__Internal DisplayPos;
            internal global::Cored.ImVec2.__Internal DisplaySize;
            internal global::Cored.ImVec2.__Internal FramebufferScale;
            internal __IntPtr OwnerViewport;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawData@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImDrawData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImDrawData@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DeIndexAllBuffers@ImDrawData@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DeIndexAllBuffers(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ScaleClipRects(__IntPtr __instance, __IntPtr fb_scale);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImDrawData>();

        protected bool __ownsNativeInstance;

        internal static ImDrawData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImDrawData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImDrawData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImDrawData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImDrawData(global::Cored.ImDrawData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImDrawData.__Internal*) __Instance) = *((global::Cored.ImDrawData.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public void DeIndexAllBuffers()
        {
            __Internal.DeIndexAllBuffers(__Instance);
        }

        public void ScaleClipRects(global::Cored.ImVec2 fb_scale)
        {
            if (ReferenceEquals(fb_scale, null))
                throw new global::System.ArgumentNullException("fb_scale", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = fb_scale.__Instance;
            __Internal.ScaleClipRects(__Instance, __arg0);
        }

        public bool Valid
        {
            get
            {
                return ((__Internal*)__Instance)->Valid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Valid = (byte) (value ? 1 : 0);
            }
        }

        public int CmdListsCount
        {
            get
            {
                return ((__Internal*)__Instance)->CmdListsCount;
            }

            set
            {
                ((__Internal*)__Instance)->CmdListsCount = value;
            }
        }

        public int TotalIdxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalIdxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalIdxCount = value;
            }
        }

        public int TotalVtxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalVtxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalVtxCount = value;
            }
        }

        public global::Cored.ImDrawList CmdLists
        {
            get
            {
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->CmdLists, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->CmdLists = new __IntPtr(&__value);
            }
        }

        public global::Cored.ImVec2 DisplayPos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayPos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 DisplaySize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 FramebufferScale
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramebufferScale = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImGuiViewport OwnerViewport
        {
            get
            {
                var __result0 = global::Cored.ImGuiViewport.__GetOrCreateInstance(((__Internal*)__Instance)->OwnerViewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->OwnerViewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            internal __IntPtr FontData;
            internal int FontDataSize;
            internal byte FontDataOwnedByAtlas;
            internal int FontNo;
            internal float SizePixels;
            internal int OversampleH;
            internal int OversampleV;
            internal byte PixelSnapH;
            internal global::Cored.ImVec2.__Internal GlyphExtraSpacing;
            internal global::Cored.ImVec2.__Internal GlyphOffset;
            internal __IntPtr GlyphRanges;
            internal float GlyphMinAdvanceX;
            internal float GlyphMaxAdvanceX;
            internal byte MergeMode;
            internal uint FontBuilderFlags;
            internal float RasterizerMultiply;
            internal ushort EllipsisChar;
            internal fixed sbyte Name[40];
            internal __IntPtr DstFont;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontConfig@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontConfig> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontConfig>();

        protected bool __ownsNativeInstance;

        internal static ImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImFontConfig(global::Cored.ImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImFontConfig.__Internal*) __Instance) = *((global::Cored.ImFontConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr FontData
        {
            get
            {
                return ((__Internal*)__Instance)->FontData;
            }

            set
            {
                ((__Internal*)__Instance)->FontData = (__IntPtr) value;
            }
        }

        public int FontDataSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataSize = value;
            }
        }

        public bool FontDataOwnedByAtlas
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataOwnedByAtlas != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataOwnedByAtlas = (byte) (value ? 1 : 0);
            }
        }

        public int FontNo
        {
            get
            {
                return ((__Internal*)__Instance)->FontNo;
            }

            set
            {
                ((__Internal*)__Instance)->FontNo = value;
            }
        }

        public float SizePixels
        {
            get
            {
                return ((__Internal*)__Instance)->SizePixels;
            }

            set
            {
                ((__Internal*)__Instance)->SizePixels = value;
            }
        }

        public int OversampleH
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleH;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleH = value;
            }
        }

        public int OversampleV
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleV;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleV = value;
            }
        }

        public bool PixelSnapH
        {
            get
            {
                return ((__Internal*)__Instance)->PixelSnapH != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PixelSnapH = (byte) (value ? 1 : 0);
            }
        }

        public global::Cored.ImVec2 GlyphExtraSpacing
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphExtraSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphExtraSpacing = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 GlyphOffset
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public ushort* GlyphRanges
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->GlyphRanges;
            }
        }

        public float GlyphMinAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMinAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMinAdvanceX = value;
            }
        }

        public float GlyphMaxAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMaxAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMaxAdvanceX = value;
            }
        }

        public bool MergeMode
        {
            get
            {
                return ((__Internal*)__Instance)->MergeMode != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MergeMode = (byte) (value ? 1 : 0);
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public float RasterizerMultiply
        {
            get
            {
                return ((__Internal*)__Instance)->RasterizerMultiply;
            }

            set
            {
                ((__Internal*)__Instance)->RasterizerMultiply = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::Cored.ImFont DstFont
        {
            get
            {
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->DstFont, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DstFont = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint Colored;

            [FieldOffset(0)]
            internal uint Visible;

            [FieldOffset(0)]
            internal uint Codepoint;

            [FieldOffset(4)]
            internal float AdvanceX;

            [FieldOffset(8)]
            internal float X0;

            [FieldOffset(12)]
            internal float Y0;

            [FieldOffset(16)]
            internal float X1;

            [FieldOffset(20)]
            internal float Y1;

            [FieldOffset(24)]
            internal float U0;

            [FieldOffset(28)]
            internal float V0;

            [FieldOffset(32)]
            internal float U1;

            [FieldOffset(36)]
            internal float V1;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontGlyph> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontGlyph>();

        protected bool __ownsNativeInstance;

        internal static ImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public ImFontGlyph(global::Cored.ImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImFontGlyph.__Internal*) __Instance) = *((global::Cored.ImFontGlyph.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Colored
        {
            get
            {
                return ((__Internal*)__Instance)->Colored;
            }

            set
            {
                ((__Internal*)__Instance)->Colored = value;
            }
        }

        public uint Visible
        {
            get
            {
                return ((__Internal*)__Instance)->Visible;
            }

            set
            {
                ((__Internal*)__Instance)->Visible = value;
            }
        }

        public uint Codepoint
        {
            get
            {
                return ((__Internal*)__Instance)->Codepoint;
            }

            set
            {
                ((__Internal*)__Instance)->Codepoint = value;
            }
        }

        public float AdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->AdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->AdvanceX = value;
            }
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->X0;
            }

            set
            {
                ((__Internal*)__Instance)->X0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((__Internal*)__Instance)->Y0;
            }

            set
            {
                ((__Internal*)__Instance)->Y0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->X1;
            }

            set
            {
                ((__Internal*)__Instance)->X1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->Y1;
            }

            set
            {
                ((__Internal*)__Instance)->Y1 = value;
            }
        }

        public float U0
        {
            get
            {
                return ((__Internal*)__Instance)->U0;
            }

            set
            {
                ((__Internal*)__Instance)->U0 = value;
            }
        }

        public float V0
        {
            get
            {
                return ((__Internal*)__Instance)->V0;
            }

            set
            {
                ((__Internal*)__Instance)->V0 = value;
            }
        }

        public float U1
        {
            get
            {
                return ((__Internal*)__Instance)->U1;
            }

            set
            {
                ((__Internal*)__Instance)->U1 = value;
            }
        }

        public float V1
        {
            get
            {
                return ((__Internal*)__Instance)->V1;
            }

            set
            {
                ((__Internal*)__Instance)->V1 = value;
            }
        }
    }

    public unsafe partial class ImFontGlyphRangesBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal UsedChars;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontGlyphRangesBuilder@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontGlyphRangesBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImFontGlyphRangesBuilder@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImFontGlyphRangesBuilder@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetBit@ImFontGlyphRangesBuilder@@QEBA_N_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetBit(__IntPtr __instance, ulong n);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetBit@ImFontGlyphRangesBuilder@@QEAAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetBit(__IntPtr __instance, ulong n);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddChar@ImFontGlyphRangesBuilder@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddChar(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddText(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddRanges(__IntPtr __instance, ushort* ranges);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontGlyphRangesBuilder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontGlyphRangesBuilder>();

        protected bool __ownsNativeInstance;

        internal static ImFontGlyphRangesBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyphRangesBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontGlyphRangesBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontGlyphRangesBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImFontGlyphRangesBuilder.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImFontGlyphRangesBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontGlyphRangesBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyphRangesBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImFontGlyphRangesBuilder(global::Cored.ImFontGlyphRangesBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public bool GetBit(ulong n)
        {
            var __ret = __Internal.GetBit(__Instance, n);
            return __ret;
        }

        public void SetBit(ulong n)
        {
            __Internal.SetBit(__Instance, n);
        }

        public void AddChar(ushort c)
        {
            __Internal.AddChar(__Instance, c);
        }

        public void AddText(string text, string text_end)
        {
            __Internal.AddText(__Instance, text, text_end);
        }

        public void AddRanges(ref ushort ranges)
        {
            fixed (ushort* __ranges0 = &ranges)
            {
                var __arg0 = __ranges0;
                __Internal.AddRanges(__Instance, __arg0);
            }
        }
    }

    public unsafe partial class ImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal ushort Width;
            internal ushort Height;
            internal ushort X;
            internal ushort Y;
            internal uint GlyphID;
            internal float GlyphAdvanceX;
            internal global::Cored.ImVec2.__Internal GlyphOffset;
            internal __IntPtr Font;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontAtlasCustomRect@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsPacked@ImFontAtlasCustomRect@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsPacked(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontAtlasCustomRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontAtlasCustomRect>();

        protected bool __ownsNativeInstance;

        internal static ImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImFontAtlasCustomRect(global::Cored.ImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImFontAtlasCustomRect.__Internal*) __Instance) = *((global::Cored.ImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public ushort Height
        {
            get
            {
                return ((__Internal*)__Instance)->Height;
            }

            set
            {
                ((__Internal*)__Instance)->Height = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public uint GlyphID
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphID;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphID = value;
            }
        }

        public float GlyphAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphAdvanceX = value;
            }
        }

        public global::Cored.ImVec2 GlyphOffset
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImFont Font
        {
            get
            {
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public bool IsPacked
        {
            get
            {
                var __ret = __Internal.IsPacked(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImFontAtlas : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1168)]
        public partial struct __Internal
        {
            internal int Flags;
            internal __IntPtr TexID;
            internal int TexDesiredWidth;
            internal int TexGlyphPadding;
            internal byte Locked;
            internal byte TexPixelsUseColors;
            internal __IntPtr TexPixelsAlpha8;
            internal __IntPtr TexPixelsRGBA32;
            internal int TexWidth;
            internal int TexHeight;
            internal global::Cored.ImVec2.__Internal TexUvScale;
            internal global::Cored.ImVec2.__Internal TexUvWhitePixel;
            internal global::Cored.ImVector.__Internal Fonts;
            internal global::Cored.ImVector.__Internal CustomRects;
            internal global::Cored.ImVector.__Internal ConfigData;
            internal fixed byte TexUvLines[1024];
            internal __IntPtr FontBuilderIO;
            internal uint FontBuilderFlags;
            internal int PackIdMouseCursors;
            internal int PackIdLines;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontAtlas@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFontAtlas@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImFontAtlas@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFont(__IntPtr __instance, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFontDefault(__IntPtr __instance, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFontFromFileTTF(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFontFromMemoryTTF(__IntPtr __instance, __IntPtr font_data, int font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFontFromMemoryCompressedTTF(__IntPtr __instance, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr AddFontFromMemoryCompressedBase85TTF(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string compressed_font_data_base85, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearInputData@ImFontAtlas@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearInputData(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearTexData@ImFontAtlas@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearTexData(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearFonts@ImFontAtlas@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearFonts(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Clear@ImFontAtlas@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Clear(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Build@ImFontAtlas@@QEAA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool Build(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetTexDataAsAlpha8(__IntPtr __instance, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetTexDataAsRGBA32(__IntPtr __instance, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetTexID@ImFontAtlas@@QEAAXPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetTexID(__IntPtr __instance, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddCustomRectRegular(__IntPtr __instance, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int AddCustomRectFontGlyph(__IntPtr __instance, __IntPtr font, ushort id, int width, int height, float advance_x, __IntPtr offset);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCustomRectByIndex@ImFontAtlas@@QEAAPEAUImFontAtlasCustomRect@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetCustomRectByIndex(__IntPtr __instance, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CalcCustomRectUV(__IntPtr __instance, __IntPtr rect, __IntPtr out_uv_min, __IntPtr out_uv_max);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool GetMouseCursorTexData(__IntPtr __instance, int cursor, __IntPtr out_offset, __IntPtr out_size, global::Cored.ImVec2.__Internal[] out_uv_border, global::Cored.ImVec2.__Internal[] out_uv_fill);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsBuilt@ImFontAtlas@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsBuilt(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesDefault(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesKorean(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesJapanese(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesChineseFull(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesChineseSimplifiedCommon(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesCyrillic(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesThai(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort* GetGlyphRangesVietnamese(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontAtlas> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFontAtlas>();

        protected bool __ownsNativeInstance;

        internal static ImFontAtlas __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlas(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFontAtlas)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFontAtlas __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlas(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImFontAtlas.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImFontAtlas(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFontAtlas(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlas()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImFontAtlas(global::Cored.ImFontAtlas _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImFont AddFont(global::Cored.ImFontConfig font_cfg)
        {
            var __arg0 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.AddFont(__Instance, __arg0);
            var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public global::Cored.ImFont AddFontDefault(global::Cored.ImFontConfig font_cfg)
        {
            var __arg0 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.AddFontDefault(__Instance, __arg0);
            var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public global::Cored.ImFont AddFontFromFileTTF(string filename, float size_pixels, global::Cored.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg2 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges3 = &glyph_ranges)
            {
                var __arg3 = __glyph_ranges3;
                var __ret = __Internal.AddFontFromFileTTF(__Instance, filename, size_pixels, __arg2, __arg3);
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public global::Cored.ImFont AddFontFromMemoryTTF(__IntPtr font_data, int font_size, float size_pixels, global::Cored.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.AddFontFromMemoryTTF(__Instance, font_data, font_size, size_pixels, __arg3, __arg4);
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public global::Cored.ImFont AddFontFromMemoryCompressedTTF(__IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::Cored.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.AddFontFromMemoryCompressedTTF(__Instance, compressed_font_data, compressed_font_size, size_pixels, __arg3, __arg4);
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public global::Cored.ImFont AddFontFromMemoryCompressedBase85TTF(string compressed_font_data_base85, float size_pixels, global::Cored.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg2 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges3 = &glyph_ranges)
            {
                var __arg3 = __glyph_ranges3;
                var __ret = __Internal.AddFontFromMemoryCompressedBase85TTF(__Instance, compressed_font_data_base85, size_pixels, __arg2, __arg3);
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public void ClearInputData()
        {
            __Internal.ClearInputData(__Instance);
        }

        public void ClearTexData()
        {
            __Internal.ClearTexData(__Instance);
        }

        public void ClearFonts()
        {
            __Internal.ClearFonts(__Instance);
        }

        public void Clear()
        {
            __Internal.Clear(__Instance);
        }

        public bool Build()
        {
            var __ret = __Internal.Build(__Instance);
            return __ret;
        }

        public void GetTexDataAsAlpha8(byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            fixed (int* __out_width1 = &out_width)
            {
                var __arg1 = __out_width1;
                fixed (int* __out_height2 = &out_height)
                {
                    var __arg2 = __out_height2;
                    fixed (int* __out_bytes_per_pixel3 = &out_bytes_per_pixel)
                    {
                        var __arg3 = __out_bytes_per_pixel3;
                        __Internal.GetTexDataAsAlpha8(__Instance, out_pixels, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        public void GetTexDataAsRGBA32(byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            fixed (int* __out_width1 = &out_width)
            {
                var __arg1 = __out_width1;
                fixed (int* __out_height2 = &out_height)
                {
                    var __arg2 = __out_height2;
                    fixed (int* __out_bytes_per_pixel3 = &out_bytes_per_pixel)
                    {
                        var __arg3 = __out_bytes_per_pixel3;
                        __Internal.GetTexDataAsRGBA32(__Instance, out_pixels, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        public void SetTexID(__IntPtr id)
        {
            __Internal.SetTexID(__Instance, id);
        }

        public int AddCustomRectRegular(int width, int height)
        {
            var __ret = __Internal.AddCustomRectRegular(__Instance, width, height);
            return __ret;
        }

        public int AddCustomRectFontGlyph(global::Cored.ImFont font, ushort id, int width, int height, float advance_x, global::Cored.ImVec2 offset)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is a C++ reference (&).");
            var __arg5 = offset.__Instance;
            var __ret = __Internal.AddCustomRectFontGlyph(__Instance, __arg0, id, width, height, advance_x, __arg5);
            return __ret;
        }

        public global::Cored.ImFontAtlasCustomRect GetCustomRectByIndex(int index)
        {
            var __ret = __Internal.GetCustomRectByIndex(__Instance, index);
            var __result0 = global::Cored.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public void CalcCustomRectUV(global::Cored.ImFontAtlasCustomRect rect, global::Cored.ImVec2 out_uv_min, global::Cored.ImVec2 out_uv_max)
        {
            var __arg0 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __arg1 = out_uv_min is null ? __IntPtr.Zero : out_uv_min.__Instance;
            var __arg2 = out_uv_max is null ? __IntPtr.Zero : out_uv_max.__Instance;
            __Internal.CalcCustomRectUV(__Instance, __arg0, __arg1, __arg2);
        }

        public bool GetMouseCursorTexData(int cursor, global::Cored.ImVec2 out_offset, global::Cored.ImVec2 out_size, global::Cored.ImVec2[] out_uv_border, global::Cored.ImVec2[] out_uv_fill)
        {
            var __arg1 = out_offset is null ? __IntPtr.Zero : out_offset.__Instance;
            var __arg2 = out_size is null ? __IntPtr.Zero : out_size.__Instance;
            if (out_uv_border == null || out_uv_border.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_border", "The dimensions of the provided array don't match the required size.");
            global::Cored.ImVec2.__Internal[] __out_uv_border;
            if (out_uv_border is null)
                __out_uv_border = null;
            else
            {
                __out_uv_border = new global::Cored.ImVec2.__Internal[out_uv_border.Length];
                for (int i = 0; i < __out_uv_border.Length; i++)
                {
                    var __element = out_uv_border[i];
                    __out_uv_border[i] = __element is null ? new global::Cored.ImVec2.__Internal() : *(global::Cored.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg3 = __out_uv_border;
            if (out_uv_fill == null || out_uv_fill.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_fill", "The dimensions of the provided array don't match the required size.");
            global::Cored.ImVec2.__Internal[] __out_uv_fill;
            if (out_uv_fill is null)
                __out_uv_fill = null;
            else
            {
                __out_uv_fill = new global::Cored.ImVec2.__Internal[out_uv_fill.Length];
                for (int i = 0; i < __out_uv_fill.Length; i++)
                {
                    var __element = out_uv_fill[i];
                    __out_uv_fill[i] = __element is null ? new global::Cored.ImVec2.__Internal() : *(global::Cored.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg4 = __out_uv_fill;
            var __ret = __Internal.GetMouseCursorTexData(__Instance, cursor, __arg1, __arg2, __arg3, __arg4);
            return __ret;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr TexID
        {
            get
            {
                return ((__Internal*)__Instance)->TexID;
            }

            set
            {
                ((__Internal*)__Instance)->TexID = (__IntPtr) value;
            }
        }

        public int TexDesiredWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexDesiredWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexDesiredWidth = value;
            }
        }

        public int TexGlyphPadding
        {
            get
            {
                return ((__Internal*)__Instance)->TexGlyphPadding;
            }

            set
            {
                ((__Internal*)__Instance)->TexGlyphPadding = value;
            }
        }

        public bool Locked
        {
            get
            {
                return ((__Internal*)__Instance)->Locked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Locked = (byte) (value ? 1 : 0);
            }
        }

        public bool TexPixelsUseColors
        {
            get
            {
                return ((__Internal*)__Instance)->TexPixelsUseColors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsUseColors = (byte) (value ? 1 : 0);
            }
        }

        public byte* TexPixelsAlpha8
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->TexPixelsAlpha8;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsAlpha8 = (__IntPtr) value;
            }
        }

        public uint* TexPixelsRGBA32
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->TexPixelsRGBA32;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsRGBA32 = (__IntPtr) value;
            }
        }

        public int TexWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexWidth = value;
            }
        }

        public int TexHeight
        {
            get
            {
                return ((__Internal*)__Instance)->TexHeight;
            }

            set
            {
                ((__Internal*)__Instance)->TexHeight = value;
            }
        }

        public global::Cored.ImVec2 TexUvScale
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvScale = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec4[] TexUvLines
        {
            get
            {
                global::Cored.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->TexUvLines != null)
                {
                    __value = new global::Cored.ImVec4[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = global::Cored.ImVec4.__CreateInstance(*((global::Cored.ImVec4.__Internal*)&(((__Internal*)__Instance)->TexUvLines[i * sizeof(global::Cored.ImVec4.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 64)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 64; i++)
                        *(global::Cored.ImVec4.__Internal*) &((__Internal*)__Instance)->TexUvLines[i * sizeof(global::Cored.ImVec4.__Internal)] = *(global::Cored.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::Cored.ImFontBuilderIO FontBuilderIO
        {
            get
            {
                var __result0 = global::Cored.ImFontBuilderIO.__GetOrCreateInstance(((__Internal*)__Instance)->FontBuilderIO, false);
                return __result0;
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public int PackIdMouseCursors
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdMouseCursors;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdMouseCursors = value;
            }
        }

        public int PackIdLines
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdLines;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdLines = value;
            }
        }

        public bool IsBuilt
        {
            get
            {
                var __ret = __Internal.IsBuilt(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesDefault
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesDefault(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesKorean
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesKorean(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesJapanese
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesJapanese(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesChineseFull
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesChineseFull(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesChineseSimplifiedCommon
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesChineseSimplifiedCommon(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesCyrillic
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesCyrillic(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesThai
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesThai(__Instance);
                return __ret;
            }
        }

        public ushort* GlyphRangesVietnamese
        {
            get
            {
                var __ret = __Internal.GetGlyphRangesVietnamese(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class ImFont : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal global::Cored.ImVector.__Internal IndexAdvanceX;
            internal float FallbackAdvanceX;
            internal float FontSize;
            internal global::Cored.ImVector.__Internal IndexLookup;
            internal global::Cored.ImVector.__Internal Glyphs;
            internal __IntPtr FallbackGlyph;
            internal __IntPtr ContainerAtlas;
            internal __IntPtr ConfigData;
            internal short ConfigDataCount;
            internal ushort FallbackChar;
            internal ushort EllipsisChar;
            internal byte DirtyLookupTables;
            internal float Scale;
            internal float Ascent;
            internal float Descent;
            internal int MetricsTotalSurface;
            internal fixed byte Used4kPagesMap[2];

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFont@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImFont@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImFont@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FindGlyph(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr FindGlyphNoFallback(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCharAdvance@ImFont@@QEBAMG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float GetCharAdvance(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CalcTextSizeA(__IntPtr __instance, __IntPtr @return, float size, float max_width, float wrap_width, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, sbyte** remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CalcWordWrapPositionA(__IntPtr __instance, float scale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RenderChar(__IntPtr __instance, __IntPtr draw_list, float size, global::Cored.ImVec2.__Internal pos, uint col, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RenderText(__IntPtr __instance, __IntPtr draw_list, float size, global::Cored.ImVec2.__Internal pos, uint col, __IntPtr clip_rect, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, bool cpu_fine_clip);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BuildLookupTable@ImFont@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void BuildLookupTable(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ClearOutputData@ImFont@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClearOutputData(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GrowIndex@ImFont@@QEAAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GrowIndex(__IntPtr __instance, int new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddGlyph(__IntPtr __instance, __IntPtr src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AddRemapChar@ImFont@@QEAAXGG_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void AddRemapChar(__IntPtr __instance, ushort dst, ushort src, bool overwrite_dst);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetGlyphVisible@ImFont@@QEAAXG_N@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetGlyphVisible(__IntPtr __instance, ushort c, bool visible);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetFallbackChar@ImFont@@QEAAXG@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetFallbackChar(__IntPtr __instance, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsGlyphRangeUnused@ImFont@@QEAA_NII@Z", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsGlyphRangeUnused(__IntPtr __instance, uint c_begin, uint c_last);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsLoaded@ImFont@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsLoaded(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetDebugName@ImFont@@QEBAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetDebugName(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFont> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImFont>();

        protected bool __ownsNativeInstance;

        internal static ImFont __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFont(native.ToPointer(), skipVTables);
        }

        internal static ImFont __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImFont)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImFont __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFont(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImFont.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImFont(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImFont(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFont()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImFont(global::Cored.ImFont _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImFont.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImFontGlyph FindGlyph(ushort c)
        {
            var __ret = __Internal.FindGlyph(__Instance, c);
            var __result0 = global::Cored.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public global::Cored.ImFontGlyph FindGlyphNoFallback(ushort c)
        {
            var __ret = __Internal.FindGlyphNoFallback(__Instance, c);
            var __result0 = global::Cored.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public float GetCharAdvance(ushort c)
        {
            var __ret = __Internal.GetCharAdvance(__Instance, c);
            return __ret;
        }

        public global::Cored.ImVec2 CalcTextSizeA(float size, float max_width, float wrap_width, string text_begin, string text_end, sbyte** remaining)
        {
            var __ret = new global::Cored.ImVec2.__Internal();
            __Internal.CalcTextSizeA(__Instance, new IntPtr(&__ret), size, max_width, wrap_width, text_begin, text_end, remaining);
            return global::Cored.ImVec2.__CreateInstance(__ret);
        }

        public string CalcWordWrapPositionA(float scale, string text, string text_end, float wrap_width)
        {
            var __ret = __Internal.CalcWordWrapPositionA(__Instance, scale, text, text_end, wrap_width);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public void RenderChar(global::Cored.ImDrawList draw_list, float size, global::Cored.ImVec2 pos, uint col, ushort c)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg2 = pos.__Instance;
            __Internal.RenderChar(__Instance, __arg0, size, *(global::Cored.ImVec2.__Internal*) __arg2, col, c);
        }

        public void RenderText(global::Cored.ImDrawList draw_list, float size, global::Cored.ImVec2 pos, uint col, global::Cored.ImVec4 clip_rect, string text_begin, string text_end, float wrap_width, bool cpu_fine_clip)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg2 = pos.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is a C++ reference (&).");
            var __arg4 = clip_rect.__Instance;
            __Internal.RenderText(__Instance, __arg0, size, *(global::Cored.ImVec2.__Internal*) __arg2, col, __arg4, text_begin, text_end, wrap_width, cpu_fine_clip);
        }

        public void BuildLookupTable()
        {
            __Internal.BuildLookupTable(__Instance);
        }

        public void ClearOutputData()
        {
            __Internal.ClearOutputData(__Instance);
        }

        public void GrowIndex(int new_size)
        {
            __Internal.GrowIndex(__Instance, new_size);
        }

        public void AddGlyph(global::Cored.ImFontConfig src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            var __arg0 = src_cfg is null ? __IntPtr.Zero : src_cfg.__Instance;
            __Internal.AddGlyph(__Instance, __arg0, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
        }

        public void AddRemapChar(ushort dst, ushort src, bool overwrite_dst)
        {
            __Internal.AddRemapChar(__Instance, dst, src, overwrite_dst);
        }

        public void SetGlyphVisible(ushort c, bool visible)
        {
            __Internal.SetGlyphVisible(__Instance, c, visible);
        }

        public void SetFallbackChar(ushort c)
        {
            __Internal.SetFallbackChar(__Instance, c);
        }

        public bool IsGlyphRangeUnused(uint c_begin, uint c_last)
        {
            var __ret = __Internal.IsGlyphRangeUnused(__Instance, c_begin, c_last);
            return __ret;
        }

        public float FallbackAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackAdvanceX = value;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public global::Cored.ImFontGlyph FallbackGlyph
        {
            get
            {
                var __result0 = global::Cored.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->FallbackGlyph, false);
                return __result0;
            }
        }

        public global::Cored.ImFontAtlas ContainerAtlas
        {
            get
            {
                var __result0 = global::Cored.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->ContainerAtlas, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ContainerAtlas = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Cored.ImFontConfig ConfigData
        {
            get
            {
                var __result0 = global::Cored.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->ConfigData, false);
                return __result0;
            }
        }

        public short ConfigDataCount
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDataCount;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDataCount = value;
            }
        }

        public ushort FallbackChar
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackChar;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackChar = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public bool DirtyLookupTables
        {
            get
            {
                return ((__Internal*)__Instance)->DirtyLookupTables != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DirtyLookupTables = (byte) (value ? 1 : 0);
            }
        }

        public float Scale
        {
            get
            {
                return ((__Internal*)__Instance)->Scale;
            }

            set
            {
                ((__Internal*)__Instance)->Scale = value;
            }
        }

        public float Ascent
        {
            get
            {
                return ((__Internal*)__Instance)->Ascent;
            }

            set
            {
                ((__Internal*)__Instance)->Ascent = value;
            }
        }

        public float Descent
        {
            get
            {
                return ((__Internal*)__Instance)->Descent;
            }

            set
            {
                ((__Internal*)__Instance)->Descent = value;
            }
        }

        public int MetricsTotalSurface
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsTotalSurface;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsTotalSurface = value;
            }
        }

        public byte[] Used4kPagesMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Used4kPagesMap, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->Used4kPagesMap[i] = value[i];
                }
            }
        }

        public bool IsLoaded
        {
            get
            {
                var __ret = __Internal.IsLoaded(__Instance);
                return __ret;
            }
        }

        public string DebugName
        {
            get
            {
                var __ret = __Internal.GetDebugName(__Instance);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }
    }

    public unsafe partial class ImGuiViewport : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            internal uint ID;
            internal int Flags;
            internal global::Cored.ImVec2.__Internal Pos;
            internal global::Cored.ImVec2.__Internal Size;
            internal global::Cored.ImVec2.__Internal WorkPos;
            internal global::Cored.ImVec2.__Internal WorkSize;
            internal float DpiScale;
            internal uint ParentViewportId;
            internal __IntPtr DrawData;
            internal __IntPtr RendererUserData;
            internal __IntPtr PlatformUserData;
            internal __IntPtr PlatformHandle;
            internal __IntPtr PlatformHandleRaw;
            internal byte PlatformRequestMove;
            internal byte PlatformRequestResize;
            internal byte PlatformRequestClose;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiViewport@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiViewport@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiViewport@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCenter@ImGuiViewport@@QEBA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCenter(__IntPtr __instance, __IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWorkCenter@ImGuiViewport@@QEBA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetWorkCenter(__IntPtr __instance, __IntPtr @return);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiViewport> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiViewport>();

        protected bool __ownsNativeInstance;

        internal static ImGuiViewport __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewport(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewport __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiViewport)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiViewport __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewport(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewport(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiViewport(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewport()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiViewport(global::Cored.ImGuiViewport _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiViewport.__Internal*) __Instance) = *((global::Cored.ImGuiViewport.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::Cored.ImVec2 Pos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 Size
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 WorkPos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 WorkSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->DpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->DpiScale = value;
            }
        }

        public uint ParentViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ParentViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ParentViewportId = value;
            }
        }

        public global::Cored.ImDrawData DrawData
        {
            get
            {
                var __result0 = global::Cored.ImDrawData.__GetOrCreateInstance(((__Internal*)__Instance)->DrawData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr RendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->RendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->RendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformHandle
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformHandle;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformHandle = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformHandleRaw
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformHandleRaw;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformHandleRaw = (__IntPtr) value;
            }
        }

        public bool PlatformRequestMove
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestMove != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestMove = (byte) (value ? 1 : 0);
            }
        }

        public bool PlatformRequestResize
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestResize != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestResize = (byte) (value ? 1 : 0);
            }
        }

        public bool PlatformRequestClose
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestClose = (byte) (value ? 1 : 0);
            }
        }

        public global::Cored.ImVec2 Center
        {
            get
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetCenter(__Instance, new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }
        }

        public global::Cored.ImVec2 WorkCenter
        {
            get
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetWorkCenter(__Instance, new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }
        }
    }

    public unsafe partial class ImGuiPlatformIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 224)]
        public partial struct __Internal
        {
            internal __IntPtr Platform_CreateWindow;
            internal __IntPtr Platform_DestroyWindow;
            internal __IntPtr Platform_ShowWindow;
            internal __IntPtr Platform_SetWindowPos;
            internal __IntPtr Platform_GetWindowPos;
            internal __IntPtr Platform_SetWindowSize;
            internal __IntPtr Platform_GetWindowSize;
            internal __IntPtr Platform_SetWindowFocus;
            internal __IntPtr Platform_GetWindowFocus;
            internal __IntPtr Platform_GetWindowMinimized;
            internal __IntPtr Platform_SetWindowTitle;
            internal __IntPtr Platform_SetWindowAlpha;
            internal __IntPtr Platform_UpdateWindow;
            internal __IntPtr Platform_RenderWindow;
            internal __IntPtr Platform_SwapBuffers;
            internal __IntPtr Platform_GetWindowDpiScale;
            internal __IntPtr Platform_OnChangedViewport;
            internal __IntPtr Platform_SetImeInputPos;
            internal __IntPtr Platform_CreateVkSurface;
            internal __IntPtr Renderer_CreateWindow;
            internal __IntPtr Renderer_DestroyWindow;
            internal __IntPtr Renderer_SetWindowSize;
            internal __IntPtr Renderer_RenderWindow;
            internal __IntPtr Renderer_SwapBuffers;
            internal global::Cored.ImVector.__Internal Monitors;
            internal global::Cored.ImVector.__Internal Viewports;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPlatformIO@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPlatformIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??1ImGuiPlatformIO@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPlatformIO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPlatformIO>();

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiPlatformIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiPlatformIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Cored.ImGuiPlatformIO.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private ImGuiPlatformIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPlatformIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPlatformIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiPlatformIO(global::Cored.ImGuiPlatformIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPlatformIO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.Delegates.Action___IntPtr PlatformCreateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_CreateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_CreateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr PlatformDestroyWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_DestroyWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_DestroyWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr PlatformShowWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_ShowWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_ShowWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal PlatformSetWindowPos
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowPos;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowPos = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr PlatformGetWindowPos
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowPos;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowPos = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal PlatformSetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr PlatformGetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_Cored_ImVec2___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr PlatformSetWindowFocus
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowFocus;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_bool___IntPtr PlatformGetWindowFocus
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowFocus;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_bool___IntPtr PlatformGetWindowMinimized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowMinimized;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowMinimized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string PlatformSetWindowTitle
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowTitle;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowTitle = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr_float PlatformSetWindowAlpha
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowAlpha;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr_float) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr_float));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowAlpha = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr PlatformUpdateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_UpdateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_UpdateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr___IntPtr PlatformRenderWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_RenderWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_RenderWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr___IntPtr PlatformSwapBuffers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SwapBuffers;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SwapBuffers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_float___IntPtr PlatformGetWindowDpiScale
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowDpiScale;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_float___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_float___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowDpiScale = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr PlatformOnChangedViewport
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_OnChangedViewport;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_OnChangedViewport = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal PlatformSetImeInputPos
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetImeInputPos;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetImeInputPos = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr PlatformCreateVkSurface
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_CreateVkSurface;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_CreateVkSurface = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr RendererCreateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_CreateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_CreateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr RendererDestroyWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_DestroyWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_DestroyWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal RendererSetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_SetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr_Cored_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_SetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr___IntPtr RendererRenderWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_RenderWindow;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_RenderWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::Cored.Delegates.Action___IntPtr___IntPtr RendererSwapBuffers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_SwapBuffers;
                return __ptr0 == IntPtr.Zero? null : (global::Cored.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Cored.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_SwapBuffers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ImGuiPlatformMonitor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            internal global::Cored.ImVec2.__Internal MainPos;
            internal global::Cored.ImVec2.__Internal MainSize;
            internal global::Cored.ImVec2.__Internal WorkPos;
            internal global::Cored.ImVec2.__Internal WorkSize;
            internal float DpiScale;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPlatformMonitor@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0ImGuiPlatformMonitor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPlatformMonitor> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.ImGuiPlatformMonitor>();

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformMonitor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformMonitor(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformMonitor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (ImGuiPlatformMonitor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static ImGuiPlatformMonitor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformMonitor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPlatformMonitor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected ImGuiPlatformMonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformMonitor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public ImGuiPlatformMonitor(global::Cored.ImGuiPlatformMonitor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.ImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.ImGuiPlatformMonitor.__Internal*) __Instance) = *((global::Cored.ImGuiPlatformMonitor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.ImVec2 MainPos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MainPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MainPos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 MainSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MainSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MainSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 WorkPos
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::Cored.ImVec2 WorkSize
        {
            get
            {
                return global::Cored.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::Cored.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->DpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->DpiScale = value;
            }
        }
    }

    namespace ImGui
    {
        public unsafe partial class imgui
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr CreateContext(__IntPtr shared_font_atlas);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DestroyContext(__IntPtr ctx);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCurrentContext();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCurrentContext(__IntPtr ctx);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetIO@ImGui@@YAAEAUImGuiIO@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetIO();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStyle();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?NewFrame@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewFrame();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndFrame@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndFrame();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Render@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Render();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDrawData();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowDemoWindow@ImGui@@YAXPEA_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowDemoWindow(bool* p_open);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowMetricsWindow@ImGui@@YAXPEA_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowMetricsWindow(bool* p_open);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowAboutWindow@ImGui@@YAXPEA_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowAboutWindow(bool* p_open);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowStyleEditor@ImGui@@YAXPEAUImGuiStyle@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowStyleEditor(__IntPtr @ref);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowStyleSelector@ImGui@@YA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowFontSelector@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowFontSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ShowUserGuide@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ShowUserGuide();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetVersion@ImGui@@YAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetVersion();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void StyleColorsDark(__IntPtr dst);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void StyleColorsLight(__IntPtr dst);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void StyleColorsClassic(__IntPtr dst);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Begin@ImGui@@YA_NPEBDPEA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Begin([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?End@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginChild([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, __IntPtr size, bool border, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginChild_1(uint id, __IntPtr size, bool border, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndChild@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndChild();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsWindowAppearing@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWindowAppearing();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsWindowCollapsed@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWindowCollapsed();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsWindowFocused@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWindowFocused(int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsWindowHovered@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWindowHovered(int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetWindowDrawList();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowDpiScale@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWindowDpiScale();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowPos@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetWindowPos(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowSize@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetWindowSize(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowWidth@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWindowWidth();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowHeight@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWindowHeight();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowViewport@ImGui@@YAPEAUImGuiViewport@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetWindowViewport();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowPos(__IntPtr pos, int cond, __IntPtr pivot);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowSize(__IntPtr size, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowSizeConstraints(__IntPtr size_min, __IntPtr size_max, __IntPtr custom_callback, __IntPtr custom_callback_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowContentSize(__IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowCollapsed@ImGui@@YAX_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowCollapsed(bool collapsed, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowFocus@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowFocus();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowBgAlpha@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowBgAlpha(float alpha);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowViewport@ImGui@@YAXI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowViewport(uint viewport_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowPos(__IntPtr pos, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowSize(__IntPtr size, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowCollapsed@ImGui@@YAX_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowCollapsed(bool collapsed, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowFocus@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowFocus();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowFontScale@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowFontScale(float scale);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowPos([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr pos, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowSize([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr size, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowCollapsed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool collapsed, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetWindowFocus@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetWindowFocus([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetContentRegionAvail(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetContentRegionMax(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetWindowContentRegionMin(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetWindowContentRegionMax(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowContentRegionWidth@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetWindowContentRegionWidth();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetScrollX@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScrollX();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetScrollY@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScrollY();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollX@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollX(float scroll_x);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollY@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollY(float scroll_y);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetScrollMaxX@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScrollMaxX();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetScrollMaxY@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetScrollMaxY();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollHereX@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollHereX(float center_x_ratio);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollHereY@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollHereY(float center_y_ratio);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollFromPosX@ImGui@@YAXMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollFromPosX(float local_x, float center_x_ratio);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetScrollFromPosY@ImGui@@YAXMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScrollFromPosY(float local_y, float center_y_ratio);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushFont@ImGui@@YAXPEAUImFont@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushFont(__IntPtr font);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopFont@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopFont();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushStyleColor@ImGui@@YAXHI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushStyleColor(int idx, uint col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushStyleColor(int idx, __IntPtr col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopStyleColor@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopStyleColor(int count);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushStyleVar@ImGui@@YAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushStyleVar(int idx, float val);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushStyleVar(int idx, __IntPtr val);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopStyleVar@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopStyleVar(int count);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushAllowKeyboardFocus@ImGui@@YAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushAllowKeyboardFocus(bool allow_keyboard_focus);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopAllowKeyboardFocus@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopAllowKeyboardFocus();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushButtonRepeat@ImGui@@YAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushButtonRepeat(bool repeat);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopButtonRepeat@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopButtonRepeat();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushItemWidth@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushItemWidth(float item_width);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopItemWidth@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopItemWidth();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextItemWidth@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextItemWidth(float item_width);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcItemWidth@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float CalcItemWidth();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushTextWrapPos@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushTextWrapPos(float wrap_local_pos_x);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopTextWrapPos@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopTextWrapPos();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFont@ImGui@@YAPEAUImFont@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetFont();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFontSize@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFontSize();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetFontTexUvWhitePixel(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColorU32@ImGui@@YAIHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetColorU32(int idx, float alpha_mul);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetColorU32(__IntPtr col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColorU32@ImGui@@YAII@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetColorU32(uint col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStyleColorVec4(int idx);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Separator@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Separator();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SameLine@ImGui@@YAXMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SameLine(float offset_from_start_x, float spacing);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?NewLine@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NewLine();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Spacing@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Spacing();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Dummy@ImGui@@YAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dummy(__IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Indent@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Indent(float indent_w);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Unindent@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Unindent(float indent_w);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginGroup@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BeginGroup();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndGroup@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndGroup();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCursorPos@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetCursorPos(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCursorPosX@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCursorPosX();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCursorPosY@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetCursorPosY();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCursorPos(__IntPtr local_pos);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCursorPosX@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCursorPosX(float local_x);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCursorPosY@ImGui@@YAXM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCursorPosY(float local_y);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetCursorStartPos(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetCursorScreenPos(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCursorScreenPos(__IntPtr pos);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AlignTextToFramePadding@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AlignTextToFramePadding();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTextLineHeight@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTextLineHeight();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTextLineHeightWithSpacing@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTextLineHeightWithSpacing();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFrameHeight@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFrameHeight();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFrameHeightWithSpacing@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetFrameHeightWithSpacing();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushID@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushID@ImGui@@YAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushID@ImGui@@YAXPEBX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushID(__IntPtr ptr_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushID@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushID_1(int int_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopID@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopID();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetID@ImGui@@YAIPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetID@ImGui@@YAIPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetID@ImGui@@YAIPEBX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetID(__IntPtr ptr_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TextUnformatted@ImGui@@YAXPEBD0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TextUnformatted([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Text@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Text([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TextColored(__IntPtr col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TextDisabled@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TextDisabled([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TextWrapped@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TextWrapped([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LabelText@ImGui@@YAXPEBD0ZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LabelText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BulletText@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BulletText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Button([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SmallButton@ImGui@@YA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SmallButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InvisibleButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, __IntPtr size, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ArrowButton@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ArrowButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Image(__IntPtr user_texture_id, __IntPtr size, __IntPtr uv0, __IntPtr uv1, __IntPtr tint_col, __IntPtr border_col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ImageButton(__IntPtr user_texture_id, __IntPtr size, __IntPtr uv0, __IntPtr uv1, int frame_padding, __IntPtr bg_col, __IntPtr tint_col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Checkbox@ImGui@@YA_NPEBDPEA_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Checkbox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* v);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CheckboxFlags([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* flags, int flags_value);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CheckboxFlags_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint* flags, uint flags_value);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?RadioButton@ImGui@@YA_NPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool RadioButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool active);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?RadioButton@ImGui@@YA_NPEBDPEAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool RadioButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ProgressBar(float fraction, __IntPtr size_arg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Bullet@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Bullet();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginCombo@ImGui@@YA_NPEBD0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginCombo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string preview_value, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndCombo@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndCombo();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Combo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int popup_max_height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Combo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string items_separated_by_zeros, int popup_max_height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Combo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloatRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragInt2@ImGui@@YA_NPEBDQEAHMHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragInt3@ImGui@@YA_NPEBDQEAHMHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragInt4@ImGui@@YA_NPEBDQEAHMHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragIntRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderAngle@ImGui@@YA_NPEBDPEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderAngle([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_rad, float v_degrees_min, float v_degrees_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderInt@ImGui@@YA_NPEBDPEAHHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderInt2@ImGui@@YA_NPEBDQEAHHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderInt3@ImGui@@YA_NPEBDQEAHHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderInt4@ImGui@@YA_NPEBDQEAHHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool VSliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool VSliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool VSliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, ulong buf_size, int flags, __IntPtr callback, __IntPtr user_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputTextMultiline([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, ulong buf_size, __IntPtr size, int flags, __IntPtr callback, __IntPtr user_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputTextWithHint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, ulong buf_size, int flags, __IntPtr callback, __IntPtr user_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float step, float step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int step, int step_fast, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputInt2@ImGui@@YA_NPEBDQEAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputInt3@ImGui@@YA_NPEBDQEAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputInt4@ImGui@@YA_NPEBDQEAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputDouble([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double* v, double step, double step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool InputScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ColorEdit3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ColorEdit4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ColorPicker3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ColorPicker4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags, float* ref_col);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ColorButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string desc_id, __IntPtr col, int flags, global::Cored.ImVec2.__Internal size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetColorEditOptions@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColorEditOptions(int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNode@ImGui@@YA_NPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNode([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNode@ImGui@@YA_NPEBD0ZZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNode([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNode@ImGui@@YA_NPEBXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNode(__IntPtr ptr_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNodeEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNodeEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TreeNodeEx(__IntPtr ptr_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreePush@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TreePush([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreePush@ImGui@@YAXPEBX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TreePush(__IntPtr ptr_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreePop@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TreePop();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetTreeNodeToLabelSpacing();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CollapsingHeader@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CollapsingHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool CollapsingHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_visible, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextItemOpen@ImGui@@YAX_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextItemOpen(bool is_open, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Selectable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool selected, int flags, __IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Selectable_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_selected, int flags, __IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndListBox@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndListBox();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PlotLines([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2.__Internal graph_size, int stride);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PlotLines([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2.__Internal graph_size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PlotHistogram([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2.__Internal graph_size, int stride);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PlotHistogram([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2.__Internal graph_size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Value@ImGui@@YAXPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Value([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, bool b);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Value@ImGui@@YAXPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Value_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, int v);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Value@ImGui@@YAXPEBDI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Value_2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, uint v);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Value@ImGui@@YAXPEBDM0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Value([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, float v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string float_format);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginMenuBar@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginMenuBar();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndMenuBar@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndMenuBar();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginMainMenuBar@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginMainMenuBar();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndMainMenuBar@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndMainMenuBar();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginMenu@ImGui@@YA_NPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginMenu([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool enabled);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndMenu@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndMenu();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?MenuItem@ImGui@@YA_NPEBD0_N1@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool MenuItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool MenuItem_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool* p_selected, bool enabled);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginTooltip@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void BeginTooltip();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndTooltip@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndTooltip();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetTooltip@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopup@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopupModal([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndPopup@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndPopup();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?OpenPopup@ImGui@@YAXPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OpenPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?OpenPopup@ImGui@@YAXIH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OpenPopup_1(uint id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?OpenPopupOnItemClick@ImGui@@YAXPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OpenPopupOnItemClick([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CloseCurrentPopup@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CloseCurrentPopup();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopupContextItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopupContextWindow@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopupContextVoid([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsPopupOpen@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsPopupOpen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginTable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int column, int flags, __IntPtr outer_size, float inner_width);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndTable@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndTable();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableNextRow@ImGui@@YAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableNextRow(int row_flags, float min_row_height);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableNextColumn@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TableNextColumn();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableSetColumnIndex@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TableSetColumnIndex(int column_n);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableSetupColumn@ImGui@@YAXPEBDHMI@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableSetupColumn([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags, float init_width_or_weight, uint user_id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableSetupScrollFreeze@ImGui@@YAXHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableSetupScrollFreeze(int cols, int rows);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableHeadersRow@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableHeadersRow();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableHeader@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr TableGetSortSpecs();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetColumnCount@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int TableGetColumnCount();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetColumnIndex@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int TableGetColumnIndex();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetRowIndex@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int TableGetRowIndex();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetColumnName@ImGui@@YAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr TableGetColumnName(int column_n);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableGetColumnFlags@ImGui@@YAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int TableGetColumnFlags(int column_n);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableSetColumnEnabled@ImGui@@YAXH_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableSetColumnEnabled(int column_n, bool v);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TableSetBgColor@ImGui@@YAXHIH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TableSetBgColor(int target, uint color, int column_n);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?Columns@ImGui@@YAXHPEBD_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Columns(int count, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, bool border);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?NextColumn@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void NextColumn();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColumnIndex@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetColumnIndex();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColumnWidth@ImGui@@YAMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetColumnWidth(int column_index);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetColumnWidth@ImGui@@YAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColumnWidth(int column_index, float width);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColumnOffset@ImGui@@YAMH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetColumnOffset(int column_index);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetColumnOffset@ImGui@@YAXHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetColumnOffset(int column_index, float offset_x);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetColumnsCount@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetColumnsCount();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginTabBar@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginTabBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndTabBar@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndTabBar();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginTabItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndTabItem@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndTabItem();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TabItemButton@ImGui@@YA_NPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool TabItemButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetTabItemClosed@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTabItemClosed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string tab_or_docked_window_label);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DockSpace@ImGui@@YAIIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint DockSpace(uint id, __IntPtr size, int flags, __IntPtr window_class);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DockSpaceOverViewport@ImGui@@YAIPEBUImGuiViewport@@HPEBUImGuiWindowClass@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint DockSpaceOverViewport(__IntPtr viewport, int flags, __IntPtr window_class);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowDockID@ImGui@@YAXIH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowDockID(uint dock_id, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextWindowClass@ImGui@@YAXPEBUImGuiWindowClass@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextWindowClass(__IntPtr window_class);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetWindowDockID@ImGui@@YAIXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetWindowDockID();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsWindowDocked@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsWindowDocked();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogToTTY@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogToTTY(int auto_open_depth);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogToFile@ImGui@@YAXHPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogToFile(int auto_open_depth, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogToClipboard@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogToClipboard(int auto_open_depth);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogFinish@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogFinish();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogButtons@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogButtons();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LogText@ImGui@@YAXPEBDZZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LogText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginDragDropSource@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginDragDropSource(int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SetDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, __IntPtr data, ulong sz, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndDragDropSource@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndDragDropSource();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginDragDropTarget@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginDragDropTarget();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr AcceptDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndDragDropTarget@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndDragDropTarget();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDragDropPayload();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PushClipRect(__IntPtr clip_rect_min, __IntPtr clip_rect_max, bool intersect_with_current_clip_rect);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?PopClipRect@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void PopClipRect();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetItemDefaultFocus@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetItemDefaultFocus();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetKeyboardFocusHere@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetKeyboardFocusHere(int offset);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemHovered@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemHovered(int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemActive@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemActive();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemFocused@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemFocused();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemClicked@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemClicked(int mouse_button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemVisible@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemVisible();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemEdited@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemEdited();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemActivated@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemActivated();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemDeactivated@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemDeactivated();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemDeactivatedAfterEdit();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsItemToggledOpen@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsItemToggledOpen();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsAnyItemHovered@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAnyItemHovered();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsAnyItemActive@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAnyItemActive();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsAnyItemFocused@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAnyItemFocused();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetItemRectMin(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetItemRectMax(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetItemRectSize(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetItemAllowOverlap@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetItemAllowOverlap();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetMainViewport();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRectVisible(__IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsRectVisible(__IntPtr rect_min, __IntPtr rect_max);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetTime@ImGui@@YANXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern double GetTime();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetFrameCount@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetFrameCount();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBackgroundDrawList();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetForegroundDrawList();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetBackgroundDrawList(__IntPtr viewport);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetForegroundDrawList(__IntPtr viewport);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDrawListSharedData();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetStyleColorName@ImGui@@YAPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStyleColorName(int idx);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStateStorage(__IntPtr storage);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStateStorage();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcListClipping@ImGui@@YAXHMPEAH0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginChildFrame(uint id, __IntPtr size, int flags);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?EndChildFrame@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void EndChildFrame();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CalcTextSize(__IntPtr @return, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_double_hash, float wrap_width);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ColorConvertU32ToFloat4(__IntPtr @return, uint @in);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint ColorConvertFloat4ToU32(__IntPtr @in);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* out_h, float* out_s, float* out_v);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* out_r, float* out_g, float* out_b);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetKeyIndex@ImGui@@YAHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetKeyIndex(int imgui_key);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsKeyDown@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsKeyDown(int user_key_index);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsKeyPressed@ImGui@@YA_NH_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsKeyPressed(int user_key_index, bool repeat);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsKeyReleased@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsKeyReleased(int user_key_index);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetKeyPressedAmount@ImGui@@YAHHMM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetKeyPressedAmount(int key_index, float repeat_delay, float rate);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CaptureKeyboardFromApp@ImGui@@YAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CaptureKeyboardFromApp(bool want_capture_keyboard_value);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseDown@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseDown(int button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseClicked@ImGui@@YA_NH_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseClicked(int button, bool repeat);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseReleased@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseReleased(int button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseDoubleClicked@ImGui@@YA_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseDoubleClicked(int button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseHoveringRect(__IntPtr r_min, __IntPtr r_max, bool clip);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMousePosValid(__IntPtr mouse_pos);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsAnyMouseDown@ImGui@@YA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsAnyMouseDown();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMousePos@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetMousePos(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetMousePosOnOpeningCurrentPopup(__IntPtr @return);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?IsMouseDragging@ImGui@@YA_NHM@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsMouseDragging(int button, float lock_threshold);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetMouseDragDelta(__IntPtr @return, int button, float lock_threshold);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ResetMouseDragDelta@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetMouseDragDelta(int button);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetMouseCursor@ImGui@@YAHXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern int GetMouseCursor();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetMouseCursor@ImGui@@YAXH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMouseCursor(int cursor_type);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?CaptureMouseFromApp@ImGui@@YAX_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CaptureMouseFromApp(bool want_capture_mouse_value);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetClipboardText@ImGui@@YAPEBDXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetClipboardText();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetClipboardText@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetClipboardText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LoadIniSettingsFromDisk@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LoadIniSettingsFromDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?LoadIniSettingsFromMemory@ImGui@@YAXPEBD_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void LoadIniSettingsFromMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_data, ulong ini_size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SaveIniSettingsToDisk@ImGui@@YAXPEBD@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SaveIniSettingsToDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SaveIniSettingsToMemory@ImGui@@YAPEBDPEA_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr SaveIniSettingsToMemory(ulong* out_ini_size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DebugCheckVersionAndDataLayout([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string version_str, ulong sz_io, ulong sz_style, ulong sz_vec2, ulong sz_vec4, ulong sz_drawvert, ulong sz_drawidx);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetAllocatorFunctions(__IntPtr alloc_func, __IntPtr free_func, __IntPtr user_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetAllocatorFunctions@ImGui@@YAXPEAP6APEAX_KPEAX@ZPEAP6AX11@ZPEAPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetAllocatorFunctions(__IntPtr p_alloc_func, __IntPtr p_free_func, void** p_user_data);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?MemAlloc@ImGui@@YAPEAX_K@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr MemAlloc(ulong size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?MemFree@ImGui@@YAXPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void MemFree(__IntPtr ptr);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetPlatformIO@ImGui@@YAAEAUImGuiPlatformIO@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetPlatformIO();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?UpdatePlatformWindows@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdatePlatformWindows();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RenderPlatformWindowsDefault(__IntPtr platform_render_arg, __IntPtr renderer_render_arg);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DestroyPlatformWindows@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DestroyPlatformWindows();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?FindViewportByID@ImGui@@YAPEAUImGuiViewport@@I@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindViewportByID(uint id);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?FindViewportByPlatformHandle@ImGui@@YAPEAUImGuiViewport@@PEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr FindViewportByPlatformHandle(__IntPtr platform_handle);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ListBoxHeader@ImGui@@YA_NPEBDHH@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ListBoxHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int items_count, int height_in_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ListBoxHeader@ImGui@@YA_NPEBDAEBUImVec2@@@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool ListBoxHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr size);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?ListBoxFooter@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ListBoxFooter();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?OpenPopupContextItem@ImGui@@YAXPEBDH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void OpenPopupContextItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int mb);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragScalar_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragScalarN_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat@ImGui@@YA_NPEBDPEAMMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat2_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat3_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool DragFloat4_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderScalar_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderScalarN_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat@ImGui@@YA_NPEBDPEAMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat2_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat3_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0M@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool SliderFloat4_1([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, float power);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?BeginPopupContextWindow@ImGui@@YA_NPEBDH_N@Z", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int mb, bool over_items);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?TreeAdvanceToLabelPos@ImGui@@YAXXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TreeAdvanceToLabelPos();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetNextTreeNodeOpen(bool open, int cond);

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetContentRegionAvailWidth@ImGui@@YAMXZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern float GetContentRegionAvailWidth();

                [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "?GetOverlayDrawList@ImGui@@YAPEAUImDrawList@@XZ", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetOverlayDrawList();
            }

            public static global::Cored.ImGuiContext CreateContext(global::Cored.ImFontAtlas shared_font_atlas)
            {
                var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
                var __ret = __Internal.CreateContext(__arg0);
                var __result0 = global::Cored.ImGuiContext.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void DestroyContext(global::Cored.ImGuiContext ctx)
            {
                var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
                __Internal.DestroyContext(__arg0);
            }

            public static global::Cored.ImGuiContext GetCurrentContext()
            {
                var __ret = __Internal.GetCurrentContext();
                var __result0 = global::Cored.ImGuiContext.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void SetCurrentContext(global::Cored.ImGuiContext ctx)
            {
                var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
                __Internal.SetCurrentContext(__arg0);
            }

            public static global::Cored.ImGuiIO GetIO()
            {
                var __ret = __Internal.GetIO();
                var __result0 = global::Cored.ImGuiIO.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImGuiStyle GetStyle()
            {
                var __ret = __Internal.GetStyle();
                var __result0 = global::Cored.ImGuiStyle.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void NewFrame()
            {
                __Internal.NewFrame();
            }

            public static void EndFrame()
            {
                __Internal.EndFrame();
            }

            public static void Render()
            {
                __Internal.Render();
            }

            public static global::Cored.ImDrawData GetDrawData()
            {
                var __ret = __Internal.GetDrawData();
                var __result0 = global::Cored.ImDrawData.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void ShowDemoWindow(ref bool p_open)
            {
                fixed (bool* __p_open0 = &p_open)
                {
                    var __arg0 = __p_open0;
                    __Internal.ShowDemoWindow(__arg0);
                }
            }

            public static void ShowMetricsWindow(ref bool p_open)
            {
                fixed (bool* __p_open0 = &p_open)
                {
                    var __arg0 = __p_open0;
                    __Internal.ShowMetricsWindow(__arg0);
                }
            }

            public static void ShowAboutWindow(ref bool p_open)
            {
                fixed (bool* __p_open0 = &p_open)
                {
                    var __arg0 = __p_open0;
                    __Internal.ShowAboutWindow(__arg0);
                }
            }

            public static void ShowStyleEditor(global::Cored.ImGuiStyle @ref)
            {
                var __arg0 = @ref is null ? __IntPtr.Zero : @ref.__Instance;
                __Internal.ShowStyleEditor(__arg0);
            }

            public static bool ShowStyleSelector(string label)
            {
                var __ret = __Internal.ShowStyleSelector(label);
                return __ret;
            }

            public static void ShowFontSelector(string label)
            {
                __Internal.ShowFontSelector(label);
            }

            public static void ShowUserGuide()
            {
                __Internal.ShowUserGuide();
            }

            public static string GetVersion()
            {
                var __ret = __Internal.GetVersion();
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }

            public static void StyleColorsDark(global::Cored.ImGuiStyle dst)
            {
                var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
                __Internal.StyleColorsDark(__arg0);
            }

            public static void StyleColorsLight(global::Cored.ImGuiStyle dst)
            {
                var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
                __Internal.StyleColorsLight(__arg0);
            }

            public static void StyleColorsClassic(global::Cored.ImGuiStyle dst)
            {
                var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
                __Internal.StyleColorsClassic(__arg0);
            }

            public static bool Begin(string name, ref bool p_open, int flags)
            {
                fixed (bool* __p_open1 = &p_open)
                {
                    var __arg1 = __p_open1;
                    var __ret = __Internal.Begin(name, __arg1, flags);
                    return __ret;
                }
            }

            public static void End()
            {
                __Internal.End();
            }

            public static bool BeginChild(string str_id, global::Cored.ImVec2 size, bool border, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.BeginChild(str_id, __arg1, border, flags);
                return __ret;
            }

            public static bool BeginChild(uint id, global::Cored.ImVec2 size, bool border, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.BeginChild_1(id, __arg1, border, flags);
                return __ret;
            }

            public static void EndChild()
            {
                __Internal.EndChild();
            }

            public static bool IsWindowAppearing()
            {
                var __ret = __Internal.IsWindowAppearing();
                return __ret;
            }

            public static bool IsWindowCollapsed()
            {
                var __ret = __Internal.IsWindowCollapsed();
                return __ret;
            }

            public static bool IsWindowFocused(int flags)
            {
                var __ret = __Internal.IsWindowFocused(flags);
                return __ret;
            }

            public static bool IsWindowHovered(int flags)
            {
                var __ret = __Internal.IsWindowHovered(flags);
                return __ret;
            }

            public static global::Cored.ImDrawList GetWindowDrawList()
            {
                var __ret = __Internal.GetWindowDrawList();
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static float GetWindowDpiScale()
            {
                var __ret = __Internal.GetWindowDpiScale();
                return __ret;
            }

            public static global::Cored.ImVec2 GetWindowPos()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetWindowPos(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetWindowSize()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetWindowSize(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static float GetWindowWidth()
            {
                var __ret = __Internal.GetWindowWidth();
                return __ret;
            }

            public static float GetWindowHeight()
            {
                var __ret = __Internal.GetWindowHeight();
                return __ret;
            }

            public static global::Cored.ImGuiViewport GetWindowViewport()
            {
                var __ret = __Internal.GetWindowViewport();
                var __result0 = global::Cored.ImGuiViewport.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void SetNextWindowPos(global::Cored.ImVec2 pos, int cond, global::Cored.ImVec2 pivot)
            {
                if (ReferenceEquals(pos, null))
                    throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = pos.__Instance;
                if (ReferenceEquals(pivot, null))
                    throw new global::System.ArgumentNullException("pivot", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = pivot.__Instance;
                __Internal.SetNextWindowPos(__arg0, cond, __arg2);
            }

            public static void SetNextWindowSize(global::Cored.ImVec2 size, int cond)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size.__Instance;
                __Internal.SetNextWindowSize(__arg0, cond);
            }

            public static void SetNextWindowSizeConstraints(global::Cored.ImVec2 size_min, global::Cored.ImVec2 size_max, global::Cored.ImGuiSizeCallback custom_callback, __IntPtr custom_callback_data)
            {
                if (ReferenceEquals(size_min, null))
                    throw new global::System.ArgumentNullException("size_min", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size_min.__Instance;
                if (ReferenceEquals(size_max, null))
                    throw new global::System.ArgumentNullException("size_max", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size_max.__Instance;
                var __arg2 = custom_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(custom_callback);
                __Internal.SetNextWindowSizeConstraints(__arg0, __arg1, __arg2, custom_callback_data);
            }

            public static void SetNextWindowContentSize(global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size.__Instance;
                __Internal.SetNextWindowContentSize(__arg0);
            }

            public static void SetNextWindowCollapsed(bool collapsed, int cond)
            {
                __Internal.SetNextWindowCollapsed(collapsed, cond);
            }

            public static void SetNextWindowFocus()
            {
                __Internal.SetNextWindowFocus();
            }

            public static void SetNextWindowBgAlpha(float alpha)
            {
                __Internal.SetNextWindowBgAlpha(alpha);
            }

            public static void SetNextWindowViewport(uint viewport_id)
            {
                __Internal.SetNextWindowViewport(viewport_id);
            }

            public static void SetWindowPos(global::Cored.ImVec2 pos, int cond)
            {
                if (ReferenceEquals(pos, null))
                    throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = pos.__Instance;
                __Internal.SetWindowPos(__arg0, cond);
            }

            public static void SetWindowSize(global::Cored.ImVec2 size, int cond)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size.__Instance;
                __Internal.SetWindowSize(__arg0, cond);
            }

            public static void SetWindowCollapsed(bool collapsed, int cond)
            {
                __Internal.SetWindowCollapsed(collapsed, cond);
            }

            public static void SetWindowFocus()
            {
                __Internal.SetWindowFocus();
            }

            public static void SetWindowFontScale(float scale)
            {
                __Internal.SetWindowFontScale(scale);
            }

            public static void SetWindowPos(string name, global::Cored.ImVec2 pos, int cond)
            {
                if (ReferenceEquals(pos, null))
                    throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = pos.__Instance;
                __Internal.SetWindowPos(name, __arg1, cond);
            }

            public static void SetWindowSize(string name, global::Cored.ImVec2 size, int cond)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                __Internal.SetWindowSize(name, __arg1, cond);
            }

            public static void SetWindowCollapsed(string name, bool collapsed, int cond)
            {
                __Internal.SetWindowCollapsed(name, collapsed, cond);
            }

            public static void SetWindowFocus(string name)
            {
                __Internal.SetWindowFocus(name);
            }

            public static global::Cored.ImVec2 GetContentRegionAvail()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetContentRegionAvail(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetContentRegionMax()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetContentRegionMax(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetWindowContentRegionMin()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetWindowContentRegionMin(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetWindowContentRegionMax()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetWindowContentRegionMax(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static float GetWindowContentRegionWidth()
            {
                var __ret = __Internal.GetWindowContentRegionWidth();
                return __ret;
            }

            public static float GetScrollX()
            {
                var __ret = __Internal.GetScrollX();
                return __ret;
            }

            public static float GetScrollY()
            {
                var __ret = __Internal.GetScrollY();
                return __ret;
            }

            public static void SetScrollX(float scroll_x)
            {
                __Internal.SetScrollX(scroll_x);
            }

            public static void SetScrollY(float scroll_y)
            {
                __Internal.SetScrollY(scroll_y);
            }

            public static float GetScrollMaxX()
            {
                var __ret = __Internal.GetScrollMaxX();
                return __ret;
            }

            public static float GetScrollMaxY()
            {
                var __ret = __Internal.GetScrollMaxY();
                return __ret;
            }

            public static void SetScrollHereX(float center_x_ratio)
            {
                __Internal.SetScrollHereX(center_x_ratio);
            }

            public static void SetScrollHereY(float center_y_ratio)
            {
                __Internal.SetScrollHereY(center_y_ratio);
            }

            public static void SetScrollFromPosX(float local_x, float center_x_ratio)
            {
                __Internal.SetScrollFromPosX(local_x, center_x_ratio);
            }

            public static void SetScrollFromPosY(float local_y, float center_y_ratio)
            {
                __Internal.SetScrollFromPosY(local_y, center_y_ratio);
            }

            public static void PushFont(global::Cored.ImFont font)
            {
                var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
                __Internal.PushFont(__arg0);
            }

            public static void PopFont()
            {
                __Internal.PopFont();
            }

            public static void PushStyleColor(int idx, uint col)
            {
                __Internal.PushStyleColor(idx, col);
            }

            public static void PushStyleColor(int idx, global::Cored.ImVec4 col)
            {
                if (ReferenceEquals(col, null))
                    throw new global::System.ArgumentNullException("col", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = col.__Instance;
                __Internal.PushStyleColor(idx, __arg1);
            }

            public static void PopStyleColor(int count)
            {
                __Internal.PopStyleColor(count);
            }

            public static void PushStyleVar(int idx, float val)
            {
                __Internal.PushStyleVar(idx, val);
            }

            public static void PushStyleVar(int idx, global::Cored.ImVec2 val)
            {
                if (ReferenceEquals(val, null))
                    throw new global::System.ArgumentNullException("val", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = val.__Instance;
                __Internal.PushStyleVar(idx, __arg1);
            }

            public static void PopStyleVar(int count)
            {
                __Internal.PopStyleVar(count);
            }

            public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
            {
                __Internal.PushAllowKeyboardFocus(allow_keyboard_focus);
            }

            public static void PopAllowKeyboardFocus()
            {
                __Internal.PopAllowKeyboardFocus();
            }

            public static void PushButtonRepeat(bool repeat)
            {
                __Internal.PushButtonRepeat(repeat);
            }

            public static void PopButtonRepeat()
            {
                __Internal.PopButtonRepeat();
            }

            public static void PushItemWidth(float item_width)
            {
                __Internal.PushItemWidth(item_width);
            }

            public static void PopItemWidth()
            {
                __Internal.PopItemWidth();
            }

            public static void SetNextItemWidth(float item_width)
            {
                __Internal.SetNextItemWidth(item_width);
            }

            public static float CalcItemWidth()
            {
                var __ret = __Internal.CalcItemWidth();
                return __ret;
            }

            public static void PushTextWrapPos(float wrap_local_pos_x)
            {
                __Internal.PushTextWrapPos(wrap_local_pos_x);
            }

            public static void PopTextWrapPos()
            {
                __Internal.PopTextWrapPos();
            }

            public static global::Cored.ImFont GetFont()
            {
                var __ret = __Internal.GetFont();
                var __result0 = global::Cored.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static float GetFontSize()
            {
                var __ret = __Internal.GetFontSize();
                return __ret;
            }

            public static global::Cored.ImVec2 GetFontTexUvWhitePixel()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetFontTexUvWhitePixel(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static uint GetColorU32(int idx, float alpha_mul)
            {
                var __ret = __Internal.GetColorU32(idx, alpha_mul);
                return __ret;
            }

            public static uint GetColorU32(global::Cored.ImVec4 col)
            {
                if (ReferenceEquals(col, null))
                    throw new global::System.ArgumentNullException("col", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = col.__Instance;
                var __ret = __Internal.GetColorU32(__arg0);
                return __ret;
            }

            public static uint GetColorU32(uint col)
            {
                var __ret = __Internal.GetColorU32(col);
                return __ret;
            }

            public static global::Cored.ImVec4 GetStyleColorVec4(int idx)
            {
                var __ret = __Internal.GetStyleColorVec4(idx);
                var __result0 = global::Cored.ImVec4.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void Separator()
            {
                __Internal.Separator();
            }

            public static void SameLine(float offset_from_start_x, float spacing)
            {
                __Internal.SameLine(offset_from_start_x, spacing);
            }

            public static void NewLine()
            {
                __Internal.NewLine();
            }

            public static void Spacing()
            {
                __Internal.Spacing();
            }

            public static void Dummy(global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size.__Instance;
                __Internal.Dummy(__arg0);
            }

            public static void Indent(float indent_w)
            {
                __Internal.Indent(indent_w);
            }

            public static void Unindent(float indent_w)
            {
                __Internal.Unindent(indent_w);
            }

            public static void BeginGroup()
            {
                __Internal.BeginGroup();
            }

            public static void EndGroup()
            {
                __Internal.EndGroup();
            }

            public static global::Cored.ImVec2 GetCursorPos()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetCursorPos(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static float GetCursorPosX()
            {
                var __ret = __Internal.GetCursorPosX();
                return __ret;
            }

            public static float GetCursorPosY()
            {
                var __ret = __Internal.GetCursorPosY();
                return __ret;
            }

            public static void SetCursorPos(global::Cored.ImVec2 local_pos)
            {
                if (ReferenceEquals(local_pos, null))
                    throw new global::System.ArgumentNullException("local_pos", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = local_pos.__Instance;
                __Internal.SetCursorPos(__arg0);
            }

            public static void SetCursorPosX(float local_x)
            {
                __Internal.SetCursorPosX(local_x);
            }

            public static void SetCursorPosY(float local_y)
            {
                __Internal.SetCursorPosY(local_y);
            }

            public static global::Cored.ImVec2 GetCursorStartPos()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetCursorStartPos(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetCursorScreenPos()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetCursorScreenPos(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static void SetCursorScreenPos(global::Cored.ImVec2 pos)
            {
                if (ReferenceEquals(pos, null))
                    throw new global::System.ArgumentNullException("pos", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = pos.__Instance;
                __Internal.SetCursorScreenPos(__arg0);
            }

            public static void AlignTextToFramePadding()
            {
                __Internal.AlignTextToFramePadding();
            }

            public static float GetTextLineHeight()
            {
                var __ret = __Internal.GetTextLineHeight();
                return __ret;
            }

            public static float GetTextLineHeightWithSpacing()
            {
                var __ret = __Internal.GetTextLineHeightWithSpacing();
                return __ret;
            }

            public static float GetFrameHeight()
            {
                var __ret = __Internal.GetFrameHeight();
                return __ret;
            }

            public static float GetFrameHeightWithSpacing()
            {
                var __ret = __Internal.GetFrameHeightWithSpacing();
                return __ret;
            }

            public static void PushID(string str_id)
            {
                __Internal.PushID(str_id);
            }

            public static void PushID(string str_id_begin, string str_id_end)
            {
                __Internal.PushID(str_id_begin, str_id_end);
            }

            public static void PushID(__IntPtr ptr_id)
            {
                __Internal.PushID(ptr_id);
            }

            public static void PushID(int int_id)
            {
                __Internal.PushID_1(int_id);
            }

            public static void PopID()
            {
                __Internal.PopID();
            }

            public static uint GetID(string str_id)
            {
                var __ret = __Internal.GetID(str_id);
                return __ret;
            }

            public static uint GetID(string str_id_begin, string str_id_end)
            {
                var __ret = __Internal.GetID(str_id_begin, str_id_end);
                return __ret;
            }

            public static uint GetID(__IntPtr ptr_id)
            {
                var __ret = __Internal.GetID(ptr_id);
                return __ret;
            }

            public static void TextUnformatted(string text, string text_end)
            {
                __Internal.TextUnformatted(text, text_end);
            }

            public static void Text(string fmt)
            {
                __Internal.Text(fmt);
            }

            public static void TextColored(global::Cored.ImVec4 col, string fmt)
            {
                if (ReferenceEquals(col, null))
                    throw new global::System.ArgumentNullException("col", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = col.__Instance;
                __Internal.TextColored(__arg0, fmt);
            }

            public static void TextDisabled(string fmt)
            {
                __Internal.TextDisabled(fmt);
            }

            public static void TextWrapped(string fmt)
            {
                __Internal.TextWrapped(fmt);
            }

            public static void LabelText(string label, string fmt)
            {
                __Internal.LabelText(label, fmt);
            }

            public static void BulletText(string fmt)
            {
                __Internal.BulletText(fmt);
            }

            public static bool Button(string label, global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.Button(label, __arg1);
                return __ret;
            }

            public static bool SmallButton(string label)
            {
                var __ret = __Internal.SmallButton(label);
                return __ret;
            }

            public static bool InvisibleButton(string str_id, global::Cored.ImVec2 size, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.InvisibleButton(str_id, __arg1, flags);
                return __ret;
            }

            public static bool ArrowButton(string str_id, int dir)
            {
                var __ret = __Internal.ArrowButton(str_id, dir);
                return __ret;
            }

            public static void Image(__IntPtr user_texture_id, global::Cored.ImVec2 size, global::Cored.ImVec2 uv0, global::Cored.ImVec2 uv1, global::Cored.ImVec4 tint_col, global::Cored.ImVec4 border_col)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                if (ReferenceEquals(uv0, null))
                    throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = uv0.__Instance;
                if (ReferenceEquals(uv1, null))
                    throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = uv1.__Instance;
                if (ReferenceEquals(tint_col, null))
                    throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is a C++ reference (&).");
                var __arg4 = tint_col.__Instance;
                if (ReferenceEquals(border_col, null))
                    throw new global::System.ArgumentNullException("border_col", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = border_col.__Instance;
                __Internal.Image(user_texture_id, __arg1, __arg2, __arg3, __arg4, __arg5);
            }

            public static bool ImageButton(__IntPtr user_texture_id, global::Cored.ImVec2 size, global::Cored.ImVec2 uv0, global::Cored.ImVec2 uv1, int frame_padding, global::Cored.ImVec4 bg_col, global::Cored.ImVec4 tint_col)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                if (ReferenceEquals(uv0, null))
                    throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = uv0.__Instance;
                if (ReferenceEquals(uv1, null))
                    throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = uv1.__Instance;
                if (ReferenceEquals(bg_col, null))
                    throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is a C++ reference (&).");
                var __arg5 = bg_col.__Instance;
                if (ReferenceEquals(tint_col, null))
                    throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is a C++ reference (&).");
                var __arg6 = tint_col.__Instance;
                var __ret = __Internal.ImageButton(user_texture_id, __arg1, __arg2, __arg3, frame_padding, __arg5, __arg6);
                return __ret;
            }

            public static bool Checkbox(string label, ref bool v)
            {
                fixed (bool* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.Checkbox(label, __arg1);
                    return __ret;
                }
            }

            public static bool CheckboxFlags(string label, ref int flags, int flags_value)
            {
                fixed (int* __flags1 = &flags)
                {
                    var __arg1 = __flags1;
                    var __ret = __Internal.CheckboxFlags(label, __arg1, flags_value);
                    return __ret;
                }
            }

            public static bool CheckboxFlags(string label, ref uint flags, uint flags_value)
            {
                fixed (uint* __flags1 = &flags)
                {
                    var __arg1 = __flags1;
                    var __ret = __Internal.CheckboxFlags_1(label, __arg1, flags_value);
                    return __ret;
                }
            }

            public static bool RadioButton(string label, bool active)
            {
                var __ret = __Internal.RadioButton(label, active);
                return __ret;
            }

            public static bool RadioButton(string label, ref int v, int v_button)
            {
                fixed (int* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.RadioButton(label, __arg1, v_button);
                    return __ret;
                }
            }

            public static void ProgressBar(float fraction, global::Cored.ImVec2 size_arg, string overlay)
            {
                if (ReferenceEquals(size_arg, null))
                    throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size_arg.__Instance;
                __Internal.ProgressBar(fraction, __arg1, overlay);
            }

            public static void Bullet()
            {
                __Internal.Bullet();
            }

            public static bool BeginCombo(string label, string preview_value, int flags)
            {
                var __ret = __Internal.BeginCombo(label, preview_value, flags);
                return __ret;
            }

            public static void EndCombo()
            {
                __Internal.EndCombo();
            }

            public static bool Combo(string label, ref int current_item, string[] items, int items_count, int popup_max_height_in_items)
            {
                fixed (int* __current_item1 = &current_item)
                {
                    var __arg1 = __current_item1;
                    var __ret = __Internal.Combo(label, __arg1, items, items_count, popup_max_height_in_items);
                    return __ret;
                }
            }

            public static bool Combo(string label, ref int current_item, string items_separated_by_zeros, int popup_max_height_in_items)
            {
                fixed (int* __current_item1 = &current_item)
                {
                    var __arg1 = __current_item1;
                    var __ret = __Internal.Combo(label, __arg1, items_separated_by_zeros, popup_max_height_in_items);
                    return __ret;
                }
            }

            public static bool Combo(string label, ref int current_item, global::Cored.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items)
            {
                fixed (int* __current_item1 = &current_item)
                {
                    var __arg1 = __current_item1;
                    var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                    var __ret = __Internal.Combo(label, __arg1, __arg2, data, items_count, popup_max_height_in_items);
                    return __ret;
                }
            }

            public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, int flags)
            {
                fixed (float* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.DragFloat(label, __arg1, v_speed, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat2(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat3(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat4(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragFloatRange2(string label, ref float v_current_min, ref float v_current_max, float v_speed, float v_min, float v_max, string format, string format_max, int flags)
            {
                fixed (float* __v_current_min1 = &v_current_min)
                {
                    var __arg1 = __v_current_min1;
                    fixed (float* __v_current_max2 = &v_current_max)
                    {
                        var __arg2 = __v_current_max2;
                        var __ret = __Internal.DragFloatRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                        return __ret;
                    }
                }
            }

            public static bool DragInt(string label, ref int v, float v_speed, int v_min, int v_max, string format, int flags)
            {
                fixed (int* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.DragInt(label, __arg1, v_speed, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool DragInt2(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragInt2(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragInt3(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragInt3(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragInt4(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragInt4(label, v, v_speed, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool DragIntRange2(string label, ref int v_current_min, ref int v_current_max, float v_speed, int v_min, int v_max, string format, string format_max, int flags)
            {
                fixed (int* __v_current_min1 = &v_current_min)
                {
                    var __arg1 = __v_current_min1;
                    fixed (int* __v_current_max2 = &v_current_max)
                    {
                        var __arg2 = __v_current_max2;
                        var __ret = __Internal.DragIntRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                        return __ret;
                    }
                }
            }

            public static bool DragScalar(string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
            {
                var __ret = __Internal.DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, flags);
                return __ret;
            }

            public static bool DragScalarN(string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
            {
                var __ret = __Internal.DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags);
                return __ret;
            }

            public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, int flags)
            {
                fixed (float* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.SliderFloat(label, __arg1, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat2(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat3(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat4(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderAngle(string label, ref float v_rad, float v_degrees_min, float v_degrees_max, string format, int flags)
            {
                fixed (float* __v_rad1 = &v_rad)
                {
                    var __arg1 = __v_rad1;
                    var __ret = __Internal.SliderAngle(label, __arg1, v_degrees_min, v_degrees_max, format, flags);
                    return __ret;
                }
            }

            public static bool SliderInt(string label, ref int v, int v_min, int v_max, string format, int flags)
            {
                fixed (int* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.SliderInt(label, __arg1, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool SliderInt2(string label, int[] v, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderInt2(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderInt3(string label, int[] v, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderInt3(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderInt4(string label, int[] v, int v_min, int v_max, string format, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderInt4(label, v, v_min, v_max, format, flags);
                return __ret;
            }

            public static bool SliderScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
            {
                var __ret = __Internal.SliderScalar(label, data_type, p_data, p_min, p_max, format, flags);
                return __ret;
            }

            public static bool SliderScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, string format, int flags)
            {
                var __ret = __Internal.SliderScalarN(label, data_type, p_data, components, p_min, p_max, format, flags);
                return __ret;
            }

            public static bool VSliderFloat(string label, global::Cored.ImVec2 size, ref float v, float v_min, float v_max, string format, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                fixed (float* __v2 = &v)
                {
                    var __arg2 = __v2;
                    var __ret = __Internal.VSliderFloat(label, __arg1, __arg2, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool VSliderInt(string label, global::Cored.ImVec2 size, ref int v, int v_min, int v_max, string format, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                fixed (int* __v2 = &v)
                {
                    var __arg2 = __v2;
                    var __ret = __Internal.VSliderInt(label, __arg1, __arg2, v_min, v_max, format, flags);
                    return __ret;
                }
            }

            public static bool VSliderScalar(string label, global::Cored.ImVec2 size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.VSliderScalar(label, __arg1, data_type, p_data, p_min, p_max, format, flags);
                return __ret;
            }

            public static bool InputText(string label, sbyte* buf, ulong buf_size, int flags, global::Cored.ImGuiInputTextCallback callback, __IntPtr user_data)
            {
                var __arg4 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
                var __ret = __Internal.InputText(label, buf, buf_size, flags, __arg4, user_data);
                return __ret;
            }

            public static bool InputTextMultiline(string label, sbyte* buf, ulong buf_size, global::Cored.ImVec2 size, int flags, global::Cored.ImGuiInputTextCallback callback, __IntPtr user_data)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = size.__Instance;
                var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
                var __ret = __Internal.InputTextMultiline(label, buf, buf_size, __arg3, flags, __arg5, user_data);
                return __ret;
            }

            public static bool InputTextWithHint(string label, string hint, sbyte* buf, ulong buf_size, int flags, global::Cored.ImGuiInputTextCallback callback, __IntPtr user_data)
            {
                var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
                var __ret = __Internal.InputTextWithHint(label, hint, buf, buf_size, flags, __arg5, user_data);
                return __ret;
            }

            public static bool InputFloat(string label, ref float v, float step, float step_fast, string format, int flags)
            {
                fixed (float* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.InputFloat(label, __arg1, step, step_fast, format, flags);
                    return __ret;
                }
            }

            public static bool InputFloat2(string label, float[] v, string format, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputFloat2(label, v, format, flags);
                return __ret;
            }

            public static bool InputFloat3(string label, float[] v, string format, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputFloat3(label, v, format, flags);
                return __ret;
            }

            public static bool InputFloat4(string label, float[] v, string format, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputFloat4(label, v, format, flags);
                return __ret;
            }

            public static bool InputInt(string label, ref int v, int step, int step_fast, int flags)
            {
                fixed (int* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.InputInt(label, __arg1, step, step_fast, flags);
                    return __ret;
                }
            }

            public static bool InputInt2(string label, int[] v, int flags)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputInt2(label, v, flags);
                return __ret;
            }

            public static bool InputInt3(string label, int[] v, int flags)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputInt3(label, v, flags);
                return __ret;
            }

            public static bool InputInt4(string label, int[] v, int flags)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.InputInt4(label, v, flags);
                return __ret;
            }

            public static bool InputDouble(string label, ref double v, double step, double step_fast, string format, int flags)
            {
                fixed (double* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.InputDouble(label, __arg1, step, step_fast, format, flags);
                    return __ret;
                }
            }

            public static bool InputScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
            {
                var __ret = __Internal.InputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
                return __ret;
            }

            public static bool InputScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
            {
                var __ret = __Internal.InputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
                return __ret;
            }

            public static bool ColorEdit3(string label, float[] col, int flags)
            {
                if (col == null || col.Length != 3)
                    throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.ColorEdit3(label, col, flags);
                return __ret;
            }

            public static bool ColorEdit4(string label, float[] col, int flags)
            {
                if (col == null || col.Length != 4)
                    throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.ColorEdit4(label, col, flags);
                return __ret;
            }

            public static bool ColorPicker3(string label, float[] col, int flags)
            {
                if (col == null || col.Length != 3)
                    throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.ColorPicker3(label, col, flags);
                return __ret;
            }

            public static bool ColorPicker4(string label, float[] col, int flags, ref float ref_col)
            {
                if (col == null || col.Length != 4)
                    throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
                fixed (float* __ref_col3 = &ref_col)
                {
                    var __arg3 = __ref_col3;
                    var __ret = __Internal.ColorPicker4(label, col, flags, __arg3);
                    return __ret;
                }
            }

            public static bool ColorButton(string desc_id, global::Cored.ImVec4 col, int flags, global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(col, null))
                    throw new global::System.ArgumentNullException("col", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = col.__Instance;
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
                var __arg3 = size.__Instance;
                var __ret = __Internal.ColorButton(desc_id, __arg1, flags, *(global::Cored.ImVec2.__Internal*) __arg3);
                return __ret;
            }

            public static void SetColorEditOptions(int flags)
            {
                __Internal.SetColorEditOptions(flags);
            }

            public static bool TreeNode(string label)
            {
                var __ret = __Internal.TreeNode(label);
                return __ret;
            }

            public static bool TreeNode(string str_id, string fmt)
            {
                var __ret = __Internal.TreeNode(str_id, fmt);
                return __ret;
            }

            public static bool TreeNode(__IntPtr ptr_id, string fmt)
            {
                var __ret = __Internal.TreeNode(ptr_id, fmt);
                return __ret;
            }

            public static bool TreeNodeEx(string label, int flags)
            {
                var __ret = __Internal.TreeNodeEx(label, flags);
                return __ret;
            }

            public static bool TreeNodeEx(string str_id, int flags, string fmt)
            {
                var __ret = __Internal.TreeNodeEx(str_id, flags, fmt);
                return __ret;
            }

            public static bool TreeNodeEx(__IntPtr ptr_id, int flags, string fmt)
            {
                var __ret = __Internal.TreeNodeEx(ptr_id, flags, fmt);
                return __ret;
            }

            public static void TreePush(string str_id)
            {
                __Internal.TreePush(str_id);
            }

            public static void TreePush(__IntPtr ptr_id)
            {
                __Internal.TreePush(ptr_id);
            }

            public static void TreePop()
            {
                __Internal.TreePop();
            }

            public static float GetTreeNodeToLabelSpacing()
            {
                var __ret = __Internal.GetTreeNodeToLabelSpacing();
                return __ret;
            }

            public static bool CollapsingHeader(string label, int flags)
            {
                var __ret = __Internal.CollapsingHeader(label, flags);
                return __ret;
            }

            public static bool CollapsingHeader(string label, ref bool p_visible, int flags)
            {
                fixed (bool* __p_visible1 = &p_visible)
                {
                    var __arg1 = __p_visible1;
                    var __ret = __Internal.CollapsingHeader(label, __arg1, flags);
                    return __ret;
                }
            }

            public static void SetNextItemOpen(bool is_open, int cond)
            {
                __Internal.SetNextItemOpen(is_open, cond);
            }

            public static bool Selectable(string label, bool selected, int flags, global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = size.__Instance;
                var __ret = __Internal.Selectable(label, selected, flags, __arg3);
                return __ret;
            }

            public static bool Selectable(string label, ref bool p_selected, int flags, global::Cored.ImVec2 size)
            {
                fixed (bool* __p_selected1 = &p_selected)
                {
                    var __arg1 = __p_selected1;
                    if (ReferenceEquals(size, null))
                        throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                    var __arg3 = size.__Instance;
                    var __ret = __Internal.Selectable_1(label, __arg1, flags, __arg3);
                    return __ret;
                }
            }

            public static bool BeginListBox(string label, global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.BeginListBox(label, __arg1);
                return __ret;
            }

            public static void EndListBox()
            {
                __Internal.EndListBox();
            }

            public static bool ListBox(string label, ref int current_item, string[] items, int items_count, int height_in_items)
            {
                fixed (int* __current_item1 = &current_item)
                {
                    var __arg1 = __current_item1;
                    var __ret = __Internal.ListBox(label, __arg1, items, items_count, height_in_items);
                    return __ret;
                }
            }

            public static bool ListBox(string label, ref int current_item, global::Cored.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int height_in_items)
            {
                fixed (int* __current_item1 = &current_item)
                {
                    var __arg1 = __current_item1;
                    var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                    var __ret = __Internal.ListBox(label, __arg1, __arg2, data, items_count, height_in_items);
                    return __ret;
                }
            }

            public static void PlotLines(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2 graph_size, int stride)
            {
                fixed (float* __values1 = &values)
                {
                    var __arg1 = __values1;
                    if (ReferenceEquals(graph_size, null))
                        throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                    var __arg7 = graph_size.__Instance;
                    __Internal.PlotLines(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::Cored.ImVec2.__Internal*) __arg7, stride);
                }
            }

            public static void PlotLines(string label, global::Cored.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2 graph_size)
            {
                var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg8 = graph_size.__Instance;
                __Internal.PlotLines(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::Cored.ImVec2.__Internal*) __arg8);
            }

            public static void PlotHistogram(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2 graph_size, int stride)
            {
                fixed (float* __values1 = &values)
                {
                    var __arg1 = __values1;
                    if (ReferenceEquals(graph_size, null))
                        throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                    var __arg7 = graph_size.__Instance;
                    __Internal.PlotHistogram(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::Cored.ImVec2.__Internal*) __arg7, stride);
                }
            }

            public static void PlotHistogram(string label, global::Cored.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::Cored.ImVec2 graph_size)
            {
                var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg8 = graph_size.__Instance;
                __Internal.PlotHistogram(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::Cored.ImVec2.__Internal*) __arg8);
            }

            public static void Value(string prefix, bool b)
            {
                __Internal.Value(prefix, b);
            }

            public static void Value(string prefix, int v)
            {
                __Internal.Value_1(prefix, v);
            }

            public static void Value(string prefix, uint v)
            {
                __Internal.Value_2(prefix, v);
            }

            public static void Value(string prefix, float v, string float_format)
            {
                __Internal.Value(prefix, v, float_format);
            }

            public static bool BeginMenuBar()
            {
                var __ret = __Internal.BeginMenuBar();
                return __ret;
            }

            public static void EndMenuBar()
            {
                __Internal.EndMenuBar();
            }

            public static bool BeginMainMenuBar()
            {
                var __ret = __Internal.BeginMainMenuBar();
                return __ret;
            }

            public static void EndMainMenuBar()
            {
                __Internal.EndMainMenuBar();
            }

            public static bool BeginMenu(string label, bool enabled)
            {
                var __ret = __Internal.BeginMenu(label, enabled);
                return __ret;
            }

            public static void EndMenu()
            {
                __Internal.EndMenu();
            }

            public static bool MenuItem(string label, string shortcut, bool selected, bool enabled)
            {
                var __ret = __Internal.MenuItem(label, shortcut, selected, enabled);
                return __ret;
            }

            public static bool MenuItem(string label, string shortcut, ref bool p_selected, bool enabled)
            {
                fixed (bool* __p_selected2 = &p_selected)
                {
                    var __arg2 = __p_selected2;
                    var __ret = __Internal.MenuItem_1(label, shortcut, __arg2, enabled);
                    return __ret;
                }
            }

            public static void BeginTooltip()
            {
                __Internal.BeginTooltip();
            }

            public static void EndTooltip()
            {
                __Internal.EndTooltip();
            }

            public static void SetTooltip(string fmt)
            {
                __Internal.SetTooltip(fmt);
            }

            public static bool BeginPopup(string str_id, int flags)
            {
                var __ret = __Internal.BeginPopup(str_id, flags);
                return __ret;
            }

            public static bool BeginPopupModal(string name, ref bool p_open, int flags)
            {
                fixed (bool* __p_open1 = &p_open)
                {
                    var __arg1 = __p_open1;
                    var __ret = __Internal.BeginPopupModal(name, __arg1, flags);
                    return __ret;
                }
            }

            public static void EndPopup()
            {
                __Internal.EndPopup();
            }

            public static void OpenPopup(string str_id, int popup_flags)
            {
                __Internal.OpenPopup(str_id, popup_flags);
            }

            public static void OpenPopup(uint id, int popup_flags)
            {
                __Internal.OpenPopup_1(id, popup_flags);
            }

            public static void OpenPopupOnItemClick(string str_id, int popup_flags)
            {
                __Internal.OpenPopupOnItemClick(str_id, popup_flags);
            }

            public static void CloseCurrentPopup()
            {
                __Internal.CloseCurrentPopup();
            }

            public static bool BeginPopupContextItem(string str_id, int popup_flags)
            {
                var __ret = __Internal.BeginPopupContextItem(str_id, popup_flags);
                return __ret;
            }

            public static bool BeginPopupContextWindow(string str_id, int popup_flags)
            {
                var __ret = __Internal.BeginPopupContextWindow(str_id, popup_flags);
                return __ret;
            }

            public static bool BeginPopupContextVoid(string str_id, int popup_flags)
            {
                var __ret = __Internal.BeginPopupContextVoid(str_id, popup_flags);
                return __ret;
            }

            public static bool IsPopupOpen(string str_id, int flags)
            {
                var __ret = __Internal.IsPopupOpen(str_id, flags);
                return __ret;
            }

            public static bool BeginTable(string str_id, int column, int flags, global::Cored.ImVec2 outer_size, float inner_width)
            {
                if (ReferenceEquals(outer_size, null))
                    throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = outer_size.__Instance;
                var __ret = __Internal.BeginTable(str_id, column, flags, __arg3, inner_width);
                return __ret;
            }

            public static void EndTable()
            {
                __Internal.EndTable();
            }

            public static void TableNextRow(int row_flags, float min_row_height)
            {
                __Internal.TableNextRow(row_flags, min_row_height);
            }

            public static bool TableNextColumn()
            {
                var __ret = __Internal.TableNextColumn();
                return __ret;
            }

            public static bool TableSetColumnIndex(int column_n)
            {
                var __ret = __Internal.TableSetColumnIndex(column_n);
                return __ret;
            }

            public static void TableSetupColumn(string label, int flags, float init_width_or_weight, uint user_id)
            {
                __Internal.TableSetupColumn(label, flags, init_width_or_weight, user_id);
            }

            public static void TableSetupScrollFreeze(int cols, int rows)
            {
                __Internal.TableSetupScrollFreeze(cols, rows);
            }

            public static void TableHeadersRow()
            {
                __Internal.TableHeadersRow();
            }

            public static void TableHeader(string label)
            {
                __Internal.TableHeader(label);
            }

            public static global::Cored.ImGuiTableSortSpecs TableGetSortSpecs()
            {
                var __ret = __Internal.TableGetSortSpecs();
                var __result0 = global::Cored.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static int TableGetColumnCount()
            {
                var __ret = __Internal.TableGetColumnCount();
                return __ret;
            }

            public static int TableGetColumnIndex()
            {
                var __ret = __Internal.TableGetColumnIndex();
                return __ret;
            }

            public static int TableGetRowIndex()
            {
                var __ret = __Internal.TableGetRowIndex();
                return __ret;
            }

            public static string TableGetColumnName(int column_n)
            {
                var __ret = __Internal.TableGetColumnName(column_n);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }

            public static int TableGetColumnFlags(int column_n)
            {
                var __ret = __Internal.TableGetColumnFlags(column_n);
                return __ret;
            }

            public static void TableSetColumnEnabled(int column_n, bool v)
            {
                __Internal.TableSetColumnEnabled(column_n, v);
            }

            public static void TableSetBgColor(int target, uint color, int column_n)
            {
                __Internal.TableSetBgColor(target, color, column_n);
            }

            public static void Columns(int count, string id, bool border)
            {
                __Internal.Columns(count, id, border);
            }

            public static void NextColumn()
            {
                __Internal.NextColumn();
            }

            public static int GetColumnIndex()
            {
                var __ret = __Internal.GetColumnIndex();
                return __ret;
            }

            public static float GetColumnWidth(int column_index)
            {
                var __ret = __Internal.GetColumnWidth(column_index);
                return __ret;
            }

            public static void SetColumnWidth(int column_index, float width)
            {
                __Internal.SetColumnWidth(column_index, width);
            }

            public static float GetColumnOffset(int column_index)
            {
                var __ret = __Internal.GetColumnOffset(column_index);
                return __ret;
            }

            public static void SetColumnOffset(int column_index, float offset_x)
            {
                __Internal.SetColumnOffset(column_index, offset_x);
            }

            public static int GetColumnsCount()
            {
                var __ret = __Internal.GetColumnsCount();
                return __ret;
            }

            public static bool BeginTabBar(string str_id, int flags)
            {
                var __ret = __Internal.BeginTabBar(str_id, flags);
                return __ret;
            }

            public static void EndTabBar()
            {
                __Internal.EndTabBar();
            }

            public static bool BeginTabItem(string label, ref bool p_open, int flags)
            {
                fixed (bool* __p_open1 = &p_open)
                {
                    var __arg1 = __p_open1;
                    var __ret = __Internal.BeginTabItem(label, __arg1, flags);
                    return __ret;
                }
            }

            public static void EndTabItem()
            {
                __Internal.EndTabItem();
            }

            public static bool TabItemButton(string label, int flags)
            {
                var __ret = __Internal.TabItemButton(label, flags);
                return __ret;
            }

            public static void SetTabItemClosed(string tab_or_docked_window_label)
            {
                __Internal.SetTabItemClosed(tab_or_docked_window_label);
            }

            public static uint DockSpace(uint id, global::Cored.ImVec2 size, int flags, global::Cored.ImGuiWindowClass window_class)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __arg3 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
                var __ret = __Internal.DockSpace(id, __arg1, flags, __arg3);
                return __ret;
            }

            public static uint DockSpaceOverViewport(global::Cored.ImGuiViewport viewport, int flags, global::Cored.ImGuiWindowClass window_class)
            {
                var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
                var __arg2 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
                var __ret = __Internal.DockSpaceOverViewport(__arg0, flags, __arg2);
                return __ret;
            }

            public static void SetNextWindowDockID(uint dock_id, int cond)
            {
                __Internal.SetNextWindowDockID(dock_id, cond);
            }

            public static void SetNextWindowClass(global::Cored.ImGuiWindowClass window_class)
            {
                var __arg0 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
                __Internal.SetNextWindowClass(__arg0);
            }

            public static uint GetWindowDockID()
            {
                var __ret = __Internal.GetWindowDockID();
                return __ret;
            }

            public static bool IsWindowDocked()
            {
                var __ret = __Internal.IsWindowDocked();
                return __ret;
            }

            public static void LogToTTY(int auto_open_depth)
            {
                __Internal.LogToTTY(auto_open_depth);
            }

            public static void LogToFile(int auto_open_depth, string filename)
            {
                __Internal.LogToFile(auto_open_depth, filename);
            }

            public static void LogToClipboard(int auto_open_depth)
            {
                __Internal.LogToClipboard(auto_open_depth);
            }

            public static void LogFinish()
            {
                __Internal.LogFinish();
            }

            public static void LogButtons()
            {
                __Internal.LogButtons();
            }

            public static void LogText(string fmt)
            {
                __Internal.LogText(fmt);
            }

            public static bool BeginDragDropSource(int flags)
            {
                var __ret = __Internal.BeginDragDropSource(flags);
                return __ret;
            }

            public static bool SetDragDropPayload(string type, __IntPtr data, ulong sz, int cond)
            {
                var __ret = __Internal.SetDragDropPayload(type, data, sz, cond);
                return __ret;
            }

            public static void EndDragDropSource()
            {
                __Internal.EndDragDropSource();
            }

            public static bool BeginDragDropTarget()
            {
                var __ret = __Internal.BeginDragDropTarget();
                return __ret;
            }

            public static global::Cored.ImGuiPayload AcceptDragDropPayload(string type, int flags)
            {
                var __ret = __Internal.AcceptDragDropPayload(type, flags);
                var __result0 = global::Cored.ImGuiPayload.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void EndDragDropTarget()
            {
                __Internal.EndDragDropTarget();
            }

            public static global::Cored.ImGuiPayload GetDragDropPayload()
            {
                var __ret = __Internal.GetDragDropPayload();
                var __result0 = global::Cored.ImGuiPayload.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void PushClipRect(global::Cored.ImVec2 clip_rect_min, global::Cored.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
            {
                if (ReferenceEquals(clip_rect_min, null))
                    throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = clip_rect_min.__Instance;
                if (ReferenceEquals(clip_rect_max, null))
                    throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = clip_rect_max.__Instance;
                __Internal.PushClipRect(__arg0, __arg1, intersect_with_current_clip_rect);
            }

            public static void PopClipRect()
            {
                __Internal.PopClipRect();
            }

            public static void SetItemDefaultFocus()
            {
                __Internal.SetItemDefaultFocus();
            }

            public static void SetKeyboardFocusHere(int offset)
            {
                __Internal.SetKeyboardFocusHere(offset);
            }

            public static bool IsItemHovered(int flags)
            {
                var __ret = __Internal.IsItemHovered(flags);
                return __ret;
            }

            public static bool IsItemActive()
            {
                var __ret = __Internal.IsItemActive();
                return __ret;
            }

            public static bool IsItemFocused()
            {
                var __ret = __Internal.IsItemFocused();
                return __ret;
            }

            public static bool IsItemClicked(int mouse_button)
            {
                var __ret = __Internal.IsItemClicked(mouse_button);
                return __ret;
            }

            public static bool IsItemVisible()
            {
                var __ret = __Internal.IsItemVisible();
                return __ret;
            }

            public static bool IsItemEdited()
            {
                var __ret = __Internal.IsItemEdited();
                return __ret;
            }

            public static bool IsItemActivated()
            {
                var __ret = __Internal.IsItemActivated();
                return __ret;
            }

            public static bool IsItemDeactivated()
            {
                var __ret = __Internal.IsItemDeactivated();
                return __ret;
            }

            public static bool IsItemDeactivatedAfterEdit()
            {
                var __ret = __Internal.IsItemDeactivatedAfterEdit();
                return __ret;
            }

            public static bool IsItemToggledOpen()
            {
                var __ret = __Internal.IsItemToggledOpen();
                return __ret;
            }

            public static bool IsAnyItemHovered()
            {
                var __ret = __Internal.IsAnyItemHovered();
                return __ret;
            }

            public static bool IsAnyItemActive()
            {
                var __ret = __Internal.IsAnyItemActive();
                return __ret;
            }

            public static bool IsAnyItemFocused()
            {
                var __ret = __Internal.IsAnyItemFocused();
                return __ret;
            }

            public static global::Cored.ImVec2 GetItemRectMin()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetItemRectMin(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetItemRectMax()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetItemRectMax(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetItemRectSize()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetItemRectSize(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static void SetItemAllowOverlap()
            {
                __Internal.SetItemAllowOverlap();
            }

            public static global::Cored.ImGuiViewport GetMainViewport()
            {
                var __ret = __Internal.GetMainViewport();
                var __result0 = global::Cored.ImGuiViewport.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static bool IsRectVisible(global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = size.__Instance;
                var __ret = __Internal.IsRectVisible(__arg0);
                return __ret;
            }

            public static bool IsRectVisible(global::Cored.ImVec2 rect_min, global::Cored.ImVec2 rect_max)
            {
                if (ReferenceEquals(rect_min, null))
                    throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = rect_min.__Instance;
                if (ReferenceEquals(rect_max, null))
                    throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = rect_max.__Instance;
                var __ret = __Internal.IsRectVisible(__arg0, __arg1);
                return __ret;
            }

            public static double GetTime()
            {
                var __ret = __Internal.GetTime();
                return __ret;
            }

            public static int GetFrameCount()
            {
                var __ret = __Internal.GetFrameCount();
                return __ret;
            }

            public static global::Cored.ImDrawList GetBackgroundDrawList()
            {
                var __ret = __Internal.GetBackgroundDrawList();
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImDrawList GetForegroundDrawList()
            {
                var __ret = __Internal.GetForegroundDrawList();
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImDrawList GetBackgroundDrawList(global::Cored.ImGuiViewport viewport)
            {
                var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
                var __ret = __Internal.GetBackgroundDrawList(__arg0);
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImDrawList GetForegroundDrawList(global::Cored.ImGuiViewport viewport)
            {
                var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
                var __ret = __Internal.GetForegroundDrawList(__arg0);
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImDrawListSharedData GetDrawListSharedData()
            {
                var __ret = __Internal.GetDrawListSharedData();
                var __result0 = global::Cored.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static string GetStyleColorName(int idx)
            {
                var __ret = __Internal.GetStyleColorName(idx);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }

            public static void SetStateStorage(global::Cored.ImGuiStorage storage)
            {
                var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
                __Internal.SetStateStorage(__arg0);
            }

            public static global::Cored.ImGuiStorage GetStateStorage()
            {
                var __ret = __Internal.GetStateStorage();
                var __result0 = global::Cored.ImGuiStorage.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void CalcListClipping(int items_count, float items_height, ref int out_items_display_start, ref int out_items_display_end)
            {
                fixed (int* __out_items_display_start2 = &out_items_display_start)
                {
                    var __arg2 = __out_items_display_start2;
                    fixed (int* __out_items_display_end3 = &out_items_display_end)
                    {
                        var __arg3 = __out_items_display_end3;
                        __Internal.CalcListClipping(items_count, items_height, __arg2, __arg3);
                    }
                }
            }

            public static bool BeginChildFrame(uint id, global::Cored.ImVec2 size, int flags)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.BeginChildFrame(id, __arg1, flags);
                return __ret;
            }

            public static void EndChildFrame()
            {
                __Internal.EndChildFrame();
            }

            public static global::Cored.ImVec2 CalcTextSize(string text, string text_end, bool hide_text_after_double_hash, float wrap_width)
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.CalcTextSize(new IntPtr(&__ret), text, text_end, hide_text_after_double_hash, wrap_width);
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec4 ColorConvertU32ToFloat4(uint @in)
            {
                var __ret = new global::Cored.ImVec4.__Internal();
                __Internal.ColorConvertU32ToFloat4(new IntPtr(&__ret), @in);
                return global::Cored.ImVec4.__CreateInstance(__ret);
            }

            public static uint ColorConvertFloat4ToU32(global::Cored.ImVec4 @in)
            {
                if (ReferenceEquals(@in, null))
                    throw new global::System.ArgumentNullException("@in", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = @in.__Instance;
                var __ret = __Internal.ColorConvertFloat4ToU32(__arg0);
                return __ret;
            }

            public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
            {
                fixed (float* __out_h3 = &out_h)
                {
                    var __arg3 = __out_h3;
                    fixed (float* __out_s4 = &out_s)
                    {
                        var __arg4 = __out_s4;
                        fixed (float* __out_v5 = &out_v)
                        {
                            var __arg5 = __out_v5;
                            __Internal.ColorConvertRGBtoHSV(r, g, b, __arg3, __arg4, __arg5);
                        }
                    }
                }
            }

            public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
            {
                fixed (float* __out_r3 = &out_r)
                {
                    var __arg3 = __out_r3;
                    fixed (float* __out_g4 = &out_g)
                    {
                        var __arg4 = __out_g4;
                        fixed (float* __out_b5 = &out_b)
                        {
                            var __arg5 = __out_b5;
                            __Internal.ColorConvertHSVtoRGB(h, s, v, __arg3, __arg4, __arg5);
                        }
                    }
                }
            }

            public static int GetKeyIndex(int imgui_key)
            {
                var __ret = __Internal.GetKeyIndex(imgui_key);
                return __ret;
            }

            public static bool IsKeyDown(int user_key_index)
            {
                var __ret = __Internal.IsKeyDown(user_key_index);
                return __ret;
            }

            public static bool IsKeyPressed(int user_key_index, bool repeat)
            {
                var __ret = __Internal.IsKeyPressed(user_key_index, repeat);
                return __ret;
            }

            public static bool IsKeyReleased(int user_key_index)
            {
                var __ret = __Internal.IsKeyReleased(user_key_index);
                return __ret;
            }

            public static int GetKeyPressedAmount(int key_index, float repeat_delay, float rate)
            {
                var __ret = __Internal.GetKeyPressedAmount(key_index, repeat_delay, rate);
                return __ret;
            }

            public static void CaptureKeyboardFromApp(bool want_capture_keyboard_value)
            {
                __Internal.CaptureKeyboardFromApp(want_capture_keyboard_value);
            }

            public static bool IsMouseDown(int button)
            {
                var __ret = __Internal.IsMouseDown(button);
                return __ret;
            }

            public static bool IsMouseClicked(int button, bool repeat)
            {
                var __ret = __Internal.IsMouseClicked(button, repeat);
                return __ret;
            }

            public static bool IsMouseReleased(int button)
            {
                var __ret = __Internal.IsMouseReleased(button);
                return __ret;
            }

            public static bool IsMouseDoubleClicked(int button)
            {
                var __ret = __Internal.IsMouseDoubleClicked(button);
                return __ret;
            }

            public static bool IsMouseHoveringRect(global::Cored.ImVec2 r_min, global::Cored.ImVec2 r_max, bool clip)
            {
                if (ReferenceEquals(r_min, null))
                    throw new global::System.ArgumentNullException("r_min", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = r_min.__Instance;
                if (ReferenceEquals(r_max, null))
                    throw new global::System.ArgumentNullException("r_max", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = r_max.__Instance;
                var __ret = __Internal.IsMouseHoveringRect(__arg0, __arg1, clip);
                return __ret;
            }

            public static bool IsMousePosValid(global::Cored.ImVec2 mouse_pos)
            {
                var __arg0 = mouse_pos is null ? __IntPtr.Zero : mouse_pos.__Instance;
                var __ret = __Internal.IsMousePosValid(__arg0);
                return __ret;
            }

            public static bool IsAnyMouseDown()
            {
                var __ret = __Internal.IsAnyMouseDown();
                return __ret;
            }

            public static global::Cored.ImVec2 GetMousePos()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetMousePos(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static global::Cored.ImVec2 GetMousePosOnOpeningCurrentPopup()
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetMousePosOnOpeningCurrentPopup(new IntPtr(&__ret));
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static bool IsMouseDragging(int button, float lock_threshold)
            {
                var __ret = __Internal.IsMouseDragging(button, lock_threshold);
                return __ret;
            }

            public static global::Cored.ImVec2 GetMouseDragDelta(int button, float lock_threshold)
            {
                var __ret = new global::Cored.ImVec2.__Internal();
                __Internal.GetMouseDragDelta(new IntPtr(&__ret), button, lock_threshold);
                return global::Cored.ImVec2.__CreateInstance(__ret);
            }

            public static void ResetMouseDragDelta(int button)
            {
                __Internal.ResetMouseDragDelta(button);
            }

            public static int GetMouseCursor()
            {
                var __ret = __Internal.GetMouseCursor();
                return __ret;
            }

            public static void SetMouseCursor(int cursor_type)
            {
                __Internal.SetMouseCursor(cursor_type);
            }

            public static void CaptureMouseFromApp(bool want_capture_mouse_value)
            {
                __Internal.CaptureMouseFromApp(want_capture_mouse_value);
            }

            public static string GetClipboardText()
            {
                var __ret = __Internal.GetClipboardText();
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }

            public static void SetClipboardText(string text)
            {
                __Internal.SetClipboardText(text);
            }

            public static void LoadIniSettingsFromDisk(string ini_filename)
            {
                __Internal.LoadIniSettingsFromDisk(ini_filename);
            }

            public static void LoadIniSettingsFromMemory(string ini_data, ulong ini_size)
            {
                __Internal.LoadIniSettingsFromMemory(ini_data, ini_size);
            }

            public static void SaveIniSettingsToDisk(string ini_filename)
            {
                __Internal.SaveIniSettingsToDisk(ini_filename);
            }

            public static string SaveIniSettingsToMemory(ref ulong out_ini_size)
            {
                fixed (ulong* __out_ini_size0 = &out_ini_size)
                {
                    var __arg0 = __out_ini_size0;
                    var __ret = __Internal.SaveIniSettingsToMemory(__arg0);
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
                }
            }

            public static bool DebugCheckVersionAndDataLayout(string version_str, ulong sz_io, ulong sz_style, ulong sz_vec2, ulong sz_vec4, ulong sz_drawvert, ulong sz_drawidx)
            {
                var __ret = __Internal.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
                return __ret;
            }

            public static void SetAllocatorFunctions(global::Cored.ImGuiMemAllocFunc alloc_func, global::Cored.ImGuiMemFreeFunc free_func, __IntPtr user_data)
            {
                var __arg0 = alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_func);
                var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
                __Internal.SetAllocatorFunctions(__arg0, __arg1, user_data);
            }

            public static void GetAllocatorFunctions(global::Cored.ImGuiMemAllocFunc p_alloc_func, global::Cored.ImGuiMemFreeFunc p_free_func, void** p_user_data)
            {
                var __arg0 = p_alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_alloc_func);
                var __arg1 = p_free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_free_func);
                __Internal.GetAllocatorFunctions(__arg0, __arg1, p_user_data);
            }

            public static __IntPtr MemAlloc(ulong size)
            {
                var __ret = __Internal.MemAlloc(size);
                return __ret;
            }

            public static void MemFree(__IntPtr ptr)
            {
                __Internal.MemFree(ptr);
            }

            public static global::Cored.ImGuiPlatformIO GetPlatformIO()
            {
                var __ret = __Internal.GetPlatformIO();
                var __result0 = global::Cored.ImGuiPlatformIO.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static void UpdatePlatformWindows()
            {
                __Internal.UpdatePlatformWindows();
            }

            public static void RenderPlatformWindowsDefault(__IntPtr platform_render_arg, __IntPtr renderer_render_arg)
            {
                __Internal.RenderPlatformWindowsDefault(platform_render_arg, renderer_render_arg);
            }

            public static void DestroyPlatformWindows()
            {
                __Internal.DestroyPlatformWindows();
            }

            public static global::Cored.ImGuiViewport FindViewportByID(uint id)
            {
                var __ret = __Internal.FindViewportByID(id);
                var __result0 = global::Cored.ImGuiViewport.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static global::Cored.ImGuiViewport FindViewportByPlatformHandle(__IntPtr platform_handle)
            {
                var __ret = __Internal.FindViewportByPlatformHandle(platform_handle);
                var __result0 = global::Cored.ImGuiViewport.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            public static bool ListBoxHeader(string label, int items_count, int height_in_items)
            {
                var __ret = __Internal.ListBoxHeader(label, items_count, height_in_items);
                return __ret;
            }

            public static bool ListBoxHeader(string label, global::Cored.ImVec2 size)
            {
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = size.__Instance;
                var __ret = __Internal.ListBoxHeader(label, __arg1);
                return __ret;
            }

            public static void ListBoxFooter()
            {
                __Internal.ListBoxFooter();
            }

            public static void OpenPopupContextItem(string str_id, int mb)
            {
                __Internal.OpenPopupContextItem(str_id, mb);
            }

            public static bool DragScalar(string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, float power)
            {
                var __ret = __Internal.DragScalar_1(label, data_type, p_data, v_speed, p_min, p_max, format, power);
                return __ret;
            }

            public static bool DragScalarN(string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, float power)
            {
                var __ret = __Internal.DragScalarN_1(label, data_type, p_data, components, v_speed, p_min, p_max, format, power);
                return __ret;
            }

            public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, float power)
            {
                fixed (float* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.DragFloat_1(label, __arg1, v_speed, v_min, v_max, format, power);
                    return __ret;
                }
            }

            public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat2_1(label, v, v_speed, v_min, v_max, format, power);
                return __ret;
            }

            public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat3_1(label, v, v_speed, v_min, v_max, format, power);
                return __ret;
            }

            public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.DragFloat4_1(label, v, v_speed, v_min, v_max, format, power);
                return __ret;
            }

            public static bool SliderScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, float power)
            {
                var __ret = __Internal.SliderScalar_1(label, data_type, p_data, p_min, p_max, format, power);
                return __ret;
            }

            public static bool SliderScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, string format, float power)
            {
                var __ret = __Internal.SliderScalarN_1(label, data_type, p_data, components, p_min, p_max, format, power);
                return __ret;
            }

            public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, float power)
            {
                fixed (float* __v1 = &v)
                {
                    var __arg1 = __v1;
                    var __ret = __Internal.SliderFloat_1(label, __arg1, v_min, v_max, format, power);
                    return __ret;
                }
            }

            public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 2)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat2_1(label, v, v_min, v_max, format, power);
                return __ret;
            }

            public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 3)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat3_1(label, v, v_min, v_max, format, power);
                return __ret;
            }

            public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, float power)
            {
                if (v == null || v.Length != 4)
                    throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
                var __ret = __Internal.SliderFloat4_1(label, v, v_min, v_max, format, power);
                return __ret;
            }

            public static bool BeginPopupContextWindow(string str_id, int mb, bool over_items)
            {
                var __ret = __Internal.BeginPopupContextWindow(str_id, mb, over_items);
                return __ret;
            }

            public static void TreeAdvanceToLabelPos()
            {
                __Internal.TreeAdvanceToLabelPos();
            }

            public static void SetNextTreeNodeOpen(bool open, int cond)
            {
                __Internal.SetNextTreeNodeOpen(open, cond);
            }

            public static float GetContentRegionAvailWidth()
            {
                var __ret = __Internal.GetContentRegionAvailWidth();
                return __ret;
            }

            public static global::Cored.ImDrawList GetOverlayDrawList()
            {
                var __ret = __Internal.GetOverlayDrawList();
                var __result0 = global::Cored.ImDrawList.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }
    }

    public enum STBRP_HEURISTIC_Skyline
    {
        STBRP_HEURISTIC_Skyline_default = 0,
        STBRP_HEURISTIC_SkylineBL_sortHeight = 0,
        STBRP_HEURISTIC_SkylineBF_sortHeight = 1
    }

    public unsafe partial class StbrpRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int id;
            internal ushort w;
            internal ushort h;
            internal ushort x;
            internal ushort y;
            internal int was_packed;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbrp_rect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpRect>();

        protected bool __ownsNativeInstance;

        internal static StbrpRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbrpRect(native.ToPointer(), skipVTables);
        }

        internal static StbrpRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbrpRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbrpRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbrpRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbrpRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbrpRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbrpRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbrpRect(global::Cored.StbrpRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbrpRect.__Internal*) __Instance) = *((global::Cored.StbrpRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        public ushort W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        public ushort H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public int WasPacked
        {
            get
            {
                return ((__Internal*)__Instance)->was_packed;
            }

            set
            {
                ((__Internal*)__Instance)->was_packed = value;
            }
        }
    }

    /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbrpNode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal ushort x;
            internal ushort y;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbrp_node@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpNode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpNode>();

        protected bool __ownsNativeInstance;

        internal static StbrpNode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbrpNode(native.ToPointer(), skipVTables);
        }

        internal static StbrpNode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbrpNode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbrpNode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbrpNode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbrpNode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbrpNode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbrpNode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbrpNode(global::Cored.StbrpNode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpNode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbrpNode.__Internal*) __Instance) = *((global::Cored.StbrpNode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public global::Cored.StbrpNode Next
        {
            get
            {
                var __result0 = global::Cored.StbrpNode.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class StbrpContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal int width;
            internal int height;
            internal int align;
            internal int init_mode;
            internal int heuristic;
            internal int num_nodes;
            internal __IntPtr active_head;
            internal __IntPtr free_head;
            internal fixed byte extra[32];

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbrp_context@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbrpContext>();

        protected bool __ownsNativeInstance;

        internal static StbrpContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbrpContext(native.ToPointer(), skipVTables);
        }

        internal static StbrpContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbrpContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbrpContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbrpContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbrpContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbrpContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbrpContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbrpContext(global::Cored.StbrpContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbrpContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbrpContext.__Internal*) __Instance) = *((global::Cored.StbrpContext.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public int Align
        {
            get
            {
                return ((__Internal*)__Instance)->align;
            }

            set
            {
                ((__Internal*)__Instance)->align = value;
            }
        }

        public int InitMode
        {
            get
            {
                return ((__Internal*)__Instance)->init_mode;
            }

            set
            {
                ((__Internal*)__Instance)->init_mode = value;
            }
        }

        public int Heuristic
        {
            get
            {
                return ((__Internal*)__Instance)->heuristic;
            }

            set
            {
                ((__Internal*)__Instance)->heuristic = value;
            }
        }

        public int NumNodes
        {
            get
            {
                return ((__Internal*)__Instance)->num_nodes;
            }

            set
            {
                ((__Internal*)__Instance)->num_nodes = value;
            }
        }

        public global::Cored.StbrpNode ActiveHead
        {
            get
            {
                var __result0 = global::Cored.StbrpNode.__GetOrCreateInstance(((__Internal*)__Instance)->active_head, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->active_head = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Cored.StbrpNode FreeHead
        {
            get
            {
                var __result0 = global::Cored.StbrpNode.__GetOrCreateInstance(((__Internal*)__Instance)->free_head, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->free_head = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::Cored.StbrpNode[] Extra
        {
            get
            {
                global::Cored.StbrpNode[] __value = null;
                if (((__Internal*)__Instance)->extra != null)
                {
                    __value = new global::Cored.StbrpNode[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::Cored.StbrpNode.__CreateInstance(*((global::Cored.StbrpNode.__Internal*)&(((__Internal*)__Instance)->extra[i * sizeof(global::Cored.StbrpNode.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::Cored.StbrpNode.__Internal*) &((__Internal*)__Instance)->extra[i * sizeof(global::Cored.StbrpNode.__Internal)] = *(global::Cored.StbrpNode.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class imstb_rectpack
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbrp_pack_rects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbrpPackRects(__IntPtr context, __IntPtr rects, int num_rects);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbrp_init_target", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbrpInitTarget(__IntPtr context, int width, int height, __IntPtr nodes, int num_nodes);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbrp_setup_allow_out_of_mem", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbrpSetupAllowOutOfMem(__IntPtr context, int allow_out_of_mem);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbrp_setup_heuristic", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbrpSetupHeuristic(__IntPtr context, int heuristic);
        }

        public static int StbrpPackRects(global::Cored.StbrpContext context, global::Cored.StbrpRect rects, int num_rects)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.StbrpPackRects(__arg0, __arg1, num_rects);
            return __ret;
        }

        public static void StbrpInitTarget(global::Cored.StbrpContext context, int width, int height, global::Cored.StbrpNode nodes, int num_nodes)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __arg3 = nodes is null ? __IntPtr.Zero : nodes.__Instance;
            __Internal.StbrpInitTarget(__arg0, width, height, __arg3, num_nodes);
        }

        public static void StbrpSetupAllowOutOfMem(global::Cored.StbrpContext context, int allow_out_of_mem)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.StbrpSetupAllowOutOfMem(__arg0, allow_out_of_mem);
        }

        public static void StbrpSetupHeuristic(global::Cored.StbrpContext context, int heuristic)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.StbrpSetupHeuristic(__arg0, heuristic);
        }
    }

    /// <summary>/////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbUndoRecord : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int @where;
            internal int insert_length;
            internal int delete_length;
            internal int char_storage;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0StbUndoRecord@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbUndoRecord> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbUndoRecord>();

        protected bool __ownsNativeInstance;

        internal static StbUndoRecord __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoRecord(native.ToPointer(), skipVTables);
        }

        internal static StbUndoRecord __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbUndoRecord)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbUndoRecord __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoRecord(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoRecord(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbUndoRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoRecord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbUndoRecord(global::Cored.StbUndoRecord __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbUndoRecord.__Internal*) __Instance) = *((global::Cored.StbUndoRecord.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Where
        {
            get
            {
                return ((__Internal*)__Instance)->@where;
            }

            set
            {
                ((__Internal*)__Instance)->@where = value;
            }
        }

        public int InsertLength
        {
            get
            {
                return ((__Internal*)__Instance)->insert_length;
            }

            set
            {
                ((__Internal*)__Instance)->insert_length = value;
            }
        }

        public int DeleteLength
        {
            get
            {
                return ((__Internal*)__Instance)->delete_length;
            }

            set
            {
                ((__Internal*)__Instance)->delete_length = value;
            }
        }

        public int CharStorage
        {
            get
            {
                return ((__Internal*)__Instance)->char_storage;
            }

            set
            {
                ((__Internal*)__Instance)->char_storage = value;
            }
        }
    }

    public unsafe partial class StbUndoState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5592)]
        public partial struct __Internal
        {
            internal fixed byte undo_rec[1584];
            internal fixed int undo_char[999];
            internal short undo_point;
            internal short redo_point;
            internal int undo_char_point;
            internal int redo_char_point;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0StbUndoState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbUndoState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbUndoState>();

        protected bool __ownsNativeInstance;

        internal static StbUndoState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoState(native.ToPointer(), skipVTables);
        }

        internal static StbUndoState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbUndoState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbUndoState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbUndoState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbUndoState(global::Cored.StbUndoState __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbUndoState.__Internal*) __Instance) = *((global::Cored.StbUndoState.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::Cored.StbUndoRecord[] UndoRec
        {
            get
            {
                global::Cored.StbUndoRecord[] __value = null;
                if (((__Internal*)__Instance)->undo_rec != null)
                {
                    __value = new global::Cored.StbUndoRecord[99];
                    for (int i = 0; i < 99; i++)
                        __value[i] = global::Cored.StbUndoRecord.__CreateInstance(*((global::Cored.StbUndoRecord.__Internal*)&(((__Internal*)__Instance)->undo_rec[i * sizeof(global::Cored.StbUndoRecord.__Internal)])));
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 99)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 99; i++)
                        *(global::Cored.StbUndoRecord.__Internal*) &((__Internal*)__Instance)->undo_rec[i * sizeof(global::Cored.StbUndoRecord.__Internal)] = *(global::Cored.StbUndoRecord.__Internal*)value[i].__Instance;
                }
            }
        }

        public int[] UndoChar
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->undo_char, 999);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 999; i++)
                        ((__Internal*)__Instance)->undo_char[i] = value[i];
                }
            }
        }

        public short UndoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_point = value;
            }
        }

        public short RedoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_point = value;
            }
        }

        public int UndoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_char_point = value;
            }
        }

        public int RedoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_char_point = value;
            }
        }
    }

    public unsafe partial class STB_TexteditState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 5624)]
        public partial struct __Internal
        {
            internal int cursor;
            internal int select_start;
            internal int select_end;
            internal byte insert_mode;
            internal int row_count_per_page;
            internal byte cursor_at_end_of_line;
            internal byte initialized;
            internal byte has_preferred_x;
            internal byte single_line;
            internal byte padding1;
            internal byte padding2;
            internal byte padding3;
            internal float preferred_x;
            internal global::Cored.StbUndoState.__Internal undostate;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0STB_TexteditState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.STB_TexteditState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.STB_TexteditState>();

        protected bool __ownsNativeInstance;

        internal static STB_TexteditState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new STB_TexteditState(native.ToPointer(), skipVTables);
        }

        internal static STB_TexteditState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (STB_TexteditState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static STB_TexteditState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new STB_TexteditState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private STB_TexteditState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected STB_TexteditState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public STB_TexteditState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public STB_TexteditState(global::Cored.STB_TexteditState __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.STB_TexteditState.__Internal*) __Instance) = *((global::Cored.STB_TexteditState.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Cursor
        {
            get
            {
                return ((__Internal*)__Instance)->cursor;
            }

            set
            {
                ((__Internal*)__Instance)->cursor = value;
            }
        }

        public int SelectStart
        {
            get
            {
                return ((__Internal*)__Instance)->select_start;
            }

            set
            {
                ((__Internal*)__Instance)->select_start = value;
            }
        }

        public int SelectEnd
        {
            get
            {
                return ((__Internal*)__Instance)->select_end;
            }

            set
            {
                ((__Internal*)__Instance)->select_end = value;
            }
        }

        public byte InsertMode
        {
            get
            {
                return ((__Internal*)__Instance)->insert_mode;
            }

            set
            {
                ((__Internal*)__Instance)->insert_mode = value;
            }
        }

        public int RowCountPerPage
        {
            get
            {
                return ((__Internal*)__Instance)->row_count_per_page;
            }

            set
            {
                ((__Internal*)__Instance)->row_count_per_page = value;
            }
        }

        public byte CursorAtEndOfLine
        {
            get
            {
                return ((__Internal*)__Instance)->cursor_at_end_of_line;
            }

            set
            {
                ((__Internal*)__Instance)->cursor_at_end_of_line = value;
            }
        }

        public byte Initialized
        {
            get
            {
                return ((__Internal*)__Instance)->initialized;
            }

            set
            {
                ((__Internal*)__Instance)->initialized = value;
            }
        }

        public byte HasPreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->has_preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->has_preferred_x = value;
            }
        }

        public byte SingleLine
        {
            get
            {
                return ((__Internal*)__Instance)->single_line;
            }

            set
            {
                ((__Internal*)__Instance)->single_line = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        public float PreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->preferred_x = value;
            }
        }

        public global::Cored.StbUndoState Undostate
        {
            get
            {
                return global::Cored.StbUndoState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->undostate));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->undostate = *(global::Cored.StbUndoState.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>/////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbTexteditRow : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal float x0;
            internal float x1;
            internal float baseline_y_delta;
            internal float ymin;
            internal float ymax;
            internal int num_chars;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0StbTexteditRow@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbTexteditRow> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbTexteditRow>();

        protected bool __ownsNativeInstance;

        internal static StbTexteditRow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbTexteditRow(native.ToPointer(), skipVTables);
        }

        internal static StbTexteditRow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbTexteditRow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbTexteditRow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbTexteditRow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbTexteditRow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbTexteditRow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbTexteditRow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbTexteditRow(global::Cored.StbTexteditRow __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbTexteditRow.__Internal*) __Instance) = *((global::Cored.StbTexteditRow.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float BaselineYDelta
        {
            get
            {
                return ((__Internal*)__Instance)->baseline_y_delta;
            }

            set
            {
                ((__Internal*)__Instance)->baseline_y_delta = value;
            }
        }

        public float Ymin
        {
            get
            {
                return ((__Internal*)__Instance)->ymin;
            }

            set
            {
                ((__Internal*)__Instance)->ymin = value;
            }
        }

        public float Ymax
        {
            get
            {
                return ((__Internal*)__Instance)->ymax;
            }

            set
            {
                ((__Internal*)__Instance)->ymax = value;
            }
        }

        public int NumChars
        {
            get
            {
                return ((__Internal*)__Instance)->num_chars;
            }

            set
            {
                ((__Internal*)__Instance)->num_chars = value;
            }
        }
    }

    public enum STBTT_v
    {
        STBTT_vmove = 1,
        STBTT_vline = 2,
        STBTT_vcurve = 3,
        STBTT_vcubic = 4
    }

    public enum STBTT_PLATFORM_ID
    {
        STBTT_PLATFORM_ID_UNICODE = 0,
        STBTT_PLATFORM_ID_MAC = 1,
        STBTT_PLATFORM_ID_ISO = 2,
        STBTT_PLATFORM_ID_MICROSOFT = 3
    }

    public enum STBTT_UNICODE_EID
    {
        STBTT_UNICODE_EID_UNICODE_1_0 = 0,
        STBTT_UNICODE_EID_UNICODE_1_1 = 1,
        STBTT_UNICODE_EID_ISO_10646 = 2,
        STBTT_UNICODE_EID_UNICODE_2_0BMP = 3,
        STBTT_UNICODE_EID_UNICODE_2_0FULL = 4
    }

    public enum STBTT_MS_EID
    {
        STBTT_MS_EID_SYMBOL = 0,
        STBTT_MS_EID_UNICODE_BMP = 1,
        STBTT_MS_EID_SHIFTJIS = 2,
        STBTT_MS_EID_UNICODE_FULL = 10
    }

    public enum STBTT_MAC_EID
    {
        STBTT_MAC_EID_ROMAN = 0,
        STBTT_MAC_EID_ARABIC = 4,
        STBTT_MAC_EID_JAPANESE = 1,
        STBTT_MAC_EID_HEBREW = 5,
        STBTT_MAC_EID_CHINESE_TRAD = 2,
        STBTT_MAC_EID_GREEK = 6,
        STBTT_MAC_EID_KOREAN = 3,
        STBTT_MAC_EID_RUSSIAN = 7
    }

    public enum STBTT_MS_LANG
    {
        STBTT_MS_LANG_ENGLISH = 1033,
        STBTT_MS_LANG_ITALIAN = 1040,
        STBTT_MS_LANG_CHINESE = 2052,
        STBTT_MS_LANG_JAPANESE = 1041,
        STBTT_MS_LANG_DUTCH = 1043,
        STBTT_MS_LANG_KOREAN = 1042,
        STBTT_MS_LANG_FRENCH = 1036,
        STBTT_MS_LANG_RUSSIAN = 1049,
        STBTT_MS_LANG_GERMAN = 1031,
        STBTT_MS_LANG_SPANISH = 1033,
        STBTT_MS_LANG_HEBREW = 1037,
        STBTT_MS_LANG_SWEDISH = 1053
    }

    public enum STBTT_MAC_LANG
    {
        STBTT_MAC_LANG_ENGLISH = 0,
        STBTT_MAC_LANG_JAPANESE = 11,
        STBTT_MAC_LANG_ARABIC = 12,
        STBTT_MAC_LANG_KOREAN = 23,
        STBTT_MAC_LANG_DUTCH = 4,
        STBTT_MAC_LANG_RUSSIAN = 32,
        STBTT_MAC_LANG_FRENCH = 1,
        STBTT_MAC_LANG_SPANISH = 6,
        STBTT_MAC_LANG_GERMAN = 2,
        STBTT_MAC_LANG_SWEDISH = 5,
        STBTT_MAC_LANG_HEBREW = 10,
        STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
        STBTT_MAC_LANG_ITALIAN = 3,
        STBTT_MAC_LANG_CHINESE_TRAD = 19
    }

    /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
    /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbttBuf : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal int cursor;
            internal int size;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt__buf@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBuf> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBuf>();

        protected bool __ownsNativeInstance;

        internal static StbttBuf __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttBuf(native.ToPointer(), skipVTables);
        }

        internal static StbttBuf __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttBuf)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttBuf __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttBuf(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttBuf(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttBuf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttBuf()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBuf.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttBuf(global::Cored.StbttBuf __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBuf.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttBuf.__Internal*) __Instance) = *((global::Cored.StbttBuf.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        public int Cursor
        {
            get
            {
                return ((__Internal*)__Instance)->cursor;
            }

            set
            {
                ((__Internal*)__Instance)->cursor = value;
            }
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }
    }

    /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbttBakedchar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            internal ushort x0;
            internal ushort y0;
            internal ushort x1;
            internal ushort y1;
            internal float xoff;
            internal float yoff;
            internal float xadvance;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_bakedchar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBakedchar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBakedchar>();

        protected bool __ownsNativeInstance;

        internal static StbttBakedchar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttBakedchar(native.ToPointer(), skipVTables);
        }

        internal static StbttBakedchar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttBakedchar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttBakedchar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttBakedchar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttBakedchar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttBakedchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttBakedchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBakedchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttBakedchar(global::Cored.StbttBakedchar __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBakedchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttBakedchar.__Internal*) __Instance) = *((global::Cored.StbttBakedchar.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public ushort Y0
        {
            get
            {
                return ((__Internal*)__Instance)->y0;
            }

            set
            {
                ((__Internal*)__Instance)->y0 = value;
            }
        }

        public ushort X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public ushort Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public float Xoff
        {
            get
            {
                return ((__Internal*)__Instance)->xoff;
            }

            set
            {
                ((__Internal*)__Instance)->xoff = value;
            }
        }

        public float Yoff
        {
            get
            {
                return ((__Internal*)__Instance)->yoff;
            }

            set
            {
                ((__Internal*)__Instance)->yoff = value;
            }
        }

        public float Xadvance
        {
            get
            {
                return ((__Internal*)__Instance)->xadvance;
            }

            set
            {
                ((__Internal*)__Instance)->xadvance = value;
            }
        }
    }

    public unsafe partial class StbttAlignedQuad : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal float x0;
            internal float y0;
            internal float s0;
            internal float t0;
            internal float x1;
            internal float y1;
            internal float s1;
            internal float t1;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_aligned_quad@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttAlignedQuad> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttAlignedQuad>();

        protected bool __ownsNativeInstance;

        internal static StbttAlignedQuad __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttAlignedQuad(native.ToPointer(), skipVTables);
        }

        internal static StbttAlignedQuad __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttAlignedQuad)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttAlignedQuad __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttAlignedQuad(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttAlignedQuad(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttAlignedQuad(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttAlignedQuad()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttAlignedQuad.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttAlignedQuad(global::Cored.StbttAlignedQuad __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttAlignedQuad.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttAlignedQuad.__Internal*) __Instance) = *((global::Cored.StbttAlignedQuad.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((__Internal*)__Instance)->y0;
            }

            set
            {
                ((__Internal*)__Instance)->y0 = value;
            }
        }

        public float S0
        {
            get
            {
                return ((__Internal*)__Instance)->s0;
            }

            set
            {
                ((__Internal*)__Instance)->s0 = value;
            }
        }

        public float T0
        {
            get
            {
                return ((__Internal*)__Instance)->t0;
            }

            set
            {
                ((__Internal*)__Instance)->t0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public float S1
        {
            get
            {
                return ((__Internal*)__Instance)->s1;
            }

            set
            {
                ((__Internal*)__Instance)->s1 = value;
            }
        }

        public float T1
        {
            get
            {
                return ((__Internal*)__Instance)->t1;
            }

            set
            {
                ((__Internal*)__Instance)->t1 = value;
            }
        }
    }

    /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
    public unsafe partial class StbttPackedchar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal ushort x0;
            internal ushort y0;
            internal ushort x1;
            internal ushort y1;
            internal float xoff;
            internal float yoff;
            internal float xadvance;
            internal float xoff2;
            internal float yoff2;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_packedchar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackedchar> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackedchar>();

        protected bool __ownsNativeInstance;

        internal static StbttPackedchar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttPackedchar(native.ToPointer(), skipVTables);
        }

        internal static StbttPackedchar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttPackedchar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttPackedchar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttPackedchar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttPackedchar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttPackedchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttPackedchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackedchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttPackedchar(global::Cored.StbttPackedchar __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackedchar.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttPackedchar.__Internal*) __Instance) = *((global::Cored.StbttPackedchar.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public ushort Y0
        {
            get
            {
                return ((__Internal*)__Instance)->y0;
            }

            set
            {
                ((__Internal*)__Instance)->y0 = value;
            }
        }

        public ushort X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public ushort Y1
        {
            get
            {
                return ((__Internal*)__Instance)->y1;
            }

            set
            {
                ((__Internal*)__Instance)->y1 = value;
            }
        }

        public float Xoff
        {
            get
            {
                return ((__Internal*)__Instance)->xoff;
            }

            set
            {
                ((__Internal*)__Instance)->xoff = value;
            }
        }

        public float Yoff
        {
            get
            {
                return ((__Internal*)__Instance)->yoff;
            }

            set
            {
                ((__Internal*)__Instance)->yoff = value;
            }
        }

        public float Xadvance
        {
            get
            {
                return ((__Internal*)__Instance)->xadvance;
            }

            set
            {
                ((__Internal*)__Instance)->xadvance = value;
            }
        }

        public float Xoff2
        {
            get
            {
                return ((__Internal*)__Instance)->xoff2;
            }

            set
            {
                ((__Internal*)__Instance)->xoff2 = value;
            }
        }

        public float Yoff2
        {
            get
            {
                return ((__Internal*)__Instance)->yoff2;
            }

            set
            {
                ((__Internal*)__Instance)->yoff2 = value;
            }
        }
    }

    public unsafe partial class StbttPackRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal float font_size;
            internal int first_unicode_codepoint_in_range;
            internal __IntPtr array_of_unicode_codepoints;
            internal int num_chars;
            internal __IntPtr chardata_for_range;
            internal byte h_oversample;
            internal byte v_oversample;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_pack_range@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackRange>();

        protected bool __ownsNativeInstance;

        internal static StbttPackRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttPackRange(native.ToPointer(), skipVTables);
        }

        internal static StbttPackRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttPackRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttPackRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttPackRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttPackRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttPackRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttPackRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttPackRange(global::Cored.StbttPackRange __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackRange.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttPackRange.__Internal*) __Instance) = *((global::Cored.StbttPackRange.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->font_size;
            }

            set
            {
                ((__Internal*)__Instance)->font_size = value;
            }
        }

        public int FirstUnicodeCodepointInRange
        {
            get
            {
                return ((__Internal*)__Instance)->first_unicode_codepoint_in_range;
            }

            set
            {
                ((__Internal*)__Instance)->first_unicode_codepoint_in_range = value;
            }
        }

        public int* ArrayOfUnicodeCodepoints
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->array_of_unicode_codepoints;
            }

            set
            {
                ((__Internal*)__Instance)->array_of_unicode_codepoints = (__IntPtr) value;
            }
        }

        public int NumChars
        {
            get
            {
                return ((__Internal*)__Instance)->num_chars;
            }

            set
            {
                ((__Internal*)__Instance)->num_chars = value;
            }
        }

        public global::Cored.StbttPackedchar ChardataForRange
        {
            get
            {
                var __result0 = global::Cored.StbttPackedchar.__GetOrCreateInstance(((__Internal*)__Instance)->chardata_for_range, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->chardata_for_range = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public byte HOversample
        {
            get
            {
                return ((__Internal*)__Instance)->h_oversample;
            }

            set
            {
                ((__Internal*)__Instance)->h_oversample = value;
            }
        }

        public byte VOversample
        {
            get
            {
                return ((__Internal*)__Instance)->v_oversample;
            }

            set
            {
                ((__Internal*)__Instance)->v_oversample = value;
            }
        }
    }

    public unsafe partial class StbttPackContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal __IntPtr user_allocator_context;
            internal __IntPtr pack_info;
            internal int width;
            internal int height;
            internal int stride_in_bytes;
            internal int padding;
            internal int skip_missing;
            internal uint h_oversample;
            internal uint v_oversample;
            internal __IntPtr pixels;
            internal __IntPtr nodes;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_pack_context@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttPackContext>();

        protected bool __ownsNativeInstance;

        internal static StbttPackContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttPackContext(native.ToPointer(), skipVTables);
        }

        internal static StbttPackContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttPackContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttPackContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttPackContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttPackContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttPackContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttPackContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttPackContext(global::Cored.StbttPackContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttPackContext.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttPackContext.__Internal*) __Instance) = *((global::Cored.StbttPackContext.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserAllocatorContext
        {
            get
            {
                return ((__Internal*)__Instance)->user_allocator_context;
            }

            set
            {
                ((__Internal*)__Instance)->user_allocator_context = (__IntPtr) value;
            }
        }

        public __IntPtr PackInfo
        {
            get
            {
                return ((__Internal*)__Instance)->pack_info;
            }

            set
            {
                ((__Internal*)__Instance)->pack_info = (__IntPtr) value;
            }
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        public int StrideInBytes
        {
            get
            {
                return ((__Internal*)__Instance)->stride_in_bytes;
            }

            set
            {
                ((__Internal*)__Instance)->stride_in_bytes = value;
            }
        }

        public int Padding
        {
            get
            {
                return ((__Internal*)__Instance)->padding;
            }

            set
            {
                ((__Internal*)__Instance)->padding = value;
            }
        }

        public int SkipMissing
        {
            get
            {
                return ((__Internal*)__Instance)->skip_missing;
            }

            set
            {
                ((__Internal*)__Instance)->skip_missing = value;
            }
        }

        public uint HOversample
        {
            get
            {
                return ((__Internal*)__Instance)->h_oversample;
            }

            set
            {
                ((__Internal*)__Instance)->h_oversample = value;
            }
        }

        public uint VOversample
        {
            get
            {
                return ((__Internal*)__Instance)->v_oversample;
            }

            set
            {
                ((__Internal*)__Instance)->v_oversample = value;
            }
        }

        public byte* Pixels
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->pixels;
            }

            set
            {
                ((__Internal*)__Instance)->pixels = (__IntPtr) value;
            }
        }

        public __IntPtr Nodes
        {
            get
            {
                return ((__Internal*)__Instance)->nodes;
            }

            set
            {
                ((__Internal*)__Instance)->nodes = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class StbttFontinfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 160)]
        public partial struct __Internal
        {
            internal __IntPtr userdata;
            internal __IntPtr data;
            internal int fontstart;
            internal int numGlyphs;
            internal int loca;
            internal int head;
            internal int glyf;
            internal int hhea;
            internal int hmtx;
            internal int kern;
            internal int gpos;
            internal int index_map;
            internal int indexToLocFormat;
            internal global::Cored.StbttBuf.__Internal cff;
            internal global::Cored.StbttBuf.__Internal charstrings;
            internal global::Cored.StbttBuf.__Internal gsubrs;
            internal global::Cored.StbttBuf.__Internal subrs;
            internal global::Cored.StbttBuf.__Internal fontdicts;
            internal global::Cored.StbttBuf.__Internal fdselect;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_fontinfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttFontinfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttFontinfo>();

        protected bool __ownsNativeInstance;

        internal static StbttFontinfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttFontinfo(native.ToPointer(), skipVTables);
        }

        internal static StbttFontinfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttFontinfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttFontinfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttFontinfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttFontinfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttFontinfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttFontinfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttFontinfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttFontinfo(global::Cored.StbttFontinfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttFontinfo.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttFontinfo.__Internal*) __Instance) = *((global::Cored.StbttFontinfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Userdata
        {
            get
            {
                return ((__Internal*)__Instance)->userdata;
            }

            set
            {
                ((__Internal*)__Instance)->userdata = (__IntPtr) value;
            }
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        public int Fontstart
        {
            get
            {
                return ((__Internal*)__Instance)->fontstart;
            }

            set
            {
                ((__Internal*)__Instance)->fontstart = value;
            }
        }

        public int NumGlyphs
        {
            get
            {
                return ((__Internal*)__Instance)->numGlyphs;
            }

            set
            {
                ((__Internal*)__Instance)->numGlyphs = value;
            }
        }

        public int Loca
        {
            get
            {
                return ((__Internal*)__Instance)->loca;
            }

            set
            {
                ((__Internal*)__Instance)->loca = value;
            }
        }

        public int Head
        {
            get
            {
                return ((__Internal*)__Instance)->head;
            }

            set
            {
                ((__Internal*)__Instance)->head = value;
            }
        }

        public int Glyf
        {
            get
            {
                return ((__Internal*)__Instance)->glyf;
            }

            set
            {
                ((__Internal*)__Instance)->glyf = value;
            }
        }

        public int Hhea
        {
            get
            {
                return ((__Internal*)__Instance)->hhea;
            }

            set
            {
                ((__Internal*)__Instance)->hhea = value;
            }
        }

        public int Hmtx
        {
            get
            {
                return ((__Internal*)__Instance)->hmtx;
            }

            set
            {
                ((__Internal*)__Instance)->hmtx = value;
            }
        }

        public int Kern
        {
            get
            {
                return ((__Internal*)__Instance)->kern;
            }

            set
            {
                ((__Internal*)__Instance)->kern = value;
            }
        }

        public int Gpos
        {
            get
            {
                return ((__Internal*)__Instance)->gpos;
            }

            set
            {
                ((__Internal*)__Instance)->gpos = value;
            }
        }

        public int IndexMap
        {
            get
            {
                return ((__Internal*)__Instance)->index_map;
            }

            set
            {
                ((__Internal*)__Instance)->index_map = value;
            }
        }

        public int IndexToLocFormat
        {
            get
            {
                return ((__Internal*)__Instance)->indexToLocFormat;
            }

            set
            {
                ((__Internal*)__Instance)->indexToLocFormat = value;
            }
        }

        public global::Cored.StbttBuf Cff
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cff));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cff = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }

        public global::Cored.StbttBuf Charstrings
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->charstrings));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->charstrings = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }

        public global::Cored.StbttBuf Gsubrs
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gsubrs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gsubrs = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }

        public global::Cored.StbttBuf Subrs
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->subrs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->subrs = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }

        public global::Cored.StbttBuf Fontdicts
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->fontdicts));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->fontdicts = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }

        public global::Cored.StbttBuf Fdselect
        {
            get
            {
                return global::Cored.StbttBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->fdselect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->fdselect = *(global::Cored.StbttBuf.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class StbttVertex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 14)]
        public partial struct __Internal
        {
            internal short x;
            internal short y;
            internal short cx;
            internal short cy;
            internal short cx1;
            internal short cy1;
            internal byte type;
            internal byte padding;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt_vertex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttVertex> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttVertex>();

        protected bool __ownsNativeInstance;

        internal static StbttVertex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttVertex(native.ToPointer(), skipVTables);
        }

        internal static StbttVertex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttVertex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttVertex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttVertex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttVertex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttVertex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttVertex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttVertex(global::Cored.StbttVertex __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttVertex.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttVertex.__Internal*) __Instance) = *((global::Cored.StbttVertex.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public short Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public short Cx
        {
            get
            {
                return ((__Internal*)__Instance)->cx;
            }

            set
            {
                ((__Internal*)__Instance)->cx = value;
            }
        }

        public short Cy
        {
            get
            {
                return ((__Internal*)__Instance)->cy;
            }

            set
            {
                ((__Internal*)__Instance)->cy = value;
            }
        }

        public short Cx1
        {
            get
            {
                return ((__Internal*)__Instance)->cx1;
            }

            set
            {
                ((__Internal*)__Instance)->cx1 = value;
            }
        }

        public short Cy1
        {
            get
            {
                return ((__Internal*)__Instance)->cy1;
            }

            set
            {
                ((__Internal*)__Instance)->cy1 = value;
            }
        }

        public byte Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        public byte Padding
        {
            get
            {
                return ((__Internal*)__Instance)->padding;
            }

            set
            {
                ((__Internal*)__Instance)->padding = value;
            }
        }
    }

    public unsafe partial class StbttBitmap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int w;
            internal int h;
            internal int stride;
            internal __IntPtr pixels;

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "??0stbtt__bitmap@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBitmap> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Cored.StbttBitmap>();

        protected bool __ownsNativeInstance;

        internal static StbttBitmap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbttBitmap(native.ToPointer(), skipVTables);
        }

        internal static StbttBitmap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (StbttBitmap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static StbttBitmap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbttBitmap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbttBitmap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected StbttBitmap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbttBitmap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBitmap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public StbttBitmap(global::Cored.StbttBitmap __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Cored.StbttBitmap.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::Cored.StbttBitmap.__Internal*) __Instance) = *((global::Cored.StbttBitmap.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        public int H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        public int Stride
        {
            get
            {
                return ((__Internal*)__Instance)->stride;
            }

            set
            {
                ((__Internal*)__Instance)->stride = value;
            }
        }

        public byte* Pixels
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->pixels;
            }

            set
            {
                ((__Internal*)__Instance)->pixels = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class imstb_truetype
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_BakeFontBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttBakeFontBitmap(byte* data, int offset, float pixel_height, byte* pixels, int pw, int ph, int first_char, int num_chars, __IntPtr chardata);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetBakedQuad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetBakedQuad(__IntPtr chardata, int pw, int ph, int char_index, float* xpos, float* ypos, __IntPtr q, int opengl_fillrule);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetScaledFontVMetrics", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetScaledFontVMetrics(byte* fontdata, int index, float size, float* ascent, float* descent, float* lineGap);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackBegin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttPackBegin(__IntPtr spc, byte* pixels, int width, int height, int stride_in_bytes, int padding, __IntPtr alloc_context);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackEnd", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttPackEnd(__IntPtr spc);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackFontRange", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttPackFontRange(__IntPtr spc, byte* fontdata, int font_index, float font_size, int first_unicode_char_in_range, int num_chars_in_range, __IntPtr chardata_for_range);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackFontRanges", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttPackFontRanges(__IntPtr spc, byte* fontdata, int font_index, __IntPtr ranges, int num_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackSetOversampling", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttPackSetOversampling(__IntPtr spc, uint h_oversample, uint v_oversample);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackSetSkipMissingCodepoints", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttPackSetSkipMissingCodepoints(__IntPtr spc, int skip);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetPackedQuad", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetPackedQuad(__IntPtr chardata, int pw, int ph, int char_index, float* xpos, float* ypos, __IntPtr q, int align_to_integer);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackFontRangesGatherRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttPackFontRangesGatherRects(__IntPtr spc, __IntPtr info, __IntPtr ranges, int num_ranges, __IntPtr rects);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackFontRangesPackRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttPackFontRangesPackRects(__IntPtr spc, __IntPtr rects, int num_rects);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_PackFontRangesRenderIntoRects", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttPackFontRangesRenderIntoRects(__IntPtr spc, __IntPtr info, __IntPtr ranges, int num_ranges, __IntPtr rects);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetNumberOfFonts", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetNumberOfFonts(byte* data);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetFontOffsetForIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetFontOffsetForIndex(byte* data, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_InitFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttInitFont(__IntPtr info, byte* data, int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_FindGlyphIndex", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttFindGlyphIndex(__IntPtr info, int unicode_codepoint);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_ScaleForPixelHeight", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float StbttScaleForPixelHeight(__IntPtr info, float pixels);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_ScaleForMappingEmToPixels", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern float StbttScaleForMappingEmToPixels(__IntPtr info, float pixels);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetFontVMetrics", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetFontVMetrics(__IntPtr info, int* ascent, int* descent, int* lineGap);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetFontVMetricsOS2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetFontVMetricsOS2(__IntPtr info, int* typoAscent, int* typoDescent, int* typoLineGap);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetFontBoundingBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetFontBoundingBox(__IntPtr info, int* x0, int* y0, int* x1, int* y1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointHMetrics", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetCodepointHMetrics(__IntPtr info, int codepoint, int* advanceWidth, int* leftSideBearing);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointKernAdvance", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetCodepointKernAdvance(__IntPtr info, int ch1, int ch2);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetCodepointBox(__IntPtr info, int codepoint, int* x0, int* y0, int* x1, int* y1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphHMetrics", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetGlyphHMetrics(__IntPtr info, int glyph_index, int* advanceWidth, int* leftSideBearing);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphKernAdvance", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetGlyphKernAdvance(__IntPtr info, int glyph1, int glyph2);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetGlyphBox(__IntPtr info, int glyph_index, int* x0, int* y0, int* x1, int* y1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_IsGlyphEmpty", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttIsGlyphEmpty(__IntPtr info, int glyph_index);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointShape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetCodepointShape(__IntPtr info, int unicode_codepoint, __IntPtr vertices);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphShape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttGetGlyphShape(__IntPtr info, int glyph_index, __IntPtr vertices);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_FreeShape", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttFreeShape(__IntPtr info, __IntPtr vertices);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_FreeBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttFreeBitmap(byte* bitmap, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetCodepointBitmap(__IntPtr info, float scale_x, float scale_y, int codepoint, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointBitmapSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetCodepointBitmapSubpixel(__IntPtr info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeCodepointBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeCodepointBitmap(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeCodepointBitmapSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeCodepointBitmapSubpixel(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeCodepointBitmapSubpixelPrefilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeCodepointBitmapSubpixelPrefilter(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float* sub_x, float* sub_y, int codepoint);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointBitmapBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetCodepointBitmapBox(__IntPtr font, int codepoint, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointBitmapBoxSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetCodepointBitmapBoxSubpixel(__IntPtr font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetGlyphBitmap(__IntPtr info, float scale_x, float scale_y, int glyph, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphBitmapSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetGlyphBitmapSubpixel(__IntPtr info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeGlyphBitmap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeGlyphBitmap(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeGlyphBitmapSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeGlyphBitmapSubpixel(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_MakeGlyphBitmapSubpixelPrefilter", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttMakeGlyphBitmapSubpixelPrefilter(__IntPtr info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float* sub_x, float* sub_y, int glyph);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphBitmapBox", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetGlyphBitmapBox(__IntPtr font, int glyph, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphBitmapBoxSubpixel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttGetGlyphBitmapBoxSubpixel(__IntPtr font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_Rasterize", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttRasterize(__IntPtr result, float flatness_in_pixels, __IntPtr vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_FreeSDF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void StbttFreeSDF(byte* bitmap, __IntPtr userdata);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetGlyphSDF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetGlyphSDF(__IntPtr info, float scale, int glyph, int padding, byte onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetCodepointSDF", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte* StbttGetCodepointSDF(__IntPtr info, float scale, int codepoint, int padding, byte onedge_value, float pixel_dist_scale, int* width, int* height, int* xoff, int* yoff);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_FindMatchingFont", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttFindMatchingFont(byte* fontdata, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_CompareUTF8toUTF16_bigendian", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int StbttCompareUTF8toUTF16Bigendian([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s1, int len1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string s2, int len2);

            [SuppressUnmanagedCodeSecurity, DllImport("Cored", EntryPoint = "stbtt_GetFontNameString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr StbttGetFontNameString(__IntPtr font, int* length, int platformID, int encodingID, int languageID, int nameID);
        }

        public static int StbttBakeFontBitmap(byte* data, int offset, float pixel_height, byte* pixels, int pw, int ph, int first_char, int num_chars, global::Cored.StbttBakedchar chardata)
        {
            var __arg8 = chardata is null ? __IntPtr.Zero : chardata.__Instance;
            var __ret = __Internal.StbttBakeFontBitmap(data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, __arg8);
            return __ret;
        }

        public static void StbttGetBakedQuad(global::Cored.StbttBakedchar chardata, int pw, int ph, int char_index, ref float xpos, ref float ypos, global::Cored.StbttAlignedQuad q, int opengl_fillrule)
        {
            var __arg0 = chardata is null ? __IntPtr.Zero : chardata.__Instance;
            fixed (float* __xpos4 = &xpos)
            {
                var __arg4 = __xpos4;
                fixed (float* __ypos5 = &ypos)
                {
                    var __arg5 = __ypos5;
                    var __arg6 = q is null ? __IntPtr.Zero : q.__Instance;
                    __Internal.StbttGetBakedQuad(__arg0, pw, ph, char_index, __arg4, __arg5, __arg6, opengl_fillrule);
                }
            }
        }

        public static void StbttGetScaledFontVMetrics(byte* fontdata, int index, float size, ref float ascent, ref float descent, ref float lineGap)
        {
            fixed (float* __ascent3 = &ascent)
            {
                var __arg3 = __ascent3;
                fixed (float* __descent4 = &descent)
                {
                    var __arg4 = __descent4;
                    fixed (float* __lineGap5 = &lineGap)
                    {
                        var __arg5 = __lineGap5;
                        __Internal.StbttGetScaledFontVMetrics(fontdata, index, size, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static int StbttPackBegin(global::Cored.StbttPackContext spc, byte* pixels, int width, int height, int stride_in_bytes, int padding, __IntPtr alloc_context)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __ret = __Internal.StbttPackBegin(__arg0, pixels, width, height, stride_in_bytes, padding, alloc_context);
            return __ret;
        }

        public static void StbttPackEnd(global::Cored.StbttPackContext spc)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            __Internal.StbttPackEnd(__arg0);
        }

        public static int StbttPackFontRange(global::Cored.StbttPackContext spc, byte* fontdata, int font_index, float font_size, int first_unicode_char_in_range, int num_chars_in_range, global::Cored.StbttPackedchar chardata_for_range)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __arg6 = chardata_for_range is null ? __IntPtr.Zero : chardata_for_range.__Instance;
            var __ret = __Internal.StbttPackFontRange(__arg0, fontdata, font_index, font_size, first_unicode_char_in_range, num_chars_in_range, __arg6);
            return __ret;
        }

        public static int StbttPackFontRanges(global::Cored.StbttPackContext spc, byte* fontdata, int font_index, global::Cored.StbttPackRange ranges, int num_ranges)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __arg3 = ranges is null ? __IntPtr.Zero : ranges.__Instance;
            var __ret = __Internal.StbttPackFontRanges(__arg0, fontdata, font_index, __arg3, num_ranges);
            return __ret;
        }

        public static void StbttPackSetOversampling(global::Cored.StbttPackContext spc, uint h_oversample, uint v_oversample)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            __Internal.StbttPackSetOversampling(__arg0, h_oversample, v_oversample);
        }

        public static void StbttPackSetSkipMissingCodepoints(global::Cored.StbttPackContext spc, int skip)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            __Internal.StbttPackSetSkipMissingCodepoints(__arg0, skip);
        }

        public static void StbttGetPackedQuad(global::Cored.StbttPackedchar chardata, int pw, int ph, int char_index, ref float xpos, ref float ypos, global::Cored.StbttAlignedQuad q, int align_to_integer)
        {
            var __arg0 = chardata is null ? __IntPtr.Zero : chardata.__Instance;
            fixed (float* __xpos4 = &xpos)
            {
                var __arg4 = __xpos4;
                fixed (float* __ypos5 = &ypos)
                {
                    var __arg5 = __ypos5;
                    var __arg6 = q is null ? __IntPtr.Zero : q.__Instance;
                    __Internal.StbttGetPackedQuad(__arg0, pw, ph, char_index, __arg4, __arg5, __arg6, align_to_integer);
                }
            }
        }

        public static int StbttPackFontRangesGatherRects(global::Cored.StbttPackContext spc, global::Cored.StbttFontinfo info, global::Cored.StbttPackRange ranges, int num_ranges, global::Cored.StbrpRect rects)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __arg2 = ranges is null ? __IntPtr.Zero : ranges.__Instance;
            var __arg4 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.StbttPackFontRangesGatherRects(__arg0, __arg1, __arg2, num_ranges, __arg4);
            return __ret;
        }

        public static void StbttPackFontRangesPackRects(global::Cored.StbttPackContext spc, global::Cored.StbrpRect rects, int num_rects)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __arg1 = rects is null ? __IntPtr.Zero : rects.__Instance;
            __Internal.StbttPackFontRangesPackRects(__arg0, __arg1, num_rects);
        }

        public static int StbttPackFontRangesRenderIntoRects(global::Cored.StbttPackContext spc, global::Cored.StbttFontinfo info, global::Cored.StbttPackRange ranges, int num_ranges, global::Cored.StbrpRect rects)
        {
            var __arg0 = spc is null ? __IntPtr.Zero : spc.__Instance;
            var __arg1 = info is null ? __IntPtr.Zero : info.__Instance;
            var __arg2 = ranges is null ? __IntPtr.Zero : ranges.__Instance;
            var __arg4 = rects is null ? __IntPtr.Zero : rects.__Instance;
            var __ret = __Internal.StbttPackFontRangesRenderIntoRects(__arg0, __arg1, __arg2, num_ranges, __arg4);
            return __ret;
        }

        /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
        public static int StbttGetNumberOfFonts(byte* data)
        {
            var __ret = __Internal.StbttGetNumberOfFonts(data);
            return __ret;
        }

        public static int StbttGetFontOffsetForIndex(byte* data, int index)
        {
            var __ret = __Internal.StbttGetFontOffsetForIndex(data, index);
            return __ret;
        }

        public static int StbttInitFont(global::Cored.StbttFontinfo info, byte* data, int offset)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttInitFont(__arg0, data, offset);
            return __ret;
        }

        /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
        public static int StbttFindGlyphIndex(global::Cored.StbttFontinfo info, int unicode_codepoint)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttFindGlyphIndex(__arg0, unicode_codepoint);
            return __ret;
        }

        /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
        public static float StbttScaleForPixelHeight(global::Cored.StbttFontinfo info, float pixels)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttScaleForPixelHeight(__arg0, pixels);
            return __ret;
        }

        public static float StbttScaleForMappingEmToPixels(global::Cored.StbttFontinfo info, float pixels)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttScaleForMappingEmToPixels(__arg0, pixels);
            return __ret;
        }

        public static void StbttGetFontVMetrics(global::Cored.StbttFontinfo info, ref int ascent, ref int descent, ref int lineGap)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __ascent1 = &ascent)
            {
                var __arg1 = __ascent1;
                fixed (int* __descent2 = &descent)
                {
                    var __arg2 = __descent2;
                    fixed (int* __lineGap3 = &lineGap)
                    {
                        var __arg3 = __lineGap3;
                        __Internal.StbttGetFontVMetrics(__arg0, __arg1, __arg2, __arg3);
                    }
                }
            }
        }

        public static int StbttGetFontVMetricsOS2(global::Cored.StbttFontinfo info, ref int typoAscent, ref int typoDescent, ref int typoLineGap)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __typoAscent1 = &typoAscent)
            {
                var __arg1 = __typoAscent1;
                fixed (int* __typoDescent2 = &typoDescent)
                {
                    var __arg2 = __typoDescent2;
                    fixed (int* __typoLineGap3 = &typoLineGap)
                    {
                        var __arg3 = __typoLineGap3;
                        var __ret = __Internal.StbttGetFontVMetricsOS2(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        public static void StbttGetFontBoundingBox(global::Cored.StbttFontinfo info, ref int x0, ref int y0, ref int x1, ref int y1)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __x01 = &x0)
            {
                var __arg1 = __x01;
                fixed (int* __y02 = &y0)
                {
                    var __arg2 = __y02;
                    fixed (int* __x13 = &x1)
                    {
                        var __arg3 = __x13;
                        fixed (int* __y14 = &y1)
                        {
                            var __arg4 = __y14;
                            __Internal.StbttGetFontBoundingBox(__arg0, __arg1, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }
        }

        public static void StbttGetCodepointHMetrics(global::Cored.StbttFontinfo info, int codepoint, ref int advanceWidth, ref int leftSideBearing)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __advanceWidth2 = &advanceWidth)
            {
                var __arg2 = __advanceWidth2;
                fixed (int* __leftSideBearing3 = &leftSideBearing)
                {
                    var __arg3 = __leftSideBearing3;
                    __Internal.StbttGetCodepointHMetrics(__arg0, codepoint, __arg2, __arg3);
                }
            }
        }

        public static int StbttGetCodepointKernAdvance(global::Cored.StbttFontinfo info, int ch1, int ch2)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttGetCodepointKernAdvance(__arg0, ch1, ch2);
            return __ret;
        }

        public static int StbttGetCodepointBox(global::Cored.StbttFontinfo info, int codepoint, ref int x0, ref int y0, ref int x1, ref int y1)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __x02 = &x0)
            {
                var __arg2 = __x02;
                fixed (int* __y03 = &y0)
                {
                    var __arg3 = __y03;
                    fixed (int* __x14 = &x1)
                    {
                        var __arg4 = __x14;
                        fixed (int* __y15 = &y1)
                        {
                            var __arg5 = __y15;
                            var __ret = __Internal.StbttGetCodepointBox(__arg0, codepoint, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static void StbttGetGlyphHMetrics(global::Cored.StbttFontinfo info, int glyph_index, ref int advanceWidth, ref int leftSideBearing)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __advanceWidth2 = &advanceWidth)
            {
                var __arg2 = __advanceWidth2;
                fixed (int* __leftSideBearing3 = &leftSideBearing)
                {
                    var __arg3 = __leftSideBearing3;
                    __Internal.StbttGetGlyphHMetrics(__arg0, glyph_index, __arg2, __arg3);
                }
            }
        }

        public static int StbttGetGlyphKernAdvance(global::Cored.StbttFontinfo info, int glyph1, int glyph2)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttGetGlyphKernAdvance(__arg0, glyph1, glyph2);
            return __ret;
        }

        public static int StbttGetGlyphBox(global::Cored.StbttFontinfo info, int glyph_index, ref int x0, ref int y0, ref int x1, ref int y1)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __x02 = &x0)
            {
                var __arg2 = __x02;
                fixed (int* __y03 = &y0)
                {
                    var __arg3 = __y03;
                    fixed (int* __x14 = &x1)
                    {
                        var __arg4 = __x14;
                        fixed (int* __y15 = &y1)
                        {
                            var __arg5 = __y15;
                            var __ret = __Internal.StbttGetGlyphBox(__arg0, glyph_index, __arg2, __arg3, __arg4, __arg5);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static int StbttIsGlyphEmpty(global::Cored.StbttFontinfo info, int glyph_index)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __ret = __Internal.StbttIsGlyphEmpty(__arg0, glyph_index);
            return __ret;
        }

        public static int StbttGetCodepointShape(global::Cored.StbttFontinfo info, int unicode_codepoint, global::Cored.StbttVertex vertices)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var ____arg2 = vertices is null ? __IntPtr.Zero : vertices.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.StbttGetCodepointShape(__arg0, unicode_codepoint, __arg2);
            return __ret;
        }

        public static int StbttGetGlyphShape(global::Cored.StbttFontinfo info, int glyph_index, global::Cored.StbttVertex vertices)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var ____arg2 = vertices is null ? __IntPtr.Zero : vertices.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var __ret = __Internal.StbttGetGlyphShape(__arg0, glyph_index, __arg2);
            return __ret;
        }

        public static void StbttFreeShape(global::Cored.StbttFontinfo info, global::Cored.StbttVertex vertices)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __arg1 = vertices is null ? __IntPtr.Zero : vertices.__Instance;
            __Internal.StbttFreeShape(__arg0, __arg1);
        }

        /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
        public static void StbttFreeBitmap(byte* bitmap, __IntPtr userdata)
        {
            __Internal.StbttFreeBitmap(bitmap, userdata);
        }

        public static byte* StbttGetCodepointBitmap(global::Cored.StbttFontinfo info, float scale_x, float scale_y, int codepoint, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width4 = &width)
            {
                var __arg4 = __width4;
                fixed (int* __height5 = &height)
                {
                    var __arg5 = __height5;
                    fixed (int* __xoff6 = &xoff)
                    {
                        var __arg6 = __xoff6;
                        fixed (int* __yoff7 = &yoff)
                        {
                            var __arg7 = __yoff7;
                            var __ret = __Internal.StbttGetCodepointBitmap(__arg0, scale_x, scale_y, codepoint, __arg4, __arg5, __arg6, __arg7);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static byte* StbttGetCodepointBitmapSubpixel(global::Cored.StbttFontinfo info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width6 = &width)
            {
                var __arg6 = __width6;
                fixed (int* __height7 = &height)
                {
                    var __arg7 = __height7;
                    fixed (int* __xoff8 = &xoff)
                    {
                        var __arg8 = __xoff8;
                        fixed (int* __yoff9 = &yoff)
                        {
                            var __arg9 = __yoff9;
                            var __ret = __Internal.StbttGetCodepointBitmapSubpixel(__arg0, scale_x, scale_y, shift_x, shift_y, codepoint, __arg6, __arg7, __arg8, __arg9);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static void StbttMakeCodepointBitmap(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.StbttMakeCodepointBitmap(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, codepoint);
        }

        public static void StbttMakeCodepointBitmapSubpixel(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.StbttMakeCodepointBitmapSubpixel(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, codepoint);
        }

        public static void StbttMakeCodepointBitmapSubpixelPrefilter(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, ref float sub_x, ref float sub_y, int codepoint)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (float* __sub_x11 = &sub_x)
            {
                var __arg11 = __sub_x11;
                fixed (float* __sub_y12 = &sub_y)
                {
                    var __arg12 = __sub_y12;
                    __Internal.StbttMakeCodepointBitmapSubpixelPrefilter(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, __arg11, __arg12, codepoint);
                }
            }
        }

        public static void StbttGetCodepointBitmapBox(global::Cored.StbttFontinfo font, int codepoint, float scale_x, float scale_y, ref int ix0, ref int iy0, ref int ix1, ref int iy1)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __ix04 = &ix0)
            {
                var __arg4 = __ix04;
                fixed (int* __iy05 = &iy0)
                {
                    var __arg5 = __iy05;
                    fixed (int* __ix16 = &ix1)
                    {
                        var __arg6 = __ix16;
                        fixed (int* __iy17 = &iy1)
                        {
                            var __arg7 = __iy17;
                            __Internal.StbttGetCodepointBitmapBox(__arg0, codepoint, scale_x, scale_y, __arg4, __arg5, __arg6, __arg7);
                        }
                    }
                }
            }
        }

        public static void StbttGetCodepointBitmapBoxSubpixel(global::Cored.StbttFontinfo font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, ref int ix0, ref int iy0, ref int ix1, ref int iy1)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __ix06 = &ix0)
            {
                var __arg6 = __ix06;
                fixed (int* __iy07 = &iy0)
                {
                    var __arg7 = __iy07;
                    fixed (int* __ix18 = &ix1)
                    {
                        var __arg8 = __ix18;
                        fixed (int* __iy19 = &iy1)
                        {
                            var __arg9 = __iy19;
                            __Internal.StbttGetCodepointBitmapBoxSubpixel(__arg0, codepoint, scale_x, scale_y, shift_x, shift_y, __arg6, __arg7, __arg8, __arg9);
                        }
                    }
                }
            }
        }

        public static byte* StbttGetGlyphBitmap(global::Cored.StbttFontinfo info, float scale_x, float scale_y, int glyph, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width4 = &width)
            {
                var __arg4 = __width4;
                fixed (int* __height5 = &height)
                {
                    var __arg5 = __height5;
                    fixed (int* __xoff6 = &xoff)
                    {
                        var __arg6 = __xoff6;
                        fixed (int* __yoff7 = &yoff)
                        {
                            var __arg7 = __yoff7;
                            var __ret = __Internal.StbttGetGlyphBitmap(__arg0, scale_x, scale_y, glyph, __arg4, __arg5, __arg6, __arg7);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static byte* StbttGetGlyphBitmapSubpixel(global::Cored.StbttFontinfo info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width6 = &width)
            {
                var __arg6 = __width6;
                fixed (int* __height7 = &height)
                {
                    var __arg7 = __height7;
                    fixed (int* __xoff8 = &xoff)
                    {
                        var __arg8 = __xoff8;
                        fixed (int* __yoff9 = &yoff)
                        {
                            var __arg9 = __yoff9;
                            var __ret = __Internal.StbttGetGlyphBitmapSubpixel(__arg0, scale_x, scale_y, shift_x, shift_y, glyph, __arg6, __arg7, __arg8, __arg9);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static void StbttMakeGlyphBitmap(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.StbttMakeGlyphBitmap(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, glyph);
        }

        public static void StbttMakeGlyphBitmapSubpixel(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            __Internal.StbttMakeGlyphBitmapSubpixel(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, glyph);
        }

        public static void StbttMakeGlyphBitmapSubpixelPrefilter(global::Cored.StbttFontinfo info, byte* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, ref float sub_x, ref float sub_y, int glyph)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (float* __sub_x11 = &sub_x)
            {
                var __arg11 = __sub_x11;
                fixed (float* __sub_y12 = &sub_y)
                {
                    var __arg12 = __sub_y12;
                    __Internal.StbttMakeGlyphBitmapSubpixelPrefilter(__arg0, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, oversample_x, oversample_y, __arg11, __arg12, glyph);
                }
            }
        }

        public static void StbttGetGlyphBitmapBox(global::Cored.StbttFontinfo font, int glyph, float scale_x, float scale_y, ref int ix0, ref int iy0, ref int ix1, ref int iy1)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __ix04 = &ix0)
            {
                var __arg4 = __ix04;
                fixed (int* __iy05 = &iy0)
                {
                    var __arg5 = __iy05;
                    fixed (int* __ix16 = &ix1)
                    {
                        var __arg6 = __ix16;
                        fixed (int* __iy17 = &iy1)
                        {
                            var __arg7 = __iy17;
                            __Internal.StbttGetGlyphBitmapBox(__arg0, glyph, scale_x, scale_y, __arg4, __arg5, __arg6, __arg7);
                        }
                    }
                }
            }
        }

        public static void StbttGetGlyphBitmapBoxSubpixel(global::Cored.StbttFontinfo font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, ref int ix0, ref int iy0, ref int ix1, ref int iy1)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __ix06 = &ix0)
            {
                var __arg6 = __ix06;
                fixed (int* __iy07 = &iy0)
                {
                    var __arg7 = __iy07;
                    fixed (int* __ix18 = &ix1)
                    {
                        var __arg8 = __ix18;
                        fixed (int* __iy19 = &iy1)
                        {
                            var __arg9 = __iy19;
                            __Internal.StbttGetGlyphBitmapBoxSubpixel(__arg0, glyph, scale_x, scale_y, shift_x, shift_y, __arg6, __arg7, __arg8, __arg9);
                        }
                    }
                }
            }
        }

        public static void StbttRasterize(global::Cored.StbttBitmap result, float flatness_in_pixels, global::Cored.StbttVertex vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, __IntPtr userdata)
        {
            var __arg0 = result is null ? __IntPtr.Zero : result.__Instance;
            var __arg2 = vertices is null ? __IntPtr.Zero : vertices.__Instance;
            __Internal.StbttRasterize(__arg0, flatness_in_pixels, __arg2, num_verts, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
        }

        /// <summary>///////////////////////////////////////////////////////////////////////////</summary>
        public static void StbttFreeSDF(byte* bitmap, __IntPtr userdata)
        {
            __Internal.StbttFreeSDF(bitmap, userdata);
        }

        public static byte* StbttGetGlyphSDF(global::Cored.StbttFontinfo info, float scale, int glyph, int padding, byte onedge_value, float pixel_dist_scale, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width6 = &width)
            {
                var __arg6 = __width6;
                fixed (int* __height7 = &height)
                {
                    var __arg7 = __height7;
                    fixed (int* __xoff8 = &xoff)
                    {
                        var __arg8 = __xoff8;
                        fixed (int* __yoff9 = &yoff)
                        {
                            var __arg9 = __yoff9;
                            var __ret = __Internal.StbttGetGlyphSDF(__arg0, scale, glyph, padding, onedge_value, pixel_dist_scale, __arg6, __arg7, __arg8, __arg9);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static byte* StbttGetCodepointSDF(global::Cored.StbttFontinfo info, float scale, int codepoint, int padding, byte onedge_value, float pixel_dist_scale, ref int width, ref int height, ref int xoff, ref int yoff)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            fixed (int* __width6 = &width)
            {
                var __arg6 = __width6;
                fixed (int* __height7 = &height)
                {
                    var __arg7 = __height7;
                    fixed (int* __xoff8 = &xoff)
                    {
                        var __arg8 = __xoff8;
                        fixed (int* __yoff9 = &yoff)
                        {
                            var __arg9 = __yoff9;
                            var __ret = __Internal.StbttGetCodepointSDF(__arg0, scale, codepoint, padding, onedge_value, pixel_dist_scale, __arg6, __arg7, __arg8, __arg9);
                            return __ret;
                        }
                    }
                }
            }
        }

        public static int StbttFindMatchingFont(byte* fontdata, string name, int flags)
        {
            var __ret = __Internal.StbttFindMatchingFont(fontdata, name, flags);
            return __ret;
        }

        public static int StbttCompareUTF8toUTF16Bigendian(string s1, int len1, string s2, int len2)
        {
            var __ret = __Internal.StbttCompareUTF8toUTF16Bigendian(s1, len1, s2, len2);
            return __ret;
        }

        public static string StbttGetFontNameString(global::Cored.StbttFontinfo font, ref int length, int platformID, int encodingID, int languageID, int nameID)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            fixed (int* __length1 = &length)
            {
                var __arg1 = __length1;
                var __ret = __Internal.StbttGetFontNameString(__arg0, __arg1, platformID, encodingID, languageID, nameID);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr__MarshalAs_UnmanagedType_CustomMarshaler__MarshalTypeRef___typeof_CppSharp_Runtime_UTF8Marshaller____string(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_Cored_ImVec2___Internal(__IntPtr vp, global::Cored.ImVec2.__Internal pos);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::Cored.ImVec2.__Internal Func_Cored_ImVec2___Internal___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_float(__IntPtr vp, float alpha);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr vp, __IntPtr render_arg);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ulong___IntPtr_ulongPtr(__IntPtr vp, ulong vk_inst, __IntPtr vk_allocators, ulong* out_vk_surface);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr_int_sbytePtrPtr(__IntPtr data, int idx, sbyte** out_text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr_int(__IntPtr data, int idx);
    }
}
namespace Cored.__Symbols
{
    internal class Cored
    {
        public static IntPtr _EmptyString_ImGuiTextBuffer__2PADA { get; }
        static Cored()
        {
            var path = "Cored";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new System.DllNotFoundException(path);
            _EmptyString_ImGuiTextBuffer__2PADA = CppSharp.SymbolResolver.ResolveSymbol(image, "?EmptyString@ImGuiTextBuffer@@2PADA");
        }
    }
}

