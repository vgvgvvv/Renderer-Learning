// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Worldd
{
    public unsafe partial class Component : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr vfptr_Component;
            internal __IntPtr owner;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0Component@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0Component@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?GetOwner@Component@@QEBAAEAVGameObject@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetOwner(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.Component> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.Component>();

        protected bool __ownsNativeInstance;

        internal static Component __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Component(native.ToPointer(), skipVTables);
        }

        internal static Component __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Component)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Component __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (Component)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static Component __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Component(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Worldd.Component.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Component(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Component(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
            if (!skipVTables)
                SetupVTables(true);
        }

        public Component()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.Component.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "Worldd.Component");
        }

        public Component(global::Worldd.Component _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.Component.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "Worldd.Component");
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            ((global::Worldd.Component.__Internal*) __Instance)->vfptr_Component = __VTables.Tables[0];
            if (disposing)
            {
                var ___dtorDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_int>(0, 0);
                ___dtorDelegate(__Instance, 0);
            }
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public virtual void Awake()
        {
            var ___AwakeDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr>(0, 1);
            ___AwakeDelegate(__Instance);
        }

        public virtual void BeginDestroy()
        {
            var ___BeginDestroyDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr>(0, 2);
            ___BeginDestroyDelegate(__Instance);
        }

        public global::Worldd.GameObject Owner
        {
            get
            {
                var __ret = __Internal.GetOwner(__Instance);
                var __result0 = global::Worldd.GameObject.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        #region Virtual table interop

        // virtual ~Component() = default
        private static global::Worldd.Delegates.Action___IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance, int delete)
        {
            var __target = global::Worldd.Component.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void Awake()
        private static global::Worldd.Delegates.Action___IntPtr _AwakeDelegateInstance;

        private static void _AwakeDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.Component.__GetInstance(__instance);
            __target.Awake();
        }

        // void BeginDestroy()
        private static global::Worldd.Delegates.Action___IntPtr _BeginDestroyDelegateInstance;

        private static void _BeginDestroyDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.Component.__GetInstance(__instance);
            __target.BeginDestroy();
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[3];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _AwakeDelegateInstance += _AwakeDelegateHook;
                _BeginDestroyDelegateInstance += _BeginDestroyDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AwakeDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_BeginDestroyDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3);
                            ManagedVTablesDtorOnly[0][0] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            VTables.Methods[0] = new Delegate[3];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class Behavior : global::Worldd.Component, IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public new partial struct __Internal
        {
            internal __IntPtr vfptr_Component;
            internal __IntPtr owner;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0Behavior@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0Behavior@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);
        }

        internal static new Behavior __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Behavior(native.ToPointer(), skipVTables);
        }

        internal static new Behavior __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Behavior)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static new Behavior __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (Behavior)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static Behavior __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Behavior(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Worldd.Behavior.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private Behavior(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Behavior(void* native, bool skipVTables = false)
            : base((void*) native)
        {
            if (native == null)
                return;
            if (!skipVTables)
                SetupVTables(true);
        }

        public Behavior(global::Worldd.Behavior _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.Behavior.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "Worldd.Behavior");
        }

        public Behavior()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.Behavior.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "Worldd.Behavior");
        }

        public override void Awake()
        {
            base.Awake();
        }

        public virtual void PreUpdate(float deltaTime)
        {
            var ___PreUpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 3);
            ___PreUpdateDelegate(__Instance, deltaTime);
        }

        public virtual void Update(float deltaTime)
        {
            var ___UpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 4);
            ___UpdateDelegate(__Instance, deltaTime);
        }

        public virtual void LateUpdate(float deltaTime)
        {
            var ___LateUpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 5);
            ___LateUpdateDelegate(__Instance, deltaTime);
        }

        public override void BeginDestroy()
        {
            base.BeginDestroy();
        }

        #region Virtual table interop

        // Behavior
        private static global::Worldd.Delegates.Action___IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance, int delete)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void Awake() override
        private static global::Worldd.Delegates.Action___IntPtr _AwakeDelegateInstance;

        private static void _AwakeDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.Awake();
        }

        // void BeginDestroy() override
        private static global::Worldd.Delegates.Action___IntPtr _BeginDestroyDelegateInstance;

        private static void _BeginDestroyDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.BeginDestroy();
        }

        // void PreUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _PreUpdateDelegateInstance;

        private static void _PreUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.PreUpdate(deltaTime);
        }

        // void Update(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.Update(deltaTime);
        }

        // void LateUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _LateUpdateDelegateInstance;

        private static void _LateUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.Behavior.__GetInstance(__instance);
            __target.LateUpdate(deltaTime);
        }

        internal static new class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[6];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _AwakeDelegateInstance += _AwakeDelegateHook;
                _BeginDestroyDelegateInstance += _BeginDestroyDelegateHook;
                _PreUpdateDelegateInstance += _PreUpdateDelegateHook;
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _LateUpdateDelegateInstance += _LateUpdateDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AwakeDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_BeginDestroyDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_PreUpdateDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_LateUpdateDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTablesDtorOnly[0][0] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            VTables.Methods[0] = new Delegate[6];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        internal override CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal override void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class BehaviorManager : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr vfptr_BehaviorManager;
            internal global::Std.List.__Internalc__N_std_S_list_____S_Behavior___N_std_S_allocator__S0_ behaviors;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??1BehaviorManager@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Get@BehaviorManager@@SAAEAV1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Add@BehaviorManager@@QEAAXPEAVBehavior@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Add(__IntPtr __instance, __IntPtr behavior);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Remove@BehaviorManager@@QEAAXPEAVBehavior@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Remove(__IntPtr __instance, __IntPtr behavior);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.BehaviorManager> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.BehaviorManager>();

        protected bool __ownsNativeInstance;

        internal static BehaviorManager __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BehaviorManager(native.ToPointer(), skipVTables);
        }

        internal static BehaviorManager __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BehaviorManager)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BehaviorManager __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (BehaviorManager)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static BehaviorManager __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BehaviorManager(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private BehaviorManager(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BehaviorManager(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            ((global::Worldd.BehaviorManager.__Internal*) __Instance)->vfptr_BehaviorManager = __VTables.Tables[0];
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Add(global::Worldd.Behavior behavior)
        {
            var __arg0 = behavior is null ? __IntPtr.Zero : behavior.__Instance;
            __Internal.Add(__Instance, __arg0);
        }

        public void Remove(global::Worldd.Behavior behavior)
        {
            var __arg0 = behavior is null ? __IntPtr.Zero : behavior.__Instance;
            __Internal.Remove(__Instance, __arg0);
        }

        public virtual void PreUpdate(float deltaTime)
        {
            var ___PreUpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 0);
            ___PreUpdateDelegate(__Instance, deltaTime);
        }

        public virtual void Update(float deltaTime)
        {
            var ___UpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 1);
            ___UpdateDelegate(__Instance, deltaTime);
        }

        public virtual void LateUpdate(float deltaTime)
        {
            var ___LateUpdateDelegate = __VTables.GetMethodDelegate<global::Worldd.Delegates.Action___IntPtr_float>(0, 2);
            ___LateUpdateDelegate(__Instance, deltaTime);
        }

        public static global::Worldd.BehaviorManager Get()
        {
            var __ret = __Internal.Get();
            var __result0 = global::Worldd.BehaviorManager.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        #region Virtual table interop

        // void PreUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _PreUpdateDelegateInstance;

        private static void _PreUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.BehaviorManager.__GetInstance(__instance);
            __target.PreUpdate(deltaTime);
        }

        // void Update(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.BehaviorManager.__GetInstance(__instance);
            __target.Update(deltaTime);
        }

        // void LateUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _LateUpdateDelegateInstance;

        private static void _LateUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.BehaviorManager.__GetInstance(__instance);
            __target.LateUpdate(deltaTime);
        }

        internal static class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[3];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _PreUpdateDelegateInstance += _PreUpdateDelegateHook;
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _LateUpdateDelegateInstance += _LateUpdateDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_PreUpdateDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_LateUpdateDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 3);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            VTables.Methods[0] = new Delegate[3];
                            if (destructorOnly)
                                return VTables;
                        }
                    }
                }

                *(IntPtr**)(instance + 0) = ManagedVTables[0];
                return VTables;
            }
        }

        protected CppSharp.Runtime.VTables __vtables;
        internal virtual CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal virtual void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public unsafe partial class DotNetBehavior : global::Worldd.Behavior, IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public new partial struct __Internal
        {
            internal __IntPtr vfptr_Component;
            internal __IntPtr owner;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0DotNetBehavior@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0DotNetBehavior@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        internal static new DotNetBehavior __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DotNetBehavior(native.ToPointer(), skipVTables);
        }

        internal static new DotNetBehavior __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DotNetBehavior)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static new DotNetBehavior __GetInstance(__IntPtr native)
        {
            if (!NativeToManagedMap.TryGetValue(native, out var managed))
                throw new System.Exception("No managed instance was found");
            var result = (DotNetBehavior)managed;
            if (result.__ownsNativeInstance)
                result.SetupVTables();
            return result;
        }

        internal static DotNetBehavior __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DotNetBehavior(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Worldd.DotNetBehavior.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private DotNetBehavior(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DotNetBehavior(void* native, bool skipVTables = false)
            : base((void*) native)
        {
            if (native == null)
                return;
            if (!skipVTables)
                SetupVTables(true);
        }

        public DotNetBehavior()
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.DotNetBehavior.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
            SetupVTables(GetType().FullName == "Worldd.DotNetBehavior");
        }

        public DotNetBehavior(global::Worldd.DotNetBehavior _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.DotNetBehavior.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
            SetupVTables(GetType().FullName == "Worldd.DotNetBehavior");
        }

        #region Virtual table interop

        // DotNetBehavior
        private static global::Worldd.Delegates.Action___IntPtr_int _dtorDelegateInstance;

        private static void _dtorDelegateHook(__IntPtr __instance, int delete)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.Dispose(true);
        }

        // void Awake() override
        private static global::Worldd.Delegates.Action___IntPtr _AwakeDelegateInstance;

        private static void _AwakeDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.Awake();
        }

        // void BeginDestroy() override
        private static global::Worldd.Delegates.Action___IntPtr _BeginDestroyDelegateInstance;

        private static void _BeginDestroyDelegateHook(__IntPtr __instance)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.BeginDestroy();
        }

        // void PreUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _PreUpdateDelegateInstance;

        private static void _PreUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.PreUpdate(deltaTime);
        }

        // void Update(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _UpdateDelegateInstance;

        private static void _UpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.Update(deltaTime);
        }

        // void LateUpdate(float deltaTime)
        private static global::Worldd.Delegates.Action___IntPtr_float _LateUpdateDelegateInstance;

        private static void _LateUpdateDelegateHook(__IntPtr __instance, float deltaTime)
        {
            var __target = global::Worldd.DotNetBehavior.__GetInstance(__instance);
            __target.LateUpdate(deltaTime);
        }

        internal static new class VTableLoader
        {
            private static volatile bool initialized;
            private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
            private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
            private static readonly IntPtr[] Thunks = new IntPtr[6];
            private static CppSharp.Runtime.VTables VTables;
            private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

            static VTableLoader()
            {
                _dtorDelegateInstance += _dtorDelegateHook;
                _AwakeDelegateInstance += _AwakeDelegateHook;
                _BeginDestroyDelegateInstance += _BeginDestroyDelegateHook;
                _PreUpdateDelegateInstance += _PreUpdateDelegateHook;
                _UpdateDelegateInstance += _UpdateDelegateHook;
                _LateUpdateDelegateInstance += _LateUpdateDelegateHook;
                Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                Thunks[1] = Marshal.GetFunctionPointerForDelegate(_AwakeDelegateInstance);
                Thunks[2] = Marshal.GetFunctionPointerForDelegate(_BeginDestroyDelegateInstance);
                Thunks[3] = Marshal.GetFunctionPointerForDelegate(_PreUpdateDelegateInstance);
                Thunks[4] = Marshal.GetFunctionPointerForDelegate(_UpdateDelegateInstance);
                Thunks[5] = Marshal.GetFunctionPointerForDelegate(_LateUpdateDelegateInstance);
            }

            public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
            {
                if (!initialized)
                {
                    lock (ManagedVTables)
                    {
                        if (!initialized)
                        {
                            initialized = true;
                            VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                            VTables.Methods = new Delegate[1][];
                            ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTablesDtorOnly[0][0] = Thunks[0];
                            ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 6);
                            ManagedVTables[0][0] = Thunks[0];
                            ManagedVTables[0][1] = Thunks[1];
                            ManagedVTables[0][2] = Thunks[2];
                            ManagedVTables[0][3] = Thunks[3];
                            ManagedVTables[0][4] = Thunks[4];
                            ManagedVTables[0][5] = Thunks[5];
                            VTables.Methods[0] = new Delegate[6];
                        }
                    }
                }

                if (destructorOnly)
                {
                    *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                }
                else
                {
                    *(IntPtr**)(instance + 0) = ManagedVTables[0];
                }
                return VTables;
            }
        }

        internal override CppSharp.Runtime.VTables __VTables
        { 
            get {
                if (__vtables.IsEmpty)
                    __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                return __vtables;
            }

            set {        
                __vtables = value;
            }
        }

        internal override void SetupVTables(bool destructorOnly = false)
        {
            if (__VTables.IsTransient)
                __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
        }
        #endregion
    }

    public enum GameObjectFlag
    {
        None = 0,
        HideAndNotSave = 1
    }

    public unsafe partial class Transform
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.Transform>();

        protected bool __ownsNativeInstance;

        internal static Transform __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Transform(native.ToPointer(), skipVTables);
        }

        internal static Transform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (Transform)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static Transform __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Transform(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Transform(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Transform(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class GameObject : global::Worldd.BaseObject, IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 144)]
        public new partial struct __Internal
        {
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C guid;
            internal global::Worldd.GameObjectFlag flag;
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;
            internal global::Std.SharedPtr.__Internal transform;
            internal __IntPtr owner;
            internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_shared_ptr____S_Component___N_std_S_allocator__S0_ components;
            internal global::Std.List.__Internalc__N_std_S_list_____S_GameObject___N_std_S_allocator__S0_ children;
            internal byte isDestroyed;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0GameObject@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4GameObjectFlag@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance, __IntPtr name, global::Worldd.GameObjectFlag flag);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0GameObject@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??1GameObject@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?CreateGameObject@GameObject@@SAPEAV1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4GameObjectFlag@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateGameObject(__IntPtr name, global::Worldd.GameObjectFlag flag);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Destroy@GameObject@@SAXPEAV1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Destroy(__IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?OnAwake@GameObject@@IEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnAwake(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?OnDestory@GameObject@@IEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void OnDestory(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?GetName@GameObject@@QEBAAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetName(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?SetName@GameObject@@QEAAXAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetName(__IntPtr __instance, __IntPtr name);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?GetParent@GameObject@@QEBAPEBV1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetParent(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?SetParent@GameObject@@QEAAXPEAV1@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetParent(__IntPtr __instance, __IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?IsDestroyed@GameObject@@QEBA_NXZ", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool IsDestroyed(__IntPtr __instance);
        }

        internal static new GameObject __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GameObject(native.ToPointer(), skipVTables);
        }

        internal static new GameObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (GameObject)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static GameObject __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GameObject(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Worldd.GameObject.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private GameObject(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected GameObject(void* native, bool skipVTables = false)
            : base((void*) native)
        {
        }

        public GameObject(string name, global::Worldd.GameObjectFlag flag)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, name);
            var __arg0 = __basicString0.__Instance;
            __Internal.ctor(__Instance, __arg0, flag);
            __basicString0.Dispose();
        }

        public GameObject(global::Worldd.GameObject _0)
            : this((void*) null)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.GameObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public override void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        protected void OnAwake()
        {
            __Internal.OnAwake(__Instance);
        }

        protected void OnDestory()
        {
            __Internal.OnDestory(__Instance);
        }

        public static global::Worldd.GameObject CreateGameObject(string name, global::Worldd.GameObjectFlag flag)
        {
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, name);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateGameObject(__arg0, flag);
            __basicString0.Dispose();
            var __result0 = global::Worldd.GameObject.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Destroy(global::Worldd.GameObject gameObject)
        {
            var __arg0 = gameObject is null ? __IntPtr.Zero : gameObject.__Instance;
            __Internal.Destroy(__arg0);
        }

        public global::Worldd.GameObjectFlag Flag
        {
            get
            {
                return ((__Internal*)__Instance)->flag;
            }

            set
            {
                ((__Internal*)__Instance)->flag = value;
            }
        }

        public string Name
        {
            get
            {
                var __ret = __Internal.GetName(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                global::Std.BasicStringExtensions.Assign(__basicString0, value);
                var __arg0 = __basicString0.__Instance;
                __Internal.SetName(__Instance, __arg0);
                __basicString0.Dispose();
            }
        }

        public global::Worldd.GameObject Parent
        {
            get
            {
                var __ret = __Internal.GetParent(__Instance);
                var __result0 = global::Worldd.GameObject.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            set
            {
                var __arg0 = value is null ? __IntPtr.Zero : value.__Instance;
                __Internal.SetParent(__Instance, __arg0);
            }
        }

        public bool IsDestroyed
        {
            get
            {
                var __ret = __Internal.IsDestroyed(__Instance);
                return __ret;
            }
        }
    }

    public unsafe partial class BaseObject : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C guid;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0BaseObject@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr ctor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??0BaseObject@@QEAA@AEBV0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??1BaseObject@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?GetGuid@BaseObject@@QEBAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetGuid(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.BaseObject> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.BaseObject>();

        protected bool __ownsNativeInstance;

        internal static BaseObject __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new BaseObject(native.ToPointer(), skipVTables);
        }

        internal static BaseObject __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (BaseObject)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static BaseObject __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new BaseObject(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            global::Worldd.BaseObject.__Internal.cctor(ret, new __IntPtr(&native));
            return ret.ToPointer();
        }

        private BaseObject(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected BaseObject(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public BaseObject()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.BaseObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            __Internal.ctor(__Instance);
        }

        public BaseObject(global::Worldd.BaseObject _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Worldd.BaseObject.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            if (ReferenceEquals(_0, null))
                throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
            var __arg0 = _0.__Instance;
            __Internal.cctor(__Instance, __arg0);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        protected string guid
        {
            get
            {
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->guid));
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }

            set
            {
                global::Std.BasicStringExtensions.__Internal.Assign(new __IntPtr(&((__Internal*)__Instance)->guid), value);
            }
        }

        public string Guid
        {
            get
            {
                var __ret = __Internal.GetGuid(__Instance);
                var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(__ret);
                return global::Std.BasicStringExtensions.Data(__basicStringRet0);
            }
        }
    }

    public unsafe partial class World : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal global::Std.List.__Internalc__N_std_S_list_____S_GameObject___N_std_S_allocator__S0_ gameObjects;

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "??1World@@QEAA@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void dtor(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Get@World@@SAAEAV1@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr Get();

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?Init@World@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Init(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?CreateEmpty@World@@QEAAPEAVGameObject@@XZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateEmpty(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?CreateGameObject@World@@QEAAPEAVGameObject@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4GameObjectFlag@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr CreateGameObject(__IntPtr __instance, __IntPtr name, global::Worldd.GameObjectFlag flag);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?DestroyGameObject@World@@QEAAXPEAVGameObject@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DestroyGameObject(__IntPtr __instance, __IntPtr gameObject);

            [SuppressUnmanagedCodeSecurity, DllImport("Worldd", EntryPoint = "?RemoveAllDestroyedGameObjects@World@@QEAAXXZ", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RemoveAllDestroyedGameObjects(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.World> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Worldd.World>();

        protected bool __ownsNativeInstance;

        internal static World __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new World(native.ToPointer(), skipVTables);
        }

        internal static World __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (World)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static World __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new World(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private World(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected World(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (disposing)
                __Internal.dtor(__Instance);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Init()
        {
            __Internal.Init(__Instance);
        }

        public global::Worldd.GameObject CreateEmpty()
        {
            var __ret = __Internal.CreateEmpty(__Instance);
            var __result0 = global::Worldd.GameObject.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public global::Worldd.GameObject CreateGameObject(string name, global::Worldd.GameObjectFlag flag)
        {
            var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
            global::Std.BasicStringExtensions.Assign(__basicString0, name);
            var __arg0 = __basicString0.__Instance;
            var __ret = __Internal.CreateGameObject(__Instance, __arg0, flag);
            __basicString0.Dispose();
            var __result0 = global::Worldd.GameObject.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public void DestroyGameObject(global::Worldd.GameObject gameObject)
        {
            var __arg0 = gameObject is null ? __IntPtr.Zero : gameObject.__Instance;
            __Internal.DestroyGameObject(__Instance, __arg0);
        }

        public void RemoveAllDestroyedGameObjects()
        {
            __Internal.RemoveAllDestroyedGameObjects(__Instance);
        }

        public static global::Worldd.World Get()
        {
            var __ret = __Internal.Get();
            var __result0 = global::Worldd.World.__GetOrCreateInstance(__ret, false);
            return __result0;
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_int(__IntPtr __instance, int arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_float(__IntPtr __instance, float arg1);
    }
}

namespace Std
{
    namespace _List_node
    {
        [StructLayout(LayoutKind.Sequential, Size = 24, Pack = 8)]
        public unsafe partial struct __Internal_Ptr
        {
            internal __IntPtr _Next;
            internal __IntPtr _Prev;
            internal __IntPtr _Myval;
        }
    }
}
