//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace UniToLua
{
    using MathLib;
    using System;
    
    
    public class MathLib1MathfWrap
    {
        
        public static void Register(UniLua.ILuaState L)
        {
			L.BeginClass(typeof(MathLib.Mathf), typeof(System.ValueType));
			L.RegFunction("New", _CreateMathLib1Mathf);
			L.RegVar("Epsilon", get_Epsilon, null);
			L.RegVar("PI", get_PI, null);
			L.RegVar("Infinity", get_Infinity, null);
			L.RegVar("NegativeInfinity", get_NegativeInfinity, null);
			L.RegVar("Deg2Rad", get_Deg2Rad, null);
			L.RegVar("Rad2Deg", get_Rad2Deg, null);
			L.RegFunction("Sin", Sin);
			L.RegFunction("Cos", Cos);
			L.RegFunction("Tan", Tan);
			L.RegFunction("Asin", Asin);
			L.RegFunction("Acos", Acos);
			L.RegFunction("Atan", Atan);
			L.RegFunction("Atan2", Atan2);
			L.RegFunction("Sqrt", Sqrt);
			L.RegFunction("Abs", Abs);
			L.RegFunction("Min", Min);
			L.RegFunction("Max", Max);
			L.RegFunction("Pow", Pow);
			L.RegFunction("Exp", Exp);
			L.RegFunction("Log", Log);
			L.RegFunction("Log10", Log10);
			L.RegFunction("Ceil", Ceil);
			L.RegFunction("Floor", Floor);
			L.RegFunction("Round", Round);
			L.RegFunction("CeilToInt", CeilToInt);
			L.RegFunction("FloorToInt", FloorToInt);
			L.RegFunction("RoundToInt", RoundToInt);
			L.RegFunction("Sign", Sign);
			L.RegFunction("Clamp", Clamp);
			L.RegFunction("Clamp01", Clamp01);
			L.RegFunction("Lerp", Lerp);
			L.RegFunction("LerpUnclamped", LerpUnclamped);
			L.RegFunction("LerpAngle", LerpAngle);
			L.RegFunction("MoveTowards", MoveTowards);
			L.RegFunction("MoveTowardsAngle", MoveTowardsAngle);
			L.RegFunction("SmoothStep", SmoothStep);
			L.RegFunction("Gamma", Gamma);
			L.RegFunction("Approximately", Approximately);
			L.RegFunction("Repeat", Repeat);
			L.RegFunction("PingPong", PingPong);
			L.RegFunction("InverseLerp", InverseLerp);
			L.RegFunction("DeltaAngle", DeltaAngle);
			L.RegFunction("ClosestPowerOfTwo", ClosestPowerOfTwo);
			L.RegFunction("IsPowerOfTwo", IsPowerOfTwo);
			L.RegFunction("NextPowerOfTwo", NextPowerOfTwo);
			L.RegFunction("GammaToLinearSpace", GammaToLinearSpace);
			L.RegFunction("LinearToGammaSpace", LinearToGammaSpace);
			L.RegFunction("CorrelatedColorTemperatureToRGB", CorrelatedColorTemperatureToRGB);
			L.RegFunction("FloatToHalf", FloatToHalf);
			L.RegFunction("HalfToFloat", HalfToFloat);
			L.RegFunction("PerlinNoise", PerlinNoise);
			L.RegFunction("Equals", Equals);
			L.RegFunction("GetHashCode", GetHashCode);
			L.RegFunction("ToString", ToString);
			L.RegFunction("GetType", GetType);
			L.EndClass();
        }
        
        private static int _CreateMathLib1Mathf(UniLua.ILuaState L)
        {
			L.L_Error("call Mathf constructor args is error");
			return 1;
        }
        
        private static int get_Epsilon(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.Epsilon);
			return 1;
        }
        
        private static int get_PI(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.PI);
			return 1;
        }
        
        private static int get_Infinity(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.Infinity);
			return 1;
        }
        
        private static int get_NegativeInfinity(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.NegativeInfinity);
			return 1;
        }
        
        private static int get_Deg2Rad(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.Deg2Rad);
			return 1;
        }
        
        private static int get_Rad2Deg(UniLua.ILuaState L)
        {
			L.PushAny<float>(MathLib.Mathf.Rad2Deg);
			return 1;
        }
        
        private static int Sin(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Sin(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Sin args is error");
			return 1;
        }
        
        private static int Cos(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Cos(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Cos args is error");
			return 1;
        }
        
        private static int Tan(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Tan(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Tan args is error");
			return 1;
        }
        
        private static int Asin(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Asin(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Asin args is error");
			return 1;
        }
        
        private static int Acos(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Acos(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Acos args is error");
			return 1;
        }
        
        private static int Atan(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Atan(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Atan args is error");
			return 1;
        }
        
        private static int Atan2(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Atan2(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Atan2 args is error");
			return 1;
        }
        
        private static int Sqrt(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Sqrt(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Sqrt args is error");
			return 1;
        }
        
        private static int Abs(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Abs(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<int>(1))
			{
				int result;
				var arg1 = L.CheckAny<int>(1);
				result = MathLib.Mathf.Abs(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function Abs args is error");
			return 1;
        }
        
        private static int Min(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Min(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<float[]>(1))
			{
				float result;
				var arg1 = L.CheckAny<float[]>(1);
				result = MathLib.Mathf.Min(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(2) && L.CheckType<int, int>(1))
			{
				int result;
				var arg1 = L.CheckAny<int>(1);
				var arg2 = L.CheckAny<int>(2);
				result = MathLib.Mathf.Min(arg1, arg2);
				L.PushAny<int>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<int[]>(1))
			{
				int result;
				var arg1 = L.CheckAny<int[]>(1);
				result = MathLib.Mathf.Min(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function Min args is error");
			return 1;
        }
        
        private static int Max(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Max(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<float[]>(1))
			{
				float result;
				var arg1 = L.CheckAny<float[]>(1);
				result = MathLib.Mathf.Max(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(2) && L.CheckType<int, int>(1))
			{
				int result;
				var arg1 = L.CheckAny<int>(1);
				var arg2 = L.CheckAny<int>(2);
				result = MathLib.Mathf.Max(arg1, arg2);
				L.PushAny<int>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<int[]>(1))
			{
				int result;
				var arg1 = L.CheckAny<int[]>(1);
				result = MathLib.Mathf.Max(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function Max args is error");
			return 1;
        }
        
        private static int Pow(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Pow(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Pow args is error");
			return 1;
        }
        
        private static int Exp(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Exp(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Exp args is error");
			return 1;
        }
        
        private static int Log(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Log(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Log(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Log args is error");
			return 1;
        }
        
        private static int Log10(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Log10(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Log10 args is error");
			return 1;
        }
        
        private static int Ceil(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Ceil(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Ceil args is error");
			return 1;
        }
        
        private static int Floor(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Floor(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Floor args is error");
			return 1;
        }
        
        private static int Round(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Round(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Round args is error");
			return 1;
        }
        
        private static int CeilToInt(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				int result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.CeilToInt(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function CeilToInt args is error");
			return 1;
        }
        
        private static int FloorToInt(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				int result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.FloorToInt(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function FloorToInt args is error");
			return 1;
        }
        
        private static int RoundToInt(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				int result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.RoundToInt(arg1);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function RoundToInt args is error");
			return 1;
        }
        
        private static int Sign(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Sign(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Sign args is error");
			return 1;
        }
        
        private static int Clamp(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.Clamp(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			else if(L.CheckNum(3) && L.CheckType<int, int, int>(1))
			{
				int result;
				var arg1 = L.CheckAny<int>(1);
				var arg2 = L.CheckAny<int>(2);
				var arg3 = L.CheckAny<int>(3);
				result = MathLib.Mathf.Clamp(arg1, arg2, arg3);
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function Clamp args is error");
			return 1;
        }
        
        private static int Clamp01(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.Clamp01(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Clamp01 args is error");
			return 1;
        }
        
        private static int Lerp(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.Lerp(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Lerp args is error");
			return 1;
        }
        
        private static int LerpUnclamped(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.LerpUnclamped(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function LerpUnclamped args is error");
			return 1;
        }
        
        private static int LerpAngle(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.LerpAngle(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function LerpAngle args is error");
			return 1;
        }
        
        private static int MoveTowards(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.MoveTowards(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function MoveTowards args is error");
			return 1;
        }
        
        private static int MoveTowardsAngle(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.MoveTowardsAngle(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function MoveTowardsAngle args is error");
			return 1;
        }
        
        private static int SmoothStep(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.SmoothStep(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function SmoothStep args is error");
			return 1;
        }
        
        private static int Gamma(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.Gamma(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Gamma args is error");
			return 1;
        }
        
        private static int Approximately(UniLua.ILuaState L)
        {
			if(L.CheckRange(2, 3) && L.CheckType<float, float>(1))
			{
				var top = L.GetTop();
				bool result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = default(System.Nullable<float>);				
				if(3 + 1 > top)
				{
					arg3 = L.CheckAny<System.Nullable<float>>(3);
					result = MathLib.Mathf.Approximately(arg1, arg2, arg3);
					L.PushAny<bool>(result);
					return 1;
				}
				result = MathLib.Mathf.Approximately(arg1, arg2);
				L.PushAny<bool>(result);
				return 1;
			}
			L.L_Error("call function Approximately args is error");
			return 1;
        }
        
        private static int Repeat(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.Repeat(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function Repeat args is error");
			return 1;
        }
        
        private static int PingPong(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.PingPong(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function PingPong args is error");
			return 1;
        }
        
        private static int InverseLerp(UniLua.ILuaState L)
        {
			if(L.CheckNum(3) && L.CheckType<float, float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				var arg3 = L.CheckAny<float>(3);
				result = MathLib.Mathf.InverseLerp(arg1, arg2, arg3);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function InverseLerp args is error");
			return 1;
        }
        
        private static int DeltaAngle(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.DeltaAngle(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function DeltaAngle args is error");
			return 1;
        }
        
        private static int ClosestPowerOfTwo(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<uint>(1))
			{
				uint result;
				var arg1 = L.CheckAny<uint>(1);
				result = MathLib.Mathf.ClosestPowerOfTwo(arg1);
				L.PushAny<uint>(result);
				return 1;
			}
			L.L_Error("call function ClosestPowerOfTwo args is error");
			return 1;
        }
        
        private static int IsPowerOfTwo(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<int>(1))
			{
				bool result;
				var arg1 = L.CheckAny<int>(1);
				result = MathLib.Mathf.IsPowerOfTwo(arg1);
				L.PushAny<bool>(result);
				return 1;
			}
			L.L_Error("call function IsPowerOfTwo args is error");
			return 1;
        }
        
        private static int NextPowerOfTwo(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<uint>(1))
			{
				uint result;
				var arg1 = L.CheckAny<uint>(1);
				result = MathLib.Mathf.NextPowerOfTwo(arg1);
				L.PushAny<uint>(result);
				return 1;
			}
			L.L_Error("call function NextPowerOfTwo args is error");
			return 1;
        }
        
        private static int GammaToLinearSpace(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.GammaToLinearSpace(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function GammaToLinearSpace args is error");
			return 1;
        }
        
        private static int LinearToGammaSpace(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.LinearToGammaSpace(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function LinearToGammaSpace args is error");
			return 1;
        }
        
        private static int CorrelatedColorTemperatureToRGB(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				MathLib.Color result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.CorrelatedColorTemperatureToRGB(arg1);
				L.PushAny<MathLib.Color>(result);
				return 1;
			}
			L.L_Error("call function CorrelatedColorTemperatureToRGB args is error");
			return 1;
        }
        
        private static int FloatToHalf(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<float>(1))
			{
				ushort result;
				var arg1 = L.CheckAny<float>(1);
				result = MathLib.Mathf.FloatToHalf(arg1);
				L.PushAny<ushort>(result);
				return 1;
			}
			L.L_Error("call function FloatToHalf args is error");
			return 1;
        }
        
        private static int HalfToFloat(UniLua.ILuaState L)
        {
			if(L.CheckNum(1) && L.CheckType<ushort>(1))
			{
				float result;
				var arg1 = L.CheckAny<ushort>(1);
				result = MathLib.Mathf.HalfToFloat(arg1);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function HalfToFloat args is error");
			return 1;
        }
        
        private static int PerlinNoise(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<float, float>(1))
			{
				float result;
				var arg1 = L.CheckAny<float>(1);
				var arg2 = L.CheckAny<float>(2);
				result = MathLib.Mathf.PerlinNoise(arg1, arg2);
				L.PushAny<float>(result);
				return 1;
			}
			L.L_Error("call function PerlinNoise args is error");
			return 1;
        }
        
        private static int Equals(UniLua.ILuaState L)
        {
			if(L.CheckNum(2) && L.CheckType<MathLib.Mathf, object>(1))
			{
				bool result;
				var obj = (MathLib.Mathf) L.ToUserData(1);
				var arg1 = L.CheckAny<object>(2);
				result = obj.Equals(arg1);
				L.PushAny<bool>(result);
				return 1;
			}
			L.L_Error("call function Equals args is error");
			return 1;
        }
        
        private static int GetHashCode(UniLua.ILuaState L)
        {
			if(L.CheckNum(1))
			{
				int result;
				var obj = (MathLib.Mathf) L.ToUserData(1);
				result = obj.GetHashCode();
				L.PushAny<int>(result);
				return 1;
			}
			L.L_Error("call function GetHashCode args is error");
			return 1;
        }
        
        private static int ToString(UniLua.ILuaState L)
        {
			if(L.CheckNum(1))
			{
				string result;
				var obj = (MathLib.Mathf) L.ToUserData(1);
				result = obj.ToString();
				L.PushAny<string>(result);
				return 1;
			}
			L.L_Error("call function ToString args is error");
			return 1;
        }
        
        private static int GetType(UniLua.ILuaState L)
        {
			if(L.CheckNum(1))
			{
				System.Type result;
				var obj = (MathLib.Mathf) L.ToUserData(1);
				result = obj.GetType();
				L.PushAny<System.Type>(result);
				return 1;
			}
			L.L_Error("call function GetType args is error");
			return 1;
        }
    }
}
